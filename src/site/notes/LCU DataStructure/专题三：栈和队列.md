---
{"dg-publish":true,"tags":["LCU数据结构"],"permalink":"/LCU DataStructure/专题三：栈和队列/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-12-21T15:40:03.574+08:00","updated":"2025-04-19T09:56:56.906+08:00"}
---


#### 第一类问题-栈和队列输出的第i个元素

> [!NOTE]
> 3. 一个栈的输入序列为123…n，若输出序列的第一个元素是n，输出第i（1<=i<=n）个元素是（    ）。
> A. 不确定          B. n-i+1          C.  i           D. n-i
> 【中山大学 1999 一、9(1分)】
> 4. 若一个栈的输入序列为1,2,3,…,n，输出序列的第一个元素是i，则第j个输出元素是（     ）。
>  A. i-j-1          B. i-j            C. j-i+1      D. 不确定的
> 【武汉大学 2000 二、3】
> 5. 若已知一个栈的入栈序列是1,2,3,…,n，其输出序列为p1,p2,p3，…，pN,若pN是n，则pi是(    )。
>     A. i            B. n-i        C. n-i+1       D. 不确定
> 【南京理工大学 2001 一、1（1.5分）】

这几个题是有一点小区别的，第3题里面输出的第一个元素是n，那么说明前n-1个数都没有被出栈过，换句话说，出栈的整个序列是倒序的  所以输出的第i个元素是可以知道的
如果输出的最后第一个元素 不是最后一个元素  那么第i个就是不确定了，因为随时都可以入栈出栈

#### 第二类问题---栈和队列的合法序列
一般会考察栈的出栈顺序合法的是，普通队列出队合法的是，受限的双端队列输出合法这三种，其中最难的是首受限的双端队列
1. 栈的出栈顺序合法的是
	这里面有个小技巧，因为栈特殊的特性，所以第一个输出的元素之前的所有元素都不会被输出，所以只需要在原序列中找到第一个出栈的数，看它之前的元素在出栈序列中是不是倒序输出的  一般问题都设在这里  主要是有些数出栈之前有些数是不可能出来的
2. 受限的双端队列：
	这种题分为输入受限和输出受限的双端队列两种  比较灵活  一定要自己画出来看看

#### 第三类问题---栈和队列相关操作以及判断条件
对于栈来说，经常考的是对于栈指针的操作，这里需要注意栈指针的初始值是有两种的
值得注意的是，可能会考两栈共享空间的题：
	栈满判断的条件是：`top[1]+1=top[2]`

对于队列来说，主要考察链式队列和循环队列
对于链式队列：<font color="#00b0f0">在进行删除操作的时候队头和队尾指针都可能要修改，一般来说删除都是操作头指针的或者是尾指针的，看自己设计的队头是链表头还是链表尾---一般可能链表头多一点。但是如果是最后一个元素，那么头指针和尾指针不管哪种情况是需要都修改的。</font>
循环队列：
<font color="#ffc000">注意啊   循环队列的尾指针指向了要存数的位置 换句话说就是存在了队尾元素的下一个位置</font>
1. 假设数组`容量为m，arr[m-1]`头指针为front，尾指针尾rear，队列中的元素是(rear-front+m)%m ---- <font color="#00b0f0">一定要注意m是啥！</font>
2. 循环队列队空的条件：rear=front
3. 循环队列堆满的条件: (rear+1)%maxSize=front
少用一个空间的情况默认是
![Pasted image 20250101205304.png|400](/img/user/accessory/Pasted%20image%2020250101205304.png)
根本就没放满啊 不然队空和队满的条件就撞了                                                                                               
#### 第四类问题---括号匹配
原理比较简单，就不赘述了
```cpp
for(char c: string){
	if (c == '(' || c == '{' || c == '[') {
        s.push(c);
	}else if(c==')'||c=='}'||c==']'){
		if(!judge(c,s.top()))
			return false;
		s.pop();
	}
}
return s.empty();
```
#### 第五类问题---表达式求值
这前面应该还有个括号
如果直接对中缀表达式求值 那么就需要两个栈
- 一个栈用来存放数字----称为对象栈
- 一个栈用来存放符号----称为算符栈
也可以对中缀表达式转后缀表达，对后缀表达式求值
其实大差不差  ---- 我感觉对中缀表达式求值的过程其实分开就是中缀转后缀和后缀求值的样子
下面就分别来看

中缀求值：
输入中缀表达式，从头开始遍历，若当前字符为开括号，直接入字符栈；

若当前字符为闭括号，不断弹出字符栈顶运算符，直到栈顶为开括号，将其弹出；

若当前字符为数字，将其转化成整型后压栈，注意超过一位的数要用一个bool变量判断当前位x情况，用x的前一位*10+x来更新x的前一位，不管是几位数，压进去的还是一个数字。

若当前字符opt为运算符（目前仅限四则运算，如果还有乘方，它的优先级就是最高，弄个函数把每个运算符优先级划分好），比较opt和字符栈顶符号top，只要字符栈非空且栈顶元素不是开括号且优先级：top>=opt，就弹栈，然后同步弹出数字栈两个元素，做运算，结果再压回数字栈。结束以后把opt入字符栈。

当前表达式遍历完后如果字符栈还有元素，要全部弹完，一样是和数字栈的元素做运算，后者剩下的最后一个元素就是表达式的值。

<font color="#00b0f0">要掌握整个过程 还有 代码  过程更重要一点</font>

中缀表达式转后缀表达式
从左到右开始扫描中缀表达式
遇到数字， 直接输出
遇到运算符
a.若为“(” 直接入栈
b.若为“)” 将符号栈中的元素依次出栈并输出, 直到 “(“, “(“只出栈, 不输出
c.若为其他符号, 将符号栈中的元素依次出栈并输出, 直到遇到比当前符号优先级更低的符号或者”(“。 将当前符号入栈。
扫描完后, 将栈中剩余符号依次输出

后缀表达式求值：
- 如果遇到数字直接将其加入到数字栈。
- 如果遇到操作符直接从操作数栈弹出两个数据进行对应的运算，再将运算结果加入到栈中。
<font color="#00b0f0">注意是第二次出栈数 操作符  第一次出栈数</font>
#### 第六类问题---递归转非递归？？？显式栈
这个就不写了叭  不考叭