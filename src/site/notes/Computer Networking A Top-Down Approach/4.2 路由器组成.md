---
{"created":"2026-01-03T23:01","updated":"2026-01-05T15:04","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/4.2 路由器组成/","dgPassFrontmatter":true,"noteIcon":""}
---

### 路由器Overview
路由器存在输入端口(router input ports)，输出端口(router output ports)。把输入端口和输出端口连在一起的是所谓的交换机构fabric, fabric能从输入转到合适的输出，叫做转发
![Pasted image 20260105150731.png|400](/img/user/accessory/Pasted%20image%2020260105150731.png)
fabric根据什么转发？ -- 路由处理器(routing processor)运行了路由协议的实体，运行路由选择算法生成路由表送达各个输入端口
具体来说每个端口都有三部分组成，绿色的物理层，蓝色的数据链路层，以及红色的网络层
注意到routing processor是将路由表给了红色的网络层实体
另外注意讲的时候把输入端口和输出端口分开来讲的，事实上路由器的一个端口即是输入端口也是输出端口
虚线之上实现了控制平面的路由功能，虚线之下实现了数据平面的转发功能
将路由器的控制平面的路由功能和数据平面的转发功能粘连在一起的是路由表

### 输入端口功能
![Pasted image 20260105152704.png|500](/img/user/accessory/Pasted%20image%2020260105152704.png)

输入端口分为三部分，绿色的是物理层的部分，蓝色的是数据链路层的部分，红色的网络层的部分
物理层的line termination(链路终端) -- 链路上的物理信号转换成数字信号
数据链路层：判断哪里是帧头，哪里是帧尾，用CRC(循环冗余校验)或者其他校验方式校验；判断帧的目标MAC地址和我这个网卡的MAC地址是否相同（是否要收这个帧）；将帧的数据部分(IP分组)拿出来，交给网络层实体
网络层实体：排队；排到队头，按照路由处理器交下来的路由表找到合适的输出端口扔出去
为什么输入端口有一个队列？ 因为加粗的这两个地方的速度可能不一样
![Pasted image 20260105154125.png|400](/img/user/accessory/Pasted%20image%2020260105154125.png)
但按理说fabric取的速度应该大于输入网络层的速度，比如有10个网卡，那fabric的速度应该等于输入网络层速度的10倍，那为什么输入网络层的速度可能比fabric取的速度大？
有一种情况叫head-of-Line(HOL) blocking(头端阻塞)
![Pasted image 20260105154507.png|400](/img/user/accessory/Pasted%20image%2020260105154507.png)
主要就是由于上面的红色正在传，导致最下面的红色不能传，把下面的绿色堵在了后面


### 交换结构
fabric怎么从输入端口转到输出端口的，有三种典型的交换机构
![Pasted image 20260105154918.png|400](/img/user/accessory/Pasted%20image%2020260105154918.png)
**基于memory的方式**
第一代路由器实际上就是一台传统的计算机，有CPU，有RAM，有系统总线BUS，有输入输出结构(网卡)
![Pasted image 20260105155522.png|400](/img/user/accessory/Pasted%20image%2020260105155522.png)
在CPU的直接控制下，分组经过系统总线(system bus)拷贝进系统内存中，CPU从分组的头部取出目标地址，找转发表，找到对应的输出端口，拷贝到输出端口
过两次系统总线，系统总线会是速度的瓶颈
一次只能转发一个分组
实际上是通过软件的方式来实现了路由器的功能

**基于bus的方式**
这里不是系统总线了，输入接口和输出接口挂在fabric上，fabric的一种体现形式就是一种总线(bus)
只经过一次bus
存在总线竞争，总线带宽是瓶颈
1次只处理一个分组

**基于互联网络(crossbar等)的方式**
![Pasted image 20260105160624.png|150](/img/user/accessory/Pasted%20image%2020260105160624.png)
只要不抢同一个目标端口，就能同时进行
分组是变长的，经过crossbar的时间是不固定的，这给调度带来了一些困难
解决方案就是将分组切成固定长度
通过crossbar后要还原

### 输出端口
![Pasted image 20260105161122.png|400](/img/user/accessory/Pasted%20image%2020260105161122.png)
同样有物理层，数据链路层和网络层
物理层：将链路层过来的帧的比特数字信号变成物理信号
数据链路层：成帧, 包括帧头帧尾，原MAC地址目标MAC地址；还要算CRC形成差错控制编码等
网络层：排队；
排队：道理一样
![Pasted image 20260105161546.png|400](/img/user/accessory/Pasted%20image%2020260105161546.png)
注意先来的分组不一定先传，取决于调度规则

### 调度策略
**FIFO(先到先服务)**
先到先服务在操作系统中共学过，都很熟悉了
但是和FIFO配套的有一个丢弃的策略，就是说先来先服务没问题，但是如果一个分组到达一个满的队列，抛弃哪个分组的问题
- tail drop: 丢弃最后一个到的
- priority: 根据优先权丢弃
- random:  随机

![Pasted image 20260105162559.png|300](/img/user/accessory/Pasted%20image%2020260105162559.png)
**优先权调度**
发送最高优先权的分组
分组可以打标记，怎么标记是高级计算机网络的内容
另外可以根据分组的头部信息来进行分类高优先级和低优先级
![Pasted image 20260105162734.png|350](/img/user/accessory/Pasted%20image%2020260105162734.png)
只要有红的就不传绿的
![Pasted image 20260105163003.png|300](/img/user/accessory/Pasted%20image%2020260105163003.png)
**Round Robin(RR)**
循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类
![Pasted image 20260105163016.png|300](/img/user/accessory/Pasted%20image%2020260105163016.png)
**WFQ(Weighted Fair Queuing 加权工兵队列)**
![Pasted image 20260105163040.png|300](/img/user/accessory/Pasted%20image%2020260105163040.png)
红20% 绿50% 蓝30%
假设带宽为1Mbps，那红色只能拿到200Kbps的 绿的500Kbps 蓝色300Kbps
