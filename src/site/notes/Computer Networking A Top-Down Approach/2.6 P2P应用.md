---
{"created":"2025-11-26T20:51","updated":"2025-11-29T20:26","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/2.6 P2P应用/","dgPassFrontmatter":true,"noteIcon":""}
---

### P2P架构Overview
前面学过的都是CS架构，CS架构的缺点：一是服务器压力大，没法承受很多用户；二是如果服务器瘫痪了，整个服务就瘫痪了
所以会有这种P2P的应用，P2P是一类应用
没有或有极少一直运行的服务器，任何端系统都可以直接通信，任何一个节点既是客户端又是服务器
所以P2P架构随着节点的增加，请求资源节点增加，但同时提供节点的节点也在增加，系统很容易扩展
除此之外，P2P架构的可靠性比较高，没有集中式的服务器，流量是分布式的
![Pasted image 20251127092607.png|300](/img/user/accessory/Pasted%20image%2020251127092607.png)
### 性能分析文件分发 C/S vs. P2P
![Pasted image 20251127093444.png|500](/img/user/accessory/Pasted%20image%2020251127093444.png)
上载带宽$u_i$,下载带宽$d_i$ , 上载和下载是针对用户的角度而言的
服务器有上载$u_s$
**C/S模式**
所有 客户端下载大小为F的文件的时间下限，即最大值
其实是要看两部分时间
- 一部分是各个客户端下载的时间$\frac{F}{d_i}$,当然$d_i$的大小不一样，下载的时间也不一样,最慢的那一个将会决定整个时间的下限
- 另一部分是server上传N个文件的时间 $\frac{NF}{u_s}$

最终应该是取最大值
$$\max\{ \frac{F}{d_{min}}, \frac{NF}{u_s} \}
$$
随着N越来越大，前面的$\frac{F}{d_{min}}$可以忽略不计，物理意义是虽然客户端很强，服务器是瓶颈，传不上去，服务器变成了撒胡椒面hh
当N很大的时候，随着N线性增加

**P2P模式**
P2P的文件分发分成了三部分
- 第一部分，服务器至少要把文件发出去一份: $\frac{F}{u_s}$
- 第二部分，最慢的客户端必须要能下载完一份：$\frac{F}{d_{min}}$
- 第三部分，全系统总下载量被总上传量提供: $\frac{NF}{u_s+\sum_iu_i}$，即NF大小的数据需要这么多秒上传

取最大值
$$
\max{\{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_s+\sum_iu_i}\}}
$$
当N非常大的时候，前两项忽略不计，随着N增加，下载量在增加，服务上传也增加
其实由于C/S模式只能有服务器上传，所以第一部分和第三部分就是一样的

v.s. 图

![Pasted image 20251127095226.png|400](/img/user/accessory/Pasted%20image%2020251127095226.png)

### P2P管理模式
分为两种，非结构化P2P和DHT(结构化)P2P
什么叫做非结构化的P2P？
节点和节点之间有一个会话，相互提供上载和下载，构成了一种邻居的关系，从应用层的角度来看，这种关系构成了一条边。当然，这条边是逻辑上的网，叫覆盖网(overlay)，但实际上物理上两者之间的应用进程需要经过很多路由器...
非结构化的P2P是指节点与节点之间所构成的覆盖网是随机的
而结构化的P2P是指节点与节点之间所构成的覆盖网（就是那个边）是有一定结构的，可能是图，可能是树

### 非结构化P2P的文件分发与共享
非结构化P2P包括这样几类: 
- 有集中化目录的：每个节点上线之后都会将目录提供给服务器，告诉服务器我有什么，服务器做一个集中化的统筹工作
- 完全分布式

需要解决的问题就是橙子上线之后既是客户端又是服务器，这里以音乐软件为例，橙子能够检索到有薛之谦《顽疾》的所有对等方，橙子选择其中一个对等方，比如情栀凉橙，音乐就会从情栀凉橙这里传到橙子这里，同时，橙子也会宣称自己拥有了《顽疾》... 除此之外，其他的用户也可以从橙子这里下载一些歌
这里的主要问题是
- 如何定位所需资源
- 如何处理对等方的加入与离开

可能解决的方案
- 集中式
- 全分布式
- 混合体

#### P2P集中式目录
eg: Napster
![Pasted image 20251127104024.png|300](/img/user/accessory/Pasted%20image%2020251127104024.png)
具体来说就是每个节点上线的时候，需要像集中式的目录服务器做一个注册或者登记。所谓的注册，就是告诉目录服务器“我是客户端，我上线了，我的IP是什么，有哪些资源”。集中式目录服务器就维护了所有目前正在活跃的客户端的IP以及资源列表
在这种情况下，目录服务是集中式的，文件分发是P2P模式的
集中式目录中存在的问题: 单点故障；性能瓶颈

#### P2P 完全分布式
一个经典的例子: Gnutella
全分布式，没有中心服务器；开源的代码与协议
假设节点已经构建起来了overlay网络, 查的时候这个节点会向所有的邻居发出查询，它的邻居收到查询后再向所有的邻居发出查询，这种路由方式，叫泛洪(flooding) 一传十 十传百
![Pasted image 20251127110423.png|400](/img/user/accessory/Pasted%20image%2020251127110423.png)

拥有资源的节点方向给出应答
然后像拥有这个资源的节点发出查询
泛洪式的查询 -- 可能会一直在网络中回荡 -- 有一些解决方法 比如 TTL：每过一跳就减1，减为0就不再查了；另外就是让中转的节点记住谁已经给我转过了，下次绕一圈回来我就不再泛洪了...

**泛洪所依赖的overlay网络怎么建立起来的？**
对等方X一般会在比如下载软件的时候，会下下来一个配置文件，配置文件中有一个列表，是一些已经在overlay网络中的对等方。然后X试着与该列表上的对等方建立TCP连接，发送Ping报文；列表上的所有对等方再向它的所有的邻居发送Ping；所有收到Ping报文的节点都需要像源节点发出Pang报文；-- X会收到很多返回Pang的节点，随便挑一些节点做邻居，建立起连接。
**对等方离开？**
对等方会告诉X我离开了，X从其他节点中再补一个做邻居

#### P2P混合体
例子：KaZaA
![Pasted image 20251129111957.png|300](/img/user/accessory/Pasted%20image%2020251129111957.png)
每个对等方要么是一个组长，要么隶属于一个组长
组长与组长之间就像P2P完全分布式Gnutella的例子
组长和组员的关系就像集中P2P式目录Napster一样
主要的思路就是如果组员想要查询一个东西，会先像组长发出查询，如果这个东西在组内有，那么组长就会告诉他组内有，在组内去查询就好了；如果组内没有，组长再像其他组长发出查询
具体的实现来说，每个文件有一个描述和Hash标识符，在上载的时候，提供方需要提供文件本身和描述符，在上载的过程中，对文件Hash，作为唯一的标识
用户在检索的时候，实际上是匹配的描述，匹配到之后，找到文件的Hash值，以Hash值作为唯一标识像系统请求这个文件
举例来说，就是 橙子上传了一首薛之谦的《天外来物》，但是《天外来物》有很多，可能压缩格式不一样，码率不一样，唱的时间不一样，唱的地点也不一样，上载的时候会提供一些描述信息，除此之外，在上载的时候，为了标识这个文件，会给这个音乐文件计算出一个唯一的Hash值； 用户在用关键字检索的时候，比如想搜薛之谦《天外来物》，会用关键字和描述进行匹配，可能会返回一些结果；用户需要哪一个，点击的时候，实际上是发出对应这个文件的哈希值，像系统请求这个文件


### P2P BitTorrent
BitTorrent是一种P2P的内容分发协议
假设节点之间已经建立起Torrent(洪流)，所谓的洪流，就是节点的组，比如现在有一个新的节点加入Torrent洪流，需要互通文件块的有无，洪流实际上就是互通有无的一个小组
假设请求的大文件是计算机网络的知识，这个知识首先会被分为一个个知识点块，每个知识点256KB
每个节点都维护了一个bit map，来标记本节点对各个块的有无
![Pasted image 20251129192635.png|400](/img/user/accessory/Pasted%20image%2020251129192635.png)
定期的，所有的peer节点在洪流中去泛洪，去互通有无，实际上就是通过bitmap告诉其他节点我有什么，我没有什么
假设Alice是新加入的节点，它的bit map就全为0，表示自己什么也没有
Alice一开始它会随机的向节点请求一些块儿，然后当它自己有4个块的时候，也就是说当bit map中有4个bit置为1的时候，就会去请求洪流中的稀缺资源
请求稀缺资源有啥好处？ 一个好处是说，这样可以防止仅有稀缺资源的那几个节点下线了这一块内容直接空缺了 -- 这是集体利益；这里边的策略是你对别人好，别人也对你好，所以另一个好处是由于它有稀缺资源，它向别人提供的字节的数量越多，它得到别人服务的带宽就越大 -- 集体利益与个人利益结合在一起
从被请求的角度来看，假设有80个节点想请求这个块，如果同时向这80个块提供服务，实际上每个服务器只能得到节点上载带宽的八十分之一，变成了撒胡椒面hh。所以这里有一个“优化疏通”的策略，先给4个节点同时提供服务，后面76个排队；后面排队的76个并不是先来先服务，这76个中谁上一个周期给我提供服务的带宽高服务好，谁的优先级高，通过这样选4个；但第三个周期（或者一段时间后）可能会随机选一个，这是因为没准这个节点我为他提供了好的服务，下个周期它会向我提供好的服务；三个周期为一个循环

Alice是怎么知道加入到这个洪流中的？
这是因为在检索的网站上，检索后，点击列表下载torrent文件，在这个文件中有一个tracker server，然后像tracker server请求，tracker server知道哪一堆节点在管着哪个文件的长传下载，就会给你分配一些peer，然后就会Alice就会进入这个洪流互通有无

### 结构化P2P
每个节点都有一个id，这个id是ip地址的哈希值，按照这个唯一标识的大小顺序连着一定的结构，比如环状
![Pasted image 20251129202938.png](/img/user/accessory/Pasted%20image%2020251129202938.png)
如果199离开，那么88回合1011连接起来
文件内容也做一个hash，比如值为6-88的文件就会维护在88号peer

