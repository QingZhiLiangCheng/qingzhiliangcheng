---
{"created":"2025-10-18T15:16","updated":"2026-01-30T10:58","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/2.2 Web和HTTP/","dgPassFrontmatter":true,"noteIcon":""}
---

> [!quote]
> 原书2.2 The Web and HTTP
> // 看原书补 2026.1.29

### Web应用
Web是一个应用
Web页是由一些对应组成的，这些对象可以是HTML文件，可以使JPG图片，可以使音频文件等等，但是这些对象不是以对象自己的形式存在的，而是通过URL对每个对象进行引用，URL包括访问协议，用户名，口令字，端口，目标文件等
也就是说我们的应用实际上是一个base对象包括了好多其他对象的链接，比如要画一个img，HTML本身并不包括图片这个对象，而是一个链接，在画出整个html文件的时候，图片本身一开始只能用一个空框来代表，浏览器会来解释这个网页，知道图片是个链接，然后通过图片这个对象的url访问服务器

> [!quote]
> 原书明确指出了A Web Page consists of **objects**. An object is simple a file -- such as an HTML file, a JPEG image, a Javascrpt file -- that is addressable by **a single URL**.
> Most Web page consist of a **base HTML file** and s**erveal referenced objects**.
> -> 如果一个Web page包含一个HTML文件和5个JPEG图片，那就是6个对象
> HTML通过URL引用其他5个文件
> Each URL has two components: the **hostname** of the server that houses the object and the object's **path name**.
> **Web browsers** implement the client side of HTTP.
> **Web servers**, which implement the server side of HTTP, house Web objects, each addressable by a URL

### HTTP Overview
HTTP是支持Web应用的协议，叫超文本传输协议
![Pasted image 20251018160540.png|250](/img/user/accessory/Pasted%20image%2020251018160540.png)
客户端和浏览器之间首先要建立起TCP的连接，在这个链接之上发送HTTP请求；服务器在接收到HTTP请求之后，把客户端请求的对象，封装成HTTP响应的报文，回转回客户端
HTTP是跑在TCP上，服务器在某个固定ip的80号端口上运行，服务器会创建一个监听socket绑定到IP和端口，等待来自客户端的tcp连接建立请求，一旦同一建立连接(怎么建立的，怎么同意建立的和TCP有关)，web服务器就会建立一个新的socket指向和客户端(浏览器)的会话关系
![Pasted image 20251018162047.png|400](/img/user/accessory/Pasted%20image%2020251018162047.png)
一旦连接请求之后，web浏览器就可以通过socket发送http的请求，服务器就可以把http请求的对象封装成相应报文回应。web浏览器能达到这个对象后，比如是个HTML对象，就会把这个HTML画出来，解释的时候发现还有URL就会继续向服务器(也可能是其他服务器)请求拿对象
画完了就可以关闭连接了
HTTP是无状态的协议，所谓的无状态，是指服务器在处理一个HTTP请求时，不会自动记住这个客户端之前的请求状态，每次请求都是独立的，服务器不会因为刚刚访问过`/login`,就知道现在访问别的页面的就是同一个人
无状态有它自己的好处，比如不用维护历史信息，能支持更多的客户端...

> [!quote]
> 原文强调了HTTP defines how Web clients request Web pages from Web servers and how servers transfer Web pages to clients.
> 强调了HTTP uses TCP as its underlying transport protocol
> 并且介绍了整个过程 -- 建立TCP连接，之后只需要传送给socket interface -- 并且介绍了分层的好处就是HTTP不需要在意TCP怎么保证reliable的
> HTTP不保存任何状态信息 -- stateless protocol
> 上面介绍的都是最原始的HTTP -- HTTP/1.0


### 非持久HTTP vs. 持久HTTP
HTTP1.0是非持久性的HTTP，HTTP1.1是持久性的HTTP
第一步是建立连接，在建立连接的时候，事实上应用程序要借助SocketAPI告诉下面的TCP要连接了，事实上客户端TCP实体会给服务端TCP实体发送一个连接请求的段，服务器的TCP实体收到段之后要网上传，服务器要同意，然后再传回来同意的信息。换句话说，建立连接并不仅仅是涉及到上层，还涉及到与下层协议动作的一些关联关系
![Pasted image 20251018191426.png|300](/img/user/accessory/Pasted%20image%2020251018191426.png)
所以事实上整个过程是这样的
![Pasted image 20251018191524.png|250](/img/user/accessory/Pasted%20image%2020251018191524.png)
这里要注意的第一个点是，http请求发过去，回来的时候是将http请求的文件封装起来发回来了，所以需要一定的传输时间，之前我们也算过这之间的延迟
第二个点是，当然TCP传过去，传回来，这些建立连接的过程和HTTP发过去都是发送的一些报文，但是由于它的字节比较短，所以就忽略不计了，而文件比较大，不能忽略不计
第三个点是，在Http1.0中，在发送会文件之后，连接会直接关掉，所以最后实际上是一个链接拆除和链接拆除的确认。
![Pasted image 20251018191831.png|250](/img/user/accessory/Pasted%20image%2020251018191831.png)
HTTP1.0和HTTP1.1或者说是非持久HTTP和持久性HTTP的一个区别是，HTTP1.1连接不会立即关闭，在这个连接上如果还有其他对象的请求，可以在这个连接上再发请求
所以非持久的缺点就是每个对象都需要2个RTT(round-trip time, 往返时间)，操作系统每次都要为每个TCP连接分配资源
而持久HTTP的好处就是服务器就是仍保持连接
持久HTTP又分两种
- 非流水线: 在前一个对象回来之后，再发送一个新的请求
- 流水线: 第一个请求发出去，第一个对象还没回来的时候就能发第二个请求

> [!quote]
> 原书详细阐述了Non-Persistent Connection(非持久连接)和Persistent Connection(持久连接)
> Should each request/response pair be sent over a **separate** TCP conneciton, or should all of the requests and their corresponding responses be send over the **same** TCP connection? -- In the former approach, the application is said to use **non-persistent connections**; and in the latter approach, **persistent connections**.
> 原书通过请求a base HTML file and 10 JPEG images的例子阐述了非持久连接和持久连接
> 非持久连接的核心其实就在于每次传输之后就会关闭连接 -- each TCP connection is **closed** after the server sends the object -- the connection does **not persist** for other objects.
> 并且原文说**HTTP/1.0 employes(采用) non-persistent TCP connections**.
> 所以实际上是对于上面请求网页的例子，一共是用了11个TCP connections
> 
> 原书又引入了RTT的概念：
> **round-trip time(RTT), which is the time it takes for a small packet to travel from client to server and then back to the client. The RTT includes packet-propagation delays, packet-queuing delays in intermediate routers and switches, and packet-processing delays.**
> 并且原书介绍了three-way handshake的过程
> ![Pasted image 20260130092942.png|400](/img/user/accessory/Pasted%20image%2020260130092942.png)
> 
> 值得强调的是，第一个来回属于一个RTT
> **The HTTP request message combined with the third part of the three-way handshake(the acknowledgment) into the TCP connecton**. -- 在第三次实际上就通过**捎带技术**包含了请求的内容了
> 所以说请求跟获得内容又是一个RTT
> 值得注意的是，一般没法忽略传输大文件的时间
> 所以，the total response time is two RTTs + the transmission time at the server of the HTML file.
> 
> 书中总结了non-persistent connection的缺点
> - First, a brand-new connection must be established and maintained for each request object.
> - Second, each object suffers a delivery delay of two RTTs
> 
> **HTTP/1.1 - persistent connections** , 核心其实就是Subsequent requests and responses between the same client and server can be sent over the same connection.
> 并且，**multiple web page** 也能 sent from the server to the same client over a single persistnet TCP connection.
> 连接将会在一段时间没有传输后关掉 -- the HTTP server closes a connection **when it isn't used for a certain time**.
> These requests for objects can be made back-to-back, without waiting for replies to pending requests -- 叫 **pipelining**
> **The default mode HTTP uses persistent connections with pipelining.**
> 


### HTTP请求报文
HTTP请求报文是ASCII可读的，都是由ASCII码编码的
![Pasted image 20251018193215.png|400](/img/user/accessory/Pasted%20image%2020251018193215.png)
请求的命令主要有GET, POST, HEAD。其中GET和POST写过JavaWeb项目实际上很熟悉，HEAD是只要head，因为head中有一些基本的描述信息，可以建索引
后面的首部行中，格式是 首部名：首部值
- Host: 主机名
- User-agent: 用户代理的程序，是一个浏览器的第几个版本
- Connection: close -- 虽然HTTP1.1是默认不关连接的，这里选择关连接

如果是Get的话，后面就没有实体部分，Post就会有后面的实体部分

HTTP请求报文：通用格式
![Pasted image 20251018193745.png|400](/img/user/accessory/Pasted%20image%2020251018193745.png)
提交表单输入：
Post会在命令行之后，若干首部行之后，回车之后，放提交表单的内容
GET也能提交表单输入，输入通过请求行的URL字段上载
这些写SpringBoot的时候都遇到过

HTTP1.0的方法类型只有GET, POST, HEAD
而HTTP1.1的方法类型除了GET, POST, HEAD还有PUT和DELETE
> [!quote] HTTP Message Format
> 
> ![Pasted image 20260130103706.png|450](/img/user/accessory/Pasted%20image%2020260130103706.png)
> the message is written in ordinary **ASCII** text
> each followed by a carriage return and a line feed. -- 每行后均以**回车**换行
> The last line is followed by an additional carriage return and line feed.
> first line of an HTTP request message is called the **request line**.
> the subsequent lines are called the **header lines**.
> request line has three fields: **method filed**, **the URL filed**, and the **HTTP version filed**.
> method filed: **GET, POST, HEAD, PUT, DELETE**.
> - The GET method is used when the brower requests an object.
> - POST: 使用entity body部分了 -- An HTTP client often use the POST method when the user fills out a form(请求表单)
> 	- 但是值得注意的一个点是，也可以使用GET method and include the inputted data来请求
> - HEAD: is reponds with an HTTP message but it leaves out the requested object.
> - PUT: It allows a user to upload an object to a specific path(directory) on a specific Web server.
> - DELETE: to delete object on Web server.
> 
> Header lines中注意这么几个字段
> - Host: 这里需要注意，为什么主机已经建立TCP连接了，还需要Host字段 -- 这是因为the host header line is required by Web proxy caches.(主机头行是Web代理缓存的必备字段。)
> - Connection: close -- 意味着不维持连接
> - User-agent: 用户代理，其实就是用的什么浏览器 -- 为什么要指明这个？ 因为the server can actually send different version of the same object to different types of user agents.
> 



### HTTP响应报文
![Pasted image 20251020153102.png|400](/img/user/accessory/Pasted%20image%2020251020153102.png)
由状态行，首部行和请求的数据所构成
Server是服务器的信息；
Last-Modified是一个信息，基本相当于一个版本号，服务器会告诉客户端你请求的这个对象上一次被修改的时间；
Content-Length指的回车后面有多少个字节是http报文的内容。-- 实际上TCP并不维护报文的边界，比如说可能服务器往下发的是两个15k字节的，而客户端的TCP网上交的时候可能是一个30K字节的。应用进程要自己区分哪里是应用报文的头，哪里是应用报文的结束，换句话说，向采用TCP，就要自己维护报文和报文的界限。在这个例子中，HTTP是完善了下层的服务，通过报文头来告诉应用进程报文的界限

HTTP响应状态码
- 200 OK: 请求成功，请求对象包含在响应报文的后续部分
- 301 Moved Permanently: 请求的对象已经被永久转移了：新的URL在响应报文的Location: 首部行中指定；客户端软件自动用新的URL去获取对象
- 400 Bad Request: 请求不能被服务器解读
- 404 Not Found: 请求的文档在服务上没有找到
- 505 HTTP Version Not Supported
> [!quote] HTTP response message
> 
> ![Pasted image 20260130105509.png|400](/img/user/accessory/Pasted%20image%2020260130105509.png)
> 三部分：status line, header lines, entity body.
> status lines: the protocol version field, status code, a corresponding status message.
> status和phrases在课上讲的很明白了 和书上一模一样
> 值得注意的是书中强调了几个header lines的字段
> Date: 服务器创建并发送HTTP响应的时间与日期 -- 并非对象创建或最后修改的时间，而是服务器从文件系统中获取对象、将对象插入响应消息并发送响应消息的时间!
> Last-Modified: 该行标题显示对象创建或最后修改的时间和日期
> Content-Type: 实体主体中的对象类型 -- 不是扩展名！


### 用户-服务器状态：cookies
HTTP协议实际上是一个无状态的协议，所谓无状态就是服务器不维护客户端的状态，不管以前有没有请求过
一个经典的例子就是需要维护你的登录状态
怎么改造这种无状态的协议变为维护状态的？ 一个机制 -- cookie
![Pasted image 20251020164203.png|400](/img/user/accessory/Pasted%20image%2020251020164203.png)
客户端第一次发出请求的时候，通常没有cookie，服务器能够识别这是一个新家伙，然后返回响应的时候在头部塞了一个cookie，并且服务器在数据库中保留这个cookie
客户端从响应的头部中拿到cookie就可以存在本地的文件系统的相应的目录中
下次客户端再访问服务器的时候，就可以带上cookie，服务器能够将cookie与自己服务器中的cookie关联起来，这样服务器就知道了比如你有没有登陆过，你的购物车有什么，你买过什么...
三个月以后，如果客户端再访问网站，仍然可以带上cookie，服务器可以在数据库中找到相应的cookie值关联起来（这家伙以前来过hh）
这样就把HTTP从一个无状态的协议变成了一个有状态的协议

cookie在哪里包括？由哪几部分？
- Response的报文中有一个cookie的首部行
- Requet的报文中有一个cookie的首部行
- 服务器数据库所维护的cookie的情况
- 客户端所维护的cookie的文件

![Pasted image 20251020165028.png|400](/img/user/accessory/Pasted%20image%2020251020165028.png)


### Web缓存(代理服务器)
![Pasted image 20251020170218.png|400](/img/user/accessory/Pasted%20image%2020251020170218.png)
服务器将所有的HTTP请求都发给缓存或者叫代理服务器，如果缓存中存在对象，缓存直接返回对象；如果对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端
好处：
- 用户角度: 减少客户端的请求响应时间
- 服务器角度: 服务器端的载荷，负载变轻了

利用了用户趋同性

![Pasted image 20251020193355.png|500](/img/user/accessory/Pasted%20image%2020251020193355.png)

![Pasted image 20251020193923.png|500](/img/user/accessory/Pasted%20image%2020251020193923.png)

![Pasted image 20251020194058.png|500](/img/user/accessory/Pasted%20image%2020251020194058.png)


> [!quote]
> 书中举的例子应该是课中的例子是一样的，说明了有了缓存对响应时间的降低，同时也代出了后面要将的内容分发网络(Content Distribution Network, CND)的重要性


### 条件Get语句(补)
> [!quote] 条件GET
> 使用Web缓存的带来的一个重要的问题就是：the copy of an object residing in the cache may be stale. -- Web缓存和原服务器内容一致性的问题
> HTTP有一种机制，allow a cache to vertify that its objects are up to date. -- **conditional GET**
> 整个过程的核心是这样的：
> 在Web缓存第一次像文件服务器请求的时候，会有一个Last-Modified字段，如
> ![Pasted image 20260131162056.png|400](/img/user/accessory/Pasted%20image%2020260131162056.png)
> the cache also stores the last-modified date along with the object.
> 当有用户向Web缓存请求这个文件的时候 -- the cache performs an up-to-date check by issuing a conditional GET.
> ![Pasted image 20260131162411.png|400](/img/user/accessory/Pasted%20image%2020260131162411.png)
> 如果一样，服务器会发会一个没有被修改的报文
> ![Pasted image 20260131162452.png|300](/img/user/accessory/Pasted%20image%2020260131162452.png)
> 
> 

### HTTP/2 (补)
#### Overview
HTTP主要目的是通过在单个TCP连接上实现请求和相应的多路复用，提供请求优先级和服务器推送，以及提供高效的HTTP头部字段压缩来减少用户感知的延迟。并不改变HTTP的方法，状态码，URL或头部字段，而是改变数据的格式化和传输方式
HTTP1.1属于是单个TCP连接，持久性 -- 单个TCP连接顺序请求并发送对象
好处当时就是减少了socket的数量，同时满足了TCP拥塞控制的设置--即n个TCP连接每个连接都会分$\frac{1}{n}$的带宽
单个TCP的连接有一个问题 -- Head of Line blocking, HOL blocking, 队头阻塞 -- 所谓的队头阻塞，当一个HTML文件顶部有一个大的视频，下面有好多小的对象的时候，后面的对象会因为排在视频片段后面而被延迟！
HTTP1.1的一个解决方案是 -- 浏览器会打开多个并行的TCP连接来解决这个问题 -- 但是问题在于 -- 多个并行TCP连接，每个TCP连接分$\frac{1}{n}$带宽，使得浏览器通过多个TCP连接“作弊”来获得一大部分链路带宽 -- 违背了TCP的拥塞控制
所以HTTP/2的任务就是通过设计，保持单个TCP连接，同时能解决HOL阻塞的问题

#### HTTP/2 Framing(分帧)
有点像网络层的分片了hh
HTTP/2针对HOL阻塞的解决方案是：将每个message分成多个不同的小的frame，并且多路复用的交错传输
其核心就是服务器在发送了视频片段的一个帧之后，会接着发送每个小对象的第一个帧！
分帧，组装 -- 由framing sub-layer of the HTTP/2 protocol(HTTP/2协议的分帧子层)完成
具体分帧的过程：响应的头部字段成为一个帧，而消息的正文则被分解成一个或多个额外的帧
分帧子层还对帧进行二进制编码： 解析效率更高，帧更小，不容易出错

#### Response Message Prioritization and Server Pushing(响应消息优先级和服务器推送)
简单来说，所谓的响应消息优先级就是允许开发者自定义请求的相对优先级，给每个消息分配一个1-256之间的一个权重来作为相应优先级，数字越大，优先级越大
客户端还通过指定其所依赖消息的ID来声明每个消息对其他消息的依赖关系
而服务器推送是指，对原始请求的响应外，服务器还可以向客户端推送(push)额外的对象，而无需客户端对每个对象都进行请求

### HTTP/3 (补)
QUIC（在第3章讨论）是一种新的“传输”协议，它在应用层中、基于最基本的UDP协议实现。QUIC具备HTTP所期望的几个特性，例如消息多路复用（交错传输）、基于每个流的流量控制以及低延迟的连接建立。HTTP/3是又一个新的HTTP协议，它被设计为在QUIC之上运行。截至2020年，HTTP/3在互联网草案（Internet drafts）中进行描述，尚未完全标准化。许多HTTP/2的特性（例如消息交错）已被QUIC所吸收，这使得HTTP/3的设计可以更简单、更精简。
我问了一下Gemini: Gemini说HTTP2解决了HTTP应用层面的HOL Blocking，但是TCP层也存在HOL Blocking -- 假设其中一个包含了CSS文件部分数据的TCP数据包在网络中丢失了。TCP协议是一个可靠的协议，它会坚持“按顺序确认”。这意味着，即使后面包含了图片和JS文件数据的TCP数据包已经顺利到达了你的电脑，TCP层也必须等待那个丢失的CSS数据包被重新传输并成功到达后，才能将所有后续的数据包一次性交给上层（浏览器）处理 -- 仅仅因为一个数据包的丢失，所有流（图片、CSS、JS）的数据都被卡住了，尽管它们之间本是独立的
QUIC -- 釜底抽薪 -- 拥抱UDP，HTTP2是在应用层做了多路复用，QUIC在传输层做多路复用，QUIC中，不同的HTTP请求（例如请求图片、CSS）是在完全独立的“流”（Stream）中传输的
...
