---
{"created":"2025-10-18T15:16","updated":"2025-10-20T19:42","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/2.2 Web和HTTP/","dgPassFrontmatter":true,"noteIcon":""}
---

### Web应用
Web是一个应用
Web页是由一些对应组成的，这些对象可以是HTML文件，可以使JPG图片，可以使音频文件等等，但是这些对象不是以对象自己的形式存在的，而是通过URL对每个对象进行引用，URL包括访问协议，用户名，口令字，端口，目标文件等
也就是说我们的应用实际上是一个base对象包括了好多其他对象的链接，比如要画一个img，HTML本身并不包括图片这个对象，而是一个链接，在画出整个html文件的时候，图片本身一开始只能用一个空框来代表，浏览器会来解释这个网页，知道图片是个链接，然后通过图片这个对象的url访问服务器

### HTTP Overview
HTTP是支持Web应用的协议，叫超文本传输协议
![Pasted image 20251018160540.png|250](/img/user/accessory/Pasted%20image%2020251018160540.png)
客户端和浏览器之间首先要建立起TCP的连接，在这个链接之上发送HTTP请求；服务器在接收到HTTP请求之后，把客户端请求的对象，封装成HTTP响应的报文，回转回客户端
HTTP是跑在TCP上，服务器在某个固定ip的80号端口上运行，服务器会创建一个监听socket绑定到IP和端口，等待来自客户端的tcp连接建立请求，一旦同一建立连接(怎么建立的，怎么同意建立的和TCP有关)，web服务器就会建立一个新的socket指向和客户端(浏览器)的会话关系
![Pasted image 20251018162047.png|400](/img/user/accessory/Pasted%20image%2020251018162047.png)
一旦连接请求之后，web浏览器就可以通过socket发送http的请求，服务器就可以把http请求的对象封装成相应报文回应。web浏览器能达到这个对象后，比如是个HTML对象，就会把这个HTML画出来，解释的时候发现还有URL就会继续向服务器(也可能是其他服务器)请求拿对象
画完了就可以关闭连接了
HTTP是无状态的协议，所谓的无状态，是指服务器在处理一个HTTP请求时，不会自动记住这个客户端之前的请求状态，每次请求都是独立的，服务器不会因为刚刚访问过`/login`,就知道现在访问别的页面的就是同一个人
无状态有它自己的好处，比如不用维护历史信息，能支持更多的客户端...

### 非持久HTTP vs. 持久HTTP
HTTP1.0是非持久性的HTTP，HTTP1.1是持久性的HTTP
第一步是建立连接，在建立连接的时候，事实上应用程序要借助SocketAPI告诉下面的TCP要连接了，事实上客户端TCP实体会给服务端TCP实体发送一个连接请求的段，服务器的TCP实体收到段之后要网上传，服务器要同意，然后再传回来同意的信息。换句话说，建立连接并不仅仅是涉及到上层，还涉及到与下层协议动作的一些关联关系
![Pasted image 20251018191426.png|300](/img/user/accessory/Pasted%20image%2020251018191426.png)
所以事实上整个过程是这样的
![Pasted image 20251018191524.png|250](/img/user/accessory/Pasted%20image%2020251018191524.png)
这里要注意的第一个点是，http请求发过去，回来的时候是将http请求的文件封装起来发回来了，所以需要一定的传输时间，之前我们也算过这之间的延迟
第二个点是，当然TCP传过去，传回来，这些建立连接的过程和HTTP发过去都是发送的一些报文，但是由于它的字节比较短，所以就忽略不计了，而文件比较大，不能忽略不计
第三个点是，在Http1.0中，在发送会文件之后，连接会直接关掉，所以最后实际上是一个链接拆除和链接拆除的确认。
![Pasted image 20251018191831.png|250](/img/user/accessory/Pasted%20image%2020251018191831.png)
HTTP1.0和HTTP1.1或者说是非持久HTTP和持久性HTTP的一个区别是，HTTP1.1连接不会立即关闭，在这个连接上如果还有其他对象的请求，可以在这个连接上再发请求
所以非持久的缺点就是每个对象都需要2个RTT(round-trip time, 往返时间)，操作系统每次都要为每个TCP连接分配资源
而持久HTTP的好处就是服务器就是仍保持连接
持久HTTP又分两种
- 非流水线: 在前一个对象回来之后，再发送一个新的请求
- 流水线: 第一个请求发出去，第一个对象还没回来的时候就能发第二个请求

### HTTP请求报文
HTTP请求报文是ASCII可读的，都是由ASCII码编码的
![Pasted image 20251018193215.png|400](/img/user/accessory/Pasted%20image%2020251018193215.png)
请求的命令主要有GET, POST, HEAD。其中GET和POST写过JavaWeb项目实际上很熟悉，HEAD是只要head，因为head中有一些基本的描述信息，可以建索引
后面的首部行中，格式是 首部名：首部值
- Host: 主机名
- User-agent: 用户代理的程序，是一个浏览器的第几个版本
- Connection: close -- 虽然HTTP1.1是默认不关连接的，这里选择关连接

如果是Get的话，后面就没有实体部分，Post就会有后面的实体部分

HTTP请求报文：通用格式
![Pasted image 20251018193745.png|400](/img/user/accessory/Pasted%20image%2020251018193745.png)
提交表单输入：
Post会在命令行之后，若干首部行之后，回车之后，放提交表单的内容
GET也能提交表单输入，输入通过请求行的URL字段上载
这些写SpringBoot的时候都遇到过

HTTP1.0的方法类型只有GET, POST, HEAD
而HTTP1.1的方法类型除了GET, POST, HEAD还有PUT和DELETE

### HTTP响应报文
![Pasted image 20251020153102.png|400](/img/user/accessory/Pasted%20image%2020251020153102.png)
由状态行，首部行和请求的数据所构成
Server是服务器的信息；
Last-Modified是一个信息，基本相当于一个版本号，服务器会告诉客户端你请求的这个对象上一次被修改的时间；
Content-Length指的回车后面有多少个字节是http报文的内容。-- 实际上TCP并不维护报文的边界，比如说可能服务器往下发的是两个15k字节的，而客户端的TCP网上交的时候可能是一个30K字节的。应用进程要自己区分哪里是应用报文的头，哪里是应用报文的结束，换句话说，向采用TCP，就要自己维护报文和报文的界限。在这个例子中，HTTP是完善了下层的服务，通过报文头来告诉应用进程报文的界限

HTTP响应状态码
- 200 OK: 请求成功，请求对象包含在响应报文的后续部分
- 301 Moved Permanently: 请求的对象已经被永久转移了：新的URL在响应报文的Location: 首部行中指定；客户端软件自动用新的URL去获取对象
- 400 Bad Request: 请求不能被服务器解读
- 404 Not Found: 请求的文档在服务上没有找到
- 505 HTTP Version Not Supported

### 用户-服务器状态：cookies
HTTP协议实际上是一个无状态的协议，所谓无状态就是服务器不维护客户端的状态，不管以前有没有请求过
一个经典的例子就是需要维护你的登录状态
怎么改造这种无状态的协议变为维护状态的？ 一个机制 -- cookie
![Pasted image 20251020164203.png|400](/img/user/accessory/Pasted%20image%2020251020164203.png)
客户端第一次发出请求的时候，通常没有cookie，服务器能够识别这是一个新家伙，然后返回响应的时候在头部塞了一个cookie，并且服务器在数据库中保留这个cookie
客户端从响应的头部中拿到cookie就可以存在本地的文件系统的相应的目录中
下次客户端再访问服务器的时候，就可以带上cookie，服务器能够将cookie与自己服务器中的cookie关联起来，这样服务器就知道了比如你有没有登陆过，你的购物车有什么，你买过什么...
三个月以后，如果客户端再访问网站，仍然可以带上cookie，服务器可以在数据库中找到相应的cookie值关联起来（这家伙以前来过hh）
这样就把HTTP从一个无状态的协议变成了一个有状态的协议

cookie在哪里包括？由哪几部分？
- Response的报文中有一个cookie的首部行
- Requet的报文中有一个cookie的首部行
- 服务器数据库所维护的cookie的情况
- 客户端所维护的cookie的文件

![Pasted image 20251020165028.png|400](/img/user/accessory/Pasted%20image%2020251020165028.png)

### Web缓存(代理服务器)
![Pasted image 20251020170218.png|400](/img/user/accessory/Pasted%20image%2020251020170218.png)
服务器将所有的HTTP请求都发给缓存或者叫代理服务器，如果缓存中存在对象，缓存直接返回对象；如果对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端
好处：
- 用户角度: 减少客户端的请求响应时间
- 服务器角度: 服务器端的载荷，负载变轻了

利用了用户趋同性

![Pasted image 20251020193355.png|500](/img/user/accessory/Pasted%20image%2020251020193355.png)

![Pasted image 20251020193923.png|500](/img/user/accessory/Pasted%20image%2020251020193923.png)

![Pasted image 20251020194058.png|500](/img/user/accessory/Pasted%20image%2020251020194058.png)
