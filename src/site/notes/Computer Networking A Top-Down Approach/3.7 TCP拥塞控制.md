---
{"created":"2026-01-02T15:31","updated":"2026-01-03T14:11","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/3.7 TCP拥塞控制/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
TCP拥塞控制是典型的端到端的拥塞控制，网络不提供任何信息，对于TCP这种用于大型网络的协议，如果核心网中的交换设备要提供拥塞信息的话，代价比较大
对于TCP协议的网络来说，核心层会相对简单一点，复杂性放在边缘的传输层以及传输层以上
拥塞控制的几个重要的问题
- 如何检测拥塞，包括轻微拥塞和真正的拥塞
- 控制策略：在发送拥塞或轻微拥塞的时候，有哪些动作，包括如何降低速率以及在拥塞缓解的时候如何增加速率

### TCP拥塞控制: 拥塞感知
有两个事件与拥塞有关
- 某个段超时：拥塞
	- 原因1: 网络拥塞，路由器缓冲区满了，被丢弃，概率大
	- 原因2：某个比特被干扰了，出错，没有通过校验，被丢弃，概率小 -- 这最后也会造成超时，但这不是拥塞，不应该降低发送速度 
- 有关某个段的3次重复ACK: 轻微拥塞

### TCP拥塞控制: 速率控制方法
发送方维持了一个拥塞窗口的值：CongWin , 指在对方未确认的情况下，可以往网络中注入多少字节
$$
rate=\frac{CongWin}{RTT}(bytes/sec)
$$
rate是粗略的一种计算发送方往网络中注入的速率
简单来说，当发生拥塞的时候，减少ConfWin的大小，不拥塞的时候，尽可能增加ConfWin的大小
具体来说
- 发生超时的时候，将ConfWin降为一个MSS，进入慢启动(SS)阶段
- 如果收到3个冗余ACK，ConfWin降为当前的一半，进入拥塞避免(CA)阶段
- 慢启动阶段(SS): 每个RTT ConfWin加倍增加
- 拥塞避免阶段(CA): 每个RTT，线性增加，每个RTT加一个MSS

⭐值得注意的是TCP的拥塞控制和流量控制是**联合控制**的，拥塞窗口值决定了由于拥塞控制的因素，发送方在对方未经确认的情况下，一次性可以往网络中注入字节的数量；对方接受窗口字节的尺寸，告诉发送方，在对方未确认的情况下可以发送多少字节，最终是取两个值的最小值

### TCP拥塞控制: 策略
策略整体来说就是：
- 慢启动
- AIMD：线性增，乘性减；
- 超时事件后的保守策略

**慢启动**
连接刚建立时，ConWin=1MSS
如果可用带宽>>MSS/RTT,尽快加速
指数型增加每个RTT的发送速率，知道发生丢失事件
![Pasted image 20260103133210.png|200](/img/user/accessory/Pasted%20image%2020260103133210.png)
相当于没收到一个ACK增加一个MSS
**AIMD**
乘性减：丢失事件发生后，将CongWin降为1，将CongWin/2作为阈值，慢启动倍增到CongWin/2
加性增：当CongWin>阈值时，一个RTT如没有发生丢失事件，将CongWin加1MSS探测
eg: 一开始慢启动阶段1个MSS，2个，4个，8个，16个发生拥塞，ConfWin重新降为1，把8作为敏感值，重新慢启动，1个，2个，4个，8个，到8个的时候开始一个一个加，9个，10个...
哈哈哈老师举了一个很好玩的例子是喝酒测酒量，1两，2两，4两，8两，一斤流量干翻了；标记8两作为标记值；但是不知道上一次喝大了有没有伤到元气，所以第二次还是从1两开始测，1两，2两，4两，8两，9两,一斤，一斤一两，一斤二两又趴下了；然后把六两当成警戒值，从1两再开始，1两，2两，4两，6两(不能到8两), 7两 ,8两，9两，10两，开始颤颤巍巍，勾肩搭背，有喝醉的迹象了（这属于3个冗余ACK），降为5两直接进入拥塞避免阶段，5两，6两...
![Pasted image 20260103134909.png|500](/img/user/accessory/Pasted%20image%2020260103134909.png)

红色的部分属于慢启动阶段，但由于慢启动阶段很快，可以忽略，从宏观上来看，拥塞窗口就是线性增加，乘性减少

### TCP的吞吐量
假设拥塞窗口值为W，拥塞控制使其宏观上再W/2 - W的区间在线性变化，均值为$\frac{\frac{W}{2}+W}{2}$, 平均吞吐量T:
$$T=\frac{\frac{W}{2}+W}{2RTT}=\frac{3}{4}\frac{W}{RTT}$$

### TCP的公平性
![Pasted image 20260103140013.png|300](/img/user/accessory/Pasted%20image%2020260103140013.png)
两个主机分享瓶颈性的R带宽，每个主机平均上来看占$\frac{R}{2}$
均分
![Pasted image 20260103141327.png|300](/img/user/accessory/Pasted%20image%2020260103141327.png)
假设n=2，$RTT_{AA'}=RTT_{BB'}$
图中的白线是x+y=R
假设一开始x并不等于y，图中的第一个白点，忽略慢启动，宏观上实际上AA'和BB'都会一人加一个，最终会到达x+y=R这条白线，短时间内甚至会越过这条白线，然后发生丢失，拥塞窗口键位一半，变成了橙色的点，然后再你加1我加1（蓝色的线）然后会变成红色的线上的中点...
最终会收敛到均分
![Pasted image 20260103141143.png|400](/img/user/accessory/Pasted%20image%2020260103141143.png)

如果一方使用UDP，UDP想发多块就多块，对TCP是不友好的
如果B和B'已经有9个TCP连接了，A和A'再建立1个TCP连接，实际上从公平性和主机的角度来说B和B'之间建立的带宽更多
如果A和A',B和B'都只有一个TCP连接，但B和B'之间的往返延迟比较小, 就变成我加1你加多了，BB'抢到的带宽会更大
所以讲的TCP公平是大致公平