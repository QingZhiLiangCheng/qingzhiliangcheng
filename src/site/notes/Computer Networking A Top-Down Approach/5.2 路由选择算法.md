---
{"created":"2026-01-03T23:03","updated":"2026-02-22T21:04","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/5.2 路由选择算法/","dgPassFrontmatter":true,"noteIcon":""}
---

### 路由选择算法 Overview
路由选择算法有两类：
- 链路状态算法(link state)
- 距离矢量算法(distance vector)

**什么叫做路由？**
![Pasted image 20260219144942.png|400](/img/user/accessory/Pasted%20image%2020260219144942.png)
路由实际上就是找到一条从源节点到目标节点的较好的路径
从源端到目标端可能需要很多的网络，这些网络通过路由器将他们任意的互联在一起，事实上，源主机传给出口路由器，出口路由器转发给下一跳，下一跳, ... , 目标主机所在的子网，交给目标主机。第一跳实际上没有什么悬念，就是目标主机发给出口路由器，最后一条也没有什么悬念，最后一个子网的入口路由器转给目标主机，也就是说，网络层的路由实际上就是子网到子网的路由！
一个子网的子网前缀是一样的，只需要知道这个子网到其他子网怎么走（下一跳）的路径就好了，我将我的可达信息向外发布，其他人只要想发给我所在子网的设备，发给我这个路由器就好了
路由信息的计算都是以子网为单位来计算，而且在路由信息扩散的过程中，路由信息可以做进一步的聚集
一般找的是较好而不是最好，最好跟指标有关系，可能是最短路径，可能是延迟最小，可能是费用最小等等，但最好的代价可能有点大！
主机到主机的路由问题就相当于子网到子网之间的路由问题，也就相当于路由器到路由器的一个路由问题，所以找到了路由节点到路由节点之间的最优路径，就相当于知道了子网到子网的最优路径，也就找到了一个子网的所有主机到另一个子网的所有主机的最优路径，并且子网到子网的路由问题的路由规模比主机到主机的路由规模小两到三个数量级

**网络的图抽象**
![Pasted image 20260222161925.png|500](/img/user/accessory/Pasted%20image%2020260222161925.png)
路由选择是一个算法，算法就需要给出输入，输入有：网络拓扑，即节点和边的关系，节点是路由器或者说路由器所在的子网，边是把路由器连接起来的网络或者点到点的链路；边的代价；源是谁？；输出是源节点到所有其他节点的最优的路径,即源节点的汇集树，其实也就是路由表
当一个节点算出来我到其他节点的最优的路径后，就会按照自己算出来的路由表来决定到A节点的分组该给我的哪个邻居，然后这个邻居收到节点后再根据自己的路由表决定给他自己的哪个邻居....
所谓的汇集树，就是此节点到所有其他节点的最优路径形成的树，路由选择算法就是为所有的路由器找到并使用汇集树
![Pasted image 20260222162904.png|400](/img/user/accessory/Pasted%20image%2020260222162904.png)
**路由选择算法的原则**
- 正确性：正确，完整
- 简单性：为了算出最优路径花费很大的代价，网络中传输了大量的路由信息本身而不是数据报，占用太大的带宽从而影响数据报的传输 -- 没有必要为了最优，耗费大量的通信代价和计算代价
- 健壮性：能够适应通信量和网络拓扑的变化 -- 也叫鲁棒性
- 稳定性：产生的路由不应该摇摆
- 公平性：对每一个站点都公平
- 最优性(次优性)：某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的

**路由算法的两种分类**
从一种角度看，分为两类，全局的算法和分布式的算法
所谓的全局算法就是，我有一个上帝视角，我能看到整个网络的拓扑和边的代价，我是谁，我能算到我到所有其他接地那的最优路径。那我是怎么变成上帝的呢？后面会讲，这并不是路由选择算法本身的事儿，那是路由信息测量和传递的事儿 -- 如链路状态算法
分布式的算法是，路由器只知道自己的网卡所接的邻居路由器和到邻居路由器的代价值，我想到达其他子网必须通过这几个邻居，每个邻居把它所知道的到达它们各自邻居的可达信息告诉我，然后我来算一算，我到其他子网从哪个邻居走，比如其中一个邻居A告诉我到北京代价是10块钱，另一个邻居B告诉我到北京的代价是5块钱，然后我算一下加上我到A和B的代价，通过A到北京是5+10=15块钱，通过B到北京是7+5=12块钱，我选择从B到达北京！ -- 所有节点都是分布式的，通过迭代的方式，最后得到到达所有节点的路由信息 -- 如距离向量算法
从另外一种角度看，路由选择算法可以分为动态的路由选择算法和静态的路由选择算法
静态的，非自适应算法：不能适应网络拓扑和通信量的变换，路由表是事先计算好的
动态的，自适应路由选择算法：能适应网络拓扑和通信量的变换

### Link State 链路状态路由选择算法
链路状态算法实际上就是注明的Dijkstra算法
首先需要通过各种渠道获得整个网络拓扑结构，网络中所有链路代价等信息，所谓的渠道是一种泛洪的方式，并不属于路由选择算法的部分
当拿到整个网络拓扑结构和整个链路代价后，运行Dijkstra算法，算出我这个节点或者子网到其他所有节点或者说所有路由器或者说所有子网的最优路径，这就得到了路由表
后面就是使用路由表，进行转发了
总的具体来说，整个过程是这样的：
1. 发现相邻节点,获知对方网络地址 
2. 测量到相邻节点的代价(延迟,开销) 
3. 组装一个LS分组,描述它到相邻节点的代价情况 
4. 将分组通过扩散的方法发到所有其它路由器以上 -- 4步让路由器获得拓扑和边代价 
5. 通过Dijkstra算法找出最短路径（这才是路由算法） 
	1. 每个节点独立算出来到其他节点（路由器=网络）的最短路径 
	2. 迭代算法：第k步能够知道本节点到k个其他节点的最短路径

**到底是怎么获得全局信息的？**
实际上很简单，首先我会打开门，向我的邻居hello，他们会hello back回来，这样就能得到我的邻居，以及通过往返时间能够测量一些代价，比如往返的延迟...,这样我会知道我的网卡连了哪些邻居，我清楚我的邻居以及我到邻居的代价，这个信息封装成了链路状态分组 -- 总结一下就是任何一个分组它的链路状态分组就是它周边有哪些邻居以及以及到这些邻居的代价
这个链路状态分组在全网泛洪(Flooding) ，所谓的泛洪就是广播，就是我把我的链路状态分组通过网卡给我的邻居A，邻居A再把这个分组给所有它自己的邻居...
这样我的链路状态分组很快能够泛洪到全网，我也很容易能够拿到所有其他节点的链路状态分组，这样我就可以形成一个拼图，得到全网的拓扑结构以及链路代价
泛洪的话 会存在一个广播风暴的问题 网络中有环 -- 解决方案
- TTL的字段，减为0不在泛洪
- 版本号：A前面发出去的版本4，后面发出去的版本5，每个节点在转发A的链路状态分组的时候要给已经转发得A的链路状态分组做一个记录，加入我收到过并记录过seq=5的分组，又收到seq=4的分组，就不转发了

链路状态分组的泛洪是一种有确认的，可靠的泛洪
![Pasted image 20260222175713.png|200](/img/user/accessory/Pasted%20image%2020260222175713.png)
C将链路状态分组发给A，A会给C一个确认。同时A会把链路状态分组发给他的邻居B和D，并且希望收到他们的确认

**链路状态路由选择算法的应用**
- OSPF协议
- IS-IS

**Dijkstra算法**
![Pasted image 20260222192431.png|400](/img/user/accessory/Pasted%20image%2020260222192431.png)
用一个二元组来唯一的标识一个节点，Dv是从源节点到当前路径的一个代价，Pv代表的是这个路径的前序节点，实际上就是一个指针。 PPv是前序的前序节点这样子有
有两类节点：N'集合：已经知道最优值的节点，和全集-N':不知道的最优路径正在遍历最优的那部分节点
初始化：N' = {S}，只有源节点，I-N' = S节点以外的节点，实际上又分为两类，一类是源节点的邻居节点，另一类是其他节点；试图标记所有的邻居节点，并从邻居节点集合中找到一个代价最小的，比如W节点，作为路径的下一跳，加入到N'集合，然后对N'集合中的节点的邻居节点继续标记计算...
![Pasted image 20260222204545.png|400](/img/user/accessory/Pasted%20image%2020260222204545.png)
![Pasted image 20260222204954.png|400](/img/user/accessory/Pasted%20image%2020260222204954.png)
![Pasted image 20260222205019.png|400](/img/user/accessory/Pasted%20image%2020260222205019.png)
![Pasted image 20260222204756.png|400](/img/user/accessory/Pasted%20image%2020260222204756.png)
![Pasted image 20260222205051.png|400](/img/user/accessory/Pasted%20image%2020260222205051.png)
![Pasted image 20260222205130.png|400](/img/user/accessory/Pasted%20image%2020260222205130.png)
![Pasted image 20260222205440.png|400](/img/user/accessory/Pasted%20image%2020260222205440.png)
![Pasted image 20260222205510.png|400](/img/user/accessory/Pasted%20image%2020260222205510.png)
![Pasted image 20260222205541.png|400](/img/user/accessory/Pasted%20image%2020260222205541.png)
![Pasted image 20260222205631.png|500](/img/user/accessory/Pasted%20image%2020260222205631.png)
![Pasted image 20260222204005.png|500](/img/user/accessory/Pasted%20image%2020260222204005.png)
Dijkstra算法的复杂度是$O(n^2)$, 好一点的实现是$O(nlogn)$
但是，假设拥塞程度是选取的代价，在一个周期后选择了一条路，但是都走这条路他的拥塞很快就会上去，显得另一条路比较空闲，所以是可能发生震荡的
![Pasted image 20260222210331.png|500](/img/user/accessory/Pasted%20image%2020260222210331.png)

### 距离矢量路由选择 Distance Vector Routing
距离矢量选择算法的基本思想 -- 各路由器维护一张路由表，包括To(目标) Next(下一跳)，cost(代价值)。
![Pasted image 20260223192550.png|400](/img/user/accessory/Pasted%20image%2020260223192550.png)
当然具体到路由表的时候，到目标每一个节点实际上是由网络号和子网掩码这两个表项来代表
下一跳是我为了到达目标，我要发给我的哪个邻居，在上面的例子中，源A想要发送目标各B，需要通过它的邻居Z来到达
要与邻居或者说相邻的节点持续的相互交换所谓的距离矢量，距离矢量，其实就是约定好的顺序的代价所排列成的一个矢量
这样邻居就会把他到达所有的目标的距离矢量告诉我，而我又知道我的邻居有哪些，可以通过发送分组得到一些代价，比如拥塞程度延迟时间，这样我就可以通过邻居的距离矢量加上我的测量，来计算我通过这个邻居到达所有节点的代价值，这样我就可以计算我通过所有邻居到所有目标的代价值，从而选择一个最小的最合适的
定期测量 定期交换 邻居的给我 我的给邻居 通过定期的迭代 收敛到一定的值
![Pasted image 20260223194717.png](/img/user/accessory/Pasted%20image%2020260223194717.png)

距离矢量算法是基于动态规划的算法，递归方程是Bellman-Ford(贝尔曼福特方程)
![Pasted image 20260223195555.png|450](/img/user/accessory/Pasted%20image%2020260223195555.png)
![Pasted image 20260223195819.png|500](/img/user/accessory/Pasted%20image%2020260223195819.png)

两种时间会触发重新计算
- 对方把距离矢量传给我
- 我到邻居的代价发生了变化

距离矢量算法的一个特点：**好消息传的快，坏消息传的慢**
什么是好消息？
- 代价大变小了
- 原来是断路，现在通了

传的快指一步也不耽误，一次exchange传一次，传遍全网
![Pasted image 20260223201022.png|400](/img/user/accessory/Pasted%20image%2020260223201022.png)

坏消息传的慢：如果B和A突然断开了，B发现没法可达A了，但是C会说，你给我啊，我可达，我的代价是2，实际上C可达A的方式下一跳是B，这样B到达A的代价就变成了3，这样就会形成一个循环，每一个exchange代价+1，无限次之后代价才能到达无穷大
![Pasted image 20260223201327.png|500](/img/user/accessory/Pasted%20image%2020260223201327.png)

有一种方法可以减少这种环路的情况，这种方法叫做**水平分裂(split horizon)算法**
具体来说，就是C知道自己到达A要经过B，而B说到A处不可达，B才是到A的权威信息，所以C就认为自己也不可达A了，从C处进行了一个水平分裂，告诉B的时候（B是权威），C会比较谦虚，说不可达，意思是，我要经过你才能到达A，你B就别走我了，但是告诉D的时候，仍然传送记录的真实的值，是说到达A的代价是2
哈哈哈C精神分裂了
![Pasted image 20260223202137.png|400](/img/user/accessory/Pasted%20image%2020260223202137.png)
水平分裂算法在环状里面不太好使

距离矢量算法 eg:
横轴是时间，纵轴是各个节点
![Pasted image 20260223202956.png|500](/img/user/accessory/Pasted%20image%2020260223202956.png)
![Pasted image 20260223203206.png|500](/img/user/accessory/Pasted%20image%2020260223203206.png)

### LS v.s. DV
![Pasted image 20260223203358.png|500](/img/user/accessory/Pasted%20image%2020260223203358.png)
