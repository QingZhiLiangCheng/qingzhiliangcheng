---
{"created":"2025-12-01T20:25","updated":"2026-02-06T14:21","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/3.2 多路复用和解复用/","dgPassFrontmatter":true,"noteIcon":""}
---

#### Overview
在网络层是主机到主机从一个IP传到另一个IP，到了传输层，不管是TCP还是UDP，为了区分到不同进程到不同进程，增加了一个机制——端口号
> [!note]
> 端口号是一个16比特的数，0~1023范围的端口号成为周知端口号

但是TCP和UDP所使用端口的方式不太一样。在[[Computer Networking A Top-Down Approach/2.1 应用层协议原理#问题2：传输层提供的服务 -- 需要穿过层间的信息\|2.1 应用层协议原理#问题2：传输层提供的服务 -- 需要穿过层间的信息]]介绍过。
多路复用就是指，从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装，该头部信息用于以后得解复用。
解复用就是指，根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字
#### TCP多路复用解复用
TCP具体的复用解复用过程是这样的：
首先源与目标已经各自本地建立好了TCP Socket，根据之前的学习，这是一个四元组(源IP，源Port端口，目标IP，目标端口)，而且是在本地的一个类似文件描述符的句柄。
应用层往下交的是socket和Message。
我们在这里暂时忽略Message报文的拆分或者合并(实际上在[[Computer Networking A Top-Down Approach/2.1 应用层协议原理#问题2：传输层提供的服务 -- 需要穿过层间的信息\|2.1 应用层协议原理#问题2：传输层提供的服务 -- 需要穿过层间的信息]]也介绍过），在TCP层会在报文前面加上head(包含源Port，目标Port)封装成TCP报文段，TCP报文段与源IP，目标IP(代码层面可能是传的socket的引用，但概念层面其实就是源IP和目标IP) 一起传给下层的IP层
在IP层会将源IP与目标IP写入IP的头部封装成package
![Pasted image 20251202111214.png|400](/img/user/accessory/Pasted%20image%2020251202111214.png)
我们暂时先忽略是怎么传到目标IP主机的，但目标的IP层拿到之后，会取出其中的IP body(实际上就是TCP报文段)的部分，同时将拿到的body部分TCP报文段与源IP，目标IP 传给上层的TCP
上层的TCP拿到TCP报文段和IP信息后，会再TCP报文段中取出body部分(报文)，读取报文段头部的源Port和目标Port，TCP层将源Port和目标Port与下层传上来的源IP，目标IP重新拼成四元组，能够找到主机中对应的Socket以及PID，然后传给对应的应用
![Pasted image 20251202111229.png|400](/img/user/accessory/Pasted%20image%2020251202111229.png)

![Pasted image 20251222171528.png|500](/img/user/accessory/Pasted%20image%2020251222171528.png)

![Pasted image 20251222171841.png|500](/img/user/accessory/Pasted%20image%2020251222171841.png)
#### UDP多路复用解复用
在UDP中，socket是两元组(本地IP，本地端口)
在UDP中，APP往下交的是 1. Message, 2. socket(代表着本地IP，本地端口)，3. 一个标识对方IP对方端口的结构体
这样UDP就知道怎么封装源Port目标Port，源Port通过Socket查，目标Port从结构体中拿，封装成UDP报文段传给下层，同时往下交message，结构体
同样，IP层也知道怎么封装上源IP目标IP封装成IP分组
这样就能正确传输到对方的IP实体，分解之后拿到目标IP以及IP body部分(实际上就是UDP报文)传给UDP
UDP拿到目标IP，拆解出目标Port以及APP的message，这样就能在本地维护的表里查到这个IP和端口的message，就能找到是哪个端口的应用
![Pasted image 20251222165050.png|500](/img/user/accessory/Pasted%20image%2020251222165050.png)
总结
引入sokcet的概念是为了使层间接口的信息来的最方便最少。
TCP和UDP引入了Port
TCP是面向连接的，UDP是无连接的。UPD不知道要跟谁通信，所以事实上UDP的socket中是没有目标IP和目标Port的；也正因为此，UDP在往下传的时候，除了socket和要传的信息，还要告诉下层我要传给谁，具体表现为一个目标IP目标端口的结构体
![Pasted image 20251222170812.png|500](/img/user/accessory/Pasted%20image%2020251222170812.png)

![Pasted image 20251222170857.png|500](/img/user/accessory/Pasted%20image%2020251222170857.png)

![Pasted image 20251222171313.png|500](/img/user/accessory/Pasted%20image%2020251222171313.png)
两个主机上的不通端口的应用都发给了服务器上的同一个端口的应用

值得注意的一个点是，由于UDP socket是(目的IP和目的Port)，所以如果两个UDP报文有不同的源IP或源Port，但具有相同的目的IP和目的Port，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程

