---
{"created":"2025-12-01T20:26","updated":"2026-01-02T17:21","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/3.5 面相连接的传输TCP/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
TCP向应用基础提供的是点对点的服务，即一个应用进程到另外一个应用应用进程点到点的双向的数据通信
TCP提供的是字节流的服务：发送方的应用进程交给下面的TCP什么样的字节流，接收方的TCP就交给应用进程什么样的字节流，不出错，不重复，不丢失，不失序，原原本本。但不提供报文的界限，这意味着发送方交给TCP的可能是两个报文，但是不能保证接收方的应用进程收到的就是两个报文，可能是一个大的报文，也可能是四个小的报文
TCP提供的是管道化和流水线的协议，可以在对方未经确认的情况下，向对方发送连续的很多TCP的段，应用程序交下来的报文，会按照MSS(Maximum Segment Size, 最大报文段长度)进行分割，并加上头部，变成很多TCP的报文段。 但TCP会给这些连续发送的TCP报文段提供拥塞控制，流量控制
![Pasted image 20251229212411.png|400](/img/user/accessory/Pasted%20image%2020251229212411.png)

![Pasted image 20260102161158.png|600](/img/user/accessory/Pasted%20image%2020260102161158.png)
发送方具有发送缓冲区，用于发送之后的检错重发，超时重传
接收方具有接受缓冲区，因为接收方读取的速率与发送方发送的速率是不一样的
全双工：同一连接中数据流可以同时双向
面相连接

最大报文段(MSS, Maximum Segment Size)是TCP能从缓存中取出并放入报文段中的数据数量的最大值 -- 其实上面的图也表示的很明确了，是从报文中取出来的最大值，换句话说，是MSS加了TCP head变成了TCP Segment
值得注意的是MSS通常是根据由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元(MTU, Maximum Transmission Unit)来设置的）！
注意MTU不包含帧头！是“链路层”对“上层可承载数据”的限制，是链路层中负载payload的最大长度！
所以是先有的MTU的长度，MTU是帧的最大长度，减去通常的20B IP头部，减去20B的IP头部，减去20B的TCP头部就是MSS的长度
比如在以太网中和PPP中，像之前图画的那样，以太网和PPP由1500字节的MTU，所以MSS的值为1460


### TCP段结构
![Pasted image 20251229212543.png|450](/img/user/accessory/Pasted%20image%2020251229212543.png)
16比特源端口号，16比特目的端口号
32比特序号，32比特确认号
序号是字节流的序号，即这个TCP报文端的body部分的第一个字节在整个报文中的偏移量
offest = begin + n * MSS
![Pasted image 20260102161446.png](/img/user/accessory/Pasted%20image%2020260102161446.png)

一般初始序号并不是从0开始的，这是因为方式一些老的在连接中的段对新连接造成影响
确认号：也是对字节计数，假设接收方给发送方一个555，意味着：接收方已经收到了554及554之前的所有的字节，这意味着接收方期望着发送发从555字节之后开始发送
![Pasted image 20260102161357.png](/img/user/accessory/Pasted%20image%2020260102161357.png)

首部长度：以4个字节为单位的首部长度
标志位：其中R, S, F是主要用于两个应用进程建立连接的标志位，有的标志位的组合表示第一次握手，有的标志位的组合表示第二次握手，有些标志位的组合代表连接建立的请求，有些标志位组合代表的是连接释放的请求
接收窗口用于流量控制，数值意味着愿意接受那么多字节的数据
checksum校验和: 和UDP中的checksum作用一致，校验是否出错，依然是UDP学过的，16bit求和，进位回滚，反码
除了20字节的固定长度，还有一些可选项，也是属于头部的一部分，具体到哪里开始时body部分，看首部长度
![Pasted image 20260102160911.png](/img/user/accessory/Pasted%20image%2020260102160911.png)

![[Pasted image 20251230190306.png\|Pasted image 20251230190306.png]]

TCP序号和确认号的关系：
![Pasted image 20251230190612.png|300](/img/user/accessory/Pasted%20image%2020251230190612.png)
有一种应用叫做telnet，运用了回显的技术 -- 客户端发送的每一个服务器发送到了服务器，服务器要回转回来然后客户端再给出相应的确认
图中假设的初始建立连接的时候，第一条报文：Seq=42, ACK=79, data='C', HostA的报文段从42号开始传，ACK=79，意味着想让HostB从79开始传
HostB接收到之后，往回传ACK=43，意味着42我收到了，你该传43了，而且B知道了A表示78及之前都收到，HostB会传79
双方开始的序号是经过协商了的！
**超时计时器的设置**
对于客户端和服务器中间可能是隔了很多跳，事实上，延迟时间是不固定的，密度函数是很分散的，但是从一小段时间来说，临近时间的延迟时间是大致相同的，又是很集中的。
采用的方法：一定时间测定往返延迟，测量平均值，测量方差，往返延迟的平均值加四倍标准差就涵盖了大约99.9937%的情况(正态分布), 这个值就作为超时时间 -- 具体实现可能有一点出入，但是就是这样类似的思想
可以开启计时器，打出一个报文段，确认回来，关闭计时器，这段时间叫一个sampleRTT
平均值的计算：当前simpleRTT贡献α，前一个时间段的采样值对平均值贡献1-α，再往前再乘1-α, 前面的采样值的权重是乘指数级下降的 -- 其实跟PPT中写的过去平均值乘1-α + 当前采样值乘α时一回事
![Pasted image 20251230192205.png|400](/img/user/accessory/Pasted%20image%2020251230192205.png)
![Pasted image 20251231164356.png|300](/img/user/accessory/Pasted%20image%2020251231164356.png)
计算当前采样值离当前平均值的一个偏差的平均值，其实就相当于标准差
![Pasted image 20251231164900.png|400](/img/user/accessory/Pasted%20image%2020251231164900.png)
然后把超时时间设置为RTT的估计值+4倍偏差

### 可靠数据传输
TCP是一个pipline的协议，在[[Computer Networking A Top-Down Approach/3.4 可靠数据传输的原理\|3.4 可靠数据传输的原理]]中我们学过两种pipline的协议，一种叫Go Back N协议, 一种叫Selective Repeat协议。但事实上，TCP协议实现RDT(可靠数据传输)的方式是这两种协议的一种混合
TCP是累计确认，如果确认号是555，意味着发送方以及收到了554及554之前的所有序号的所有字节，确认号表示一个期待，希望发送方从555号字节开始传（像GBN）
TCP是累计重传，设置单个重传计时器，只和最先发出去的那个段相关联，像GBN
如果超时，并不是把所有的段都放一遍，而是只放最老的那个段，这一点像Selective Repeat协议
如果接收方收到一个乱序的，处于缓冲区的段，TCP并没有对这部分做规范，可以缓存也可以抛弃
触发重发的事件
- 超时
- 重复的确认：在收到了ACK50后，又收到了3个冗余的ACK50的确认

对于Sender:
![Pasted image 20260102105721.png|450](/img/user/accessory/Pasted%20image%2020260102105721.png)
接着连续发送，tail移动，但用的还是老的计时器
![Pasted image 20260102105829.png|500](/img/user/accessory/Pasted%20image%2020260102105829.png)

情况一：如果现在接收到ACK555，意味着554及其554之前的字节都已经接收到，滑动窗口base移动，关闭计时器。重启新的计时器，希望发送方从555字节开始发，发送方会从555字节开始封装TCP头部，启动新的计时器再发送
![Pasted image 20260102110516.png|500](/img/user/accessory/Pasted%20image%2020260102110516.png)
情况二: 接着发送555字节所在的段，然后才收到ACK555
![Pasted image 20260102110904.png|500](/img/user/accessory/Pasted%20image%2020260102110904.png)

![Pasted image 20260102111030.png|500](/img/user/accessory/Pasted%20image%2020260102111030.png)

对于Receiver：
![Pasted image 20260102150145.png|500](/img/user/accessory/Pasted%20image%2020260102150145.png)
由于是累计确认，接收方会有一个辅助计时器，若500ms内下一个段到来，一起发一个ACK
![Pasted image 20260102151335.png|300](/img/user/accessory/Pasted%20image%2020260102151335.png)
乱序达到
![Pasted image 20260102151506.png|300](/img/user/accessory/Pasted%20image%2020260102151506.png)
gap全部填充
![Pasted image 20260102151739.png|350](/img/user/accessory/Pasted%20image%2020260102151739.png)
gap部分到达
![Pasted image 20260102152039.png|400](/img/user/accessory/Pasted%20image%2020260102152039.png)

**快速重发**
三个冗余ACK就重发
![Pasted image 20260102152715.png|500](/img/user/accessory/Pasted%20image%2020260102152715.png)
不等超时机制，直接重发

### 流量控制
防止发送方发送太快，超过接收方的处理能力，核心就是给反馈
![Pasted image 20260102163014.png|500](/img/user/accessory/Pasted%20image%2020260102163014.png)
接收方存在一个缓冲区，Application通过Socket API取数据，IP往里灌数据
如果缓冲区中还有空间，通过一个revwindows字段，通过所谓的捎带技术发送给发送方告诉发送方我还有多少个空的字节
所谓的捎带技术(Piggybacking)就是，ACK和一些别的信息随着B发给A的信息发给A

### 连接管理
连接是发送方和接收方要建立连接
本质上是要知道和对方通信，准备好资源，包括一些缓冲区，接收窗口发送窗口等，做好一些置位，特别是双方要互通发送报文段的起始序号
本质上TCP的连接建立是3次握手
Q: 2次握手可行吗？
![Pasted image 20260102164019.png|200](/img/user/accessory/Pasted%20image%2020260102164019.png)
不可行
![Pasted image 20260102164220.png|250](/img/user/accessory/Pasted%20image%2020260102164220.png)
这样从服务器的角度来看，只要来连接请求就会建立，实际上是维护了很多虚假的半连接
![Pasted image 20260102164635.png|250](/img/user/accessory/Pasted%20image%2020260102164635.png)
3次握手！
![Pasted image 20260102164947.png](/img/user/accessory/Pasted%20image%2020260102164947.png)
中间从服务器到客户端那个用了捎带
![Pasted image 20260102165125.png|200](/img/user/accessory/Pasted%20image%2020260102165125.png)
3次连接解决版链接和接受老数据的问题
![Pasted image 20260102165210.png](/img/user/accessory/Pasted%20image%2020260102165210.png)
服务器不会自己建立起连接，所以发送的数据不会被服务器接受，滞留在中间
但如果一旦时间服务器和客户端的同一个端口接着又建立了连接，这个滞留的数据到了，那滞留的数据就给新连接造成了影响，这就是为什么两边在握手的时候需要规定一个开始的序号
这个序号可能是随机的32比特的一个数，也有的是选择当前时钟周期的低32位作为初始序号

**连接释放**
每个方向单独拆除 两个 半连接对称释放
![Pasted image 20260102170149.png|500](/img/user/accessory/Pasted%20image%2020260102170149.png)
存在两军问题
![Pasted image 20260102170610.png|400](/img/user/accessory/Pasted%20image%2020260102170610.png)
最后一段是永远是不可靠的 事实上发送方都不知道接收方有没有收到自己的内容（可能丢失了），A不能在发送完ACK后立即彻底关闭连接并释放所有资源，因为它无法100%确定B已经知道“连接可以彻底关闭了”，会启动一个计时器，一段时间内没有收到信息就可以释放了