---
{"created":"2025-10-12T20:13","updated":"2026-01-28T15:30","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/2.1 应用层协议原理/","dgPassFrontmatter":true,"noteIcon":""}
---

> [!quote]
> 对应原书2.1 Principles of Network Applications的内容
> 感觉有的部分不如老师讲的好
> // 2026.1.27 读原书 补

### 网络应用的体系结构
#### 客户-服务器(C/S) 体系结构
![Pasted image 20251012202608.png|300](/img/user/accessory/Pasted%20image%2020251012202608.png)
服务器先运行且一直运行，有固定的IP地址，域名，约定好的接口
客户端主动与服务器进行通信，可能是动态IP地址(比如我们校园网在不同的地方不同的WIFI就是不同的IP)，不能直接与其他客户端通信
服务器和客户端这两种节点是不对等的，服务器是中心，资源在服务器上
CS资源的缺点：可扩展性差 随着访问用户的增加，性能达到一定阈值之后是极具性的下降 ； 可靠性差，服务器宕机就挂掉了

#### P2P(对等体)体系结构
![Pasted image 20251012203520.png|300](/img/user/accessory/Pasted%20image%2020251012203520.png)
任何节点即是客户端又是服务器，增加节点时，会带来新的服务能力，也会带来新的服务请求
eg. 迅雷
难以管理
不需要庞大的服务器基础设施和服务器宽带

#### 混合体
**Napster**
Napster是之前大一学生做的一个音乐分发客户端。工作原理是当客户端运行起来的时候会像服务器发送一个注册的命令，告诉服务器“我上线了，我的IP是多少，拥有哪些MP3可以跟别人共享”；然后一个想下载音乐的客户端就会发起请求，然后服务器更多的是调度的作用，然后这个客户端得到音乐后再做出一些注册
目录查询是集中式的，文件的分发是P2P的方式

### 进程通信
网络想要跑起来，需要提供应用之间的通信
如果两个进程跑在一台机器上，那可以通过管道，消息队列... 这些机制来完成通信
但是如果两个应用在不同的终端上，就需要一定的相应的规范来达成通信，主要是通过操作系统所提供的报文Message服务能够收发报文
首先，发起通信的进程，我们叫做客户端进程(clients);等待连接的进程，叫做服务器进程(servers)
> [!quote]
> In the context of a communication session between a pair of processes, the process that initiates the communication (taht is, initially contacts the other process at the beginning of the session) is labeled as the client. The process that waits to be contacted to begin the session is the server.
> 在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程叫客户进程，在会话开始时等待联系的进程是服务器进程。


#### 分布式进程通信需要解决的问题
问题1: 进程标示和寻址问题 -- 这就像我们买快递需要标识自己的地址一样，所谓的标识，就是这个标识是唯一的，能够跟其他进程能够区分，同时这个标识还应该具备一个寻址的作用，让别人能够找到。
问题2: 应用通过层间结构所提供的服务向对方发送报文，那下层所提供的形式是什么？下层所提供的服务在哪里能够调用？ --  通过层架接口上的SAP，通过SocketAPI这样的形式(一种原语)来访问传输层向上层所提供的服务
问题3：定义协议 -- 如何定义报文格式，见到什么报文的时候做什么动作

#### 问题1: 对进程进行编址(addressing)
进程为了接收报文，必须有一个标识，有这个几个要素
- 唯一的32为IP地址: 在哪
- TCP or UDP: 应用进程是在TCP的协议上跑还是UDP的协议上跑
- 端口号(Port Numbers): TCP或UDP上有好多应用进程，到底在哪个端口上

传输层向应用层的应用做区分，除了IP之外，还引入了一个新的技术机制 -- 端口号，UDP和TCP的端口号都是16个bit(0~65535)，用于区分不同的应用进程, 但UDP和TCP使用端口号的方式会有一些不一样，后面会介绍
实际上两个应用进程的会话关系，是由两个端节点(end point)来决定的，这个端节点指的是IP上的某个UDP或者TCP的端口

#### 问题2：传输层提供的服务 -- 需要穿过层间的信息
![Pasted image 20251017101740.png|400](/img/user/accessory/Pasted%20image%2020251017101740.png)
进程之间想要通信，逻辑上是两个进程之间通信，但物理上实际上是通过了下层所提供的服务，那穿过层间需要哪些信息？
- 要传输的信息：本层的SDU, 在应用层中，SDU为Message(报文)
- 谁传的: 自己的应用进程标示: 自己的IP+TCP(UDP)端口号
- 传给谁: 对方的应用进程标示: 对方的IP+TCP(UDP)端口号

传输层根据上面传下来的这些信息进行TCP报文段或UDP数据报的封装
通讯会持续一段时间，如果每次发送和接受的时候都传输这些信息，会很烦，减少**层间传输信息量**的一个办法 -- **socket**
##### TCP Socket
TCP Socket实际上就是一个IP地址加端口号，是个整数，就好比我们C语言创建一个文件之后会返回一个文件描述符或者叫文件句柄，对这个描述符或者文件句柄操作就是对文件操作; 在网络中也是一样的，一旦一个应用进程与对方建立连接，操作系统就会返回一个整数，这个整数在就代表了(源IP，源port，目标IP，目标port)这个四元组；应用层的应用进程只需要用这个socket发，本主机的操作系统就知道从我这个主机的哪个端口号发给对方主机的哪里
这里要注意，TCP的socket是代表四元组的一个本地意义上的标识，它是由本主机的操作系统分配的，只有本地的应用层传输层知道，甚至源主机和目标主机的操作系统分配给各自的socket的值，它实际上就是在本地上建立起来的一张表，代表着本机的socket和四元组的对应关系
![Pasted image 20251017105929.png|400](/img/user/accessory/Pasted%20image%2020251017105929.png)

那么当源主机上的应用进程想要发送东西的时候，只需要借助socekt来层间传输往下传
![Pasted image 20251017110714.png|300](/img/user/accessory/Pasted%20image%2020251017110714.png)
其中ICI是接口控制信息，是上层(在这里是应用层)传给下层(这里是传输层)的指令，告诉下层怎么处理这个SDU
TCP会给上层传下来的SDU加上TCP头，这个头实际上里面就包含根据socket的那张表所查询出来的源Port，目标Port,然后TCP这一层的ICI里面包含着源IP和目标IP，然后再传给IP(网络层)，使其将源IP和目标IP在加到IP头中

![Pasted image 20251017111637.png|500](/img/user/accessory/Pasted%20image%2020251017111637.png)

事实上TCP就好比于顺丰寄东西的时候，由于经常和朋友寄东西，直接给货物和一个整数说老样子，顺丰就知道怎么寄
##### UDP Socket
UDP Socket也是一个具有本地意义的标识，但是不同的是，他是个2元组，只有源IP和源port
事实上这也是UDP和TCP的一个差距，UDP是说我只管源发，不管你收不收到，而TCP是我既然发了就要目标端口和目标源收到
而且事实上从应用层往下传的时候，需要指定的是 数据本身SDU，源IP，源端口，目标IP，目标端口。那么也就是说，事实上TCP往下传的时候，只需要传数据本身+TCP socket；而UDP不同，要指定数据本身，UDP socket，还要指定目标IP和目标端口
![Pasted image 20251017170719.png|400](/img/user/accessory/Pasted%20image%2020251017170719.png)


#### 问题3：如何使用传输层提供的服务实现应用
##### 应用层协议
协议是对等层的应用进程在通信过程中应该遵守的规则集合 -- 规定了语法，语义，动作和次序
应用协议仅仅是应用的一个组成部分, Web应用：HTTP协议，web客户端，web服务器，HTML...
应用层协议分为两类
- 公开协议
- 专用(私有)协议

##### 应用需要传输层提供什么样的服务？
如何描述传输层的服务？有哪些指标？
- 数据丢失率
	- 有些应用要求100%的可靠数据传输 -- 比如文件 -- 可以用TCP
	- 有些应用能容忍一定比例下的数据丢失 -- 如音频 -- 可以用UDP
- 延迟
	- 多媒体应用对延迟比较敏感 -- UDP
- 吞吐
	- 一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转
- 安全

> [!quote] Throughput
> Throughput
> available throughput, is the rate at which the sending process can deliver bits to the receiving process. -- 可用吞吐量是发送进程能够像接受进程交付比特的速率
> Because other seesions will be sharing the bandwith along the network path, and because these other sessions will be coming and going, the available throughput at some specified rate. -- 共享宽带，并且共享宽带的会话数量不定，可用吞吐量实际上是波动的
> A transport-layer protocol could provide, namely, guaranteed available throughput at some specified rate. -- 有的运输层协议能够以某种特定的速率确保可用吞吐量。
> bandwith-sensitve applicaitons -- 有吞吐了需求的叫宽带敏感应用 
> elastic applications -- 弹性应用，根据当时可用的带宽或多或少地利用可供使用的吞吐量



![Pasted image 20251017180118.png](/img/user/accessory/Pasted%20image%2020251017180118.png)

##### Internet 传输层提供的服务
**TCP服务**
可靠，流量控制， 拥塞控制，面向链接，通信之前需要握手
其中流量控制是说，源TCP实体发送的数据太快了，目标TCP实体处理不过来，就会给源TCP实体一个反馈
拥塞控制是说，网络如果出现了堵塞，tcp实体能够感知到网络的堵塞，带宽会掐住或者放开
TCP不提供时间保证，不提供最小吞吐保证，不提供安全保证，但会有一些别的机制来实现安全
> [!quote]
> 书中在这里强调了TCP的connection-oriented service(面向连接的服务)是full-duplex connection(全双工的连接), a full-dulex connection in that the two processes can send messages to each other over the connection at the same time.
> 同时书中强调了什么叫做Reliable data transfer service(可靠)，即without error  and in the proper order. with no missing or duplicate dytes. 其实总结一下就是老师经常在视频(忘了实在哪里节)中说的 不重复，不丢失，不出错，不乱序！


**UDP服务**
不可靠的数据传输，不提供可靠的服务，不提供流量控制，不提供拥塞控制，不提供带宽保证，不建立连接
那为什么还要有UDP？
**UDP存在的必要性问题**
IP只能提供主机到主机的划分，而UDP通过增加端口号这样的机制能够区分不同的进程
不需要建立连接，事务性的应用建立连接可能会耽误时间
不做可靠性的工作，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用
没有拥塞控制和流量控制，应用能够按照设定的速度发送数据


![Pasted image 20251017180907.png|500](/img/user/accessory/Pasted%20image%2020251017180907.png)

**安全TCP**
TCP和UDP都不提供安全的各种特性，明文传输
增加安全性怎么办？
在TCP之上有一个实现叫做SSL(secure socket layer, 安全套接字层), SSL能够加强TCP的安全性，向应用进程app提供安全的通信服务，包括服务器端的认证，客户端的认证，私密传输，报文的完整性
SSL在应用层，应用将SSL的库放在一起去编译运行
HTTP+SSL=HTTPS

> [!quote]
> 书中同样提到了TCP和UDP不提供各种安全特性和明文传输 -- Neither TCP or UDP provides any encryption. -- the cleartext password will travel over all the links between sender and reveiver.
> 但是原书在这里讲的enhancement for TCP是TLS(Transport Layer Security),而非SSL
> 同样书中介绍了TLS including encryption, data integrity, and end-point authentication. （加密、数据完整性及终端认证）
> 并且提到了TLS socket -- TLS in the sending host then encrypts the data and passes the encrypted data to the TCP socket. ...
> 我问了一下Gemini TLS和SSL的区别，Gemini给我的回答是本质上核心上实际上是一个东西，在发展历史上，SSL的各个版本被发现存在严重的安全漏洞，为了应对这些威胁，互联网工程任务组（IETF）在SSL 3.0的基础上进行了升级和标准化，并于1999年发布了TLS 1.0
> 同样，当一个网站使用了SSL/TLS进行保护后，其网址会以“HTTPS”（Hyper Text Transfer Protocol Secure，安全超文本传输协议）开头，而不是“HTTP”

