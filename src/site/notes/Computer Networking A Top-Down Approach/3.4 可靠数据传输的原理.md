---
{"created":"2025-12-01T20:25","updated":"2025-12-29T20:53","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/3.4 可靠数据传输的原理/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
3.4主要讲RDT(reliable data transform，可靠数据传输)的原理
![Pasted image 20251222201540.png|500](/img/user/accessory/Pasted%20image%2020251222201540.png)
在这里学是因为常见的传输层的TCP实现了可靠数据传输，但其实在某些网络的数据链路层，某些网络的网络层也会实现RDT，这是网络Top3问题之一
这里讲的是一般化的可靠数据传输原理，上层的用户称之为应用层的Process，图中有一个sending process, receiver process，可靠数据传输要实现的就是sending process传下来的数据是什么样的，传到receiver process的数据就应该是什么样的，具体来说就是，不出错！不重复！不失序！不丢失！
下层的服务是UDT(不可靠数据传输)的，在本层要封装上一些东西，在图中是一个抽象的说法，封装成一个packet，（实际上在TCP上是封装成一个segment(报文段)），封装成packet之后，借助下层所提供的服务，调用一个原语（在图中是udt_send()), 把数据发走；对方通过原语收到之后，可能是乱序的，通过一定的措施，不管怎么样，会像上层交付一个原原本本的data
![Pasted image 20251222204130.png|500](/img/user/accessory/Pasted%20image%2020251222204130.png)
面临的问题简单来说就是：在下层所提供的服务是不可靠的情况下，本层协议实体要靠哪些资源机制的安排，为上层提供可靠的服务
这里的学习的方式是假设下面的channel是reliable的，不出错不丢失不乱序... 然后将这些假设一个个去掉，每去掉一个假设就需要增加一些机制
这里注意，数据的传输是双向的，但我们能把双向看做两个单向，所以这里只需要讲明白Sending发往Receiver就可以了，但是要注意里面可能会用到一些数据的反馈，Receiver给Sending的反馈 -- 换句话说，虽然只考虑单向数据传输，但是控制信息是双向的！
除此之外，我们使用有限状态机（FSM）来描述发送方和接收方，其实就是状态迁移的过程，就像我们在jyy操作系统课上学的C语言的状态机，操作系统的状态机一样
![Pasted image 20251222205947.png|500](/img/user/accessory/Pasted%20image%2020251222205947.png)

### Rdt 1.0: 在可靠信道上的可靠数据传输
假设不出错 不丢失
![Pasted image 20251223093608.png|400](/img/user/accessory/Pasted%20image%2020251223093608.png)
发送方接受数据，封装成packet，打走
接收方从下层接受packet，解封装，交给上层

### Rdt 2.0: 具有比特差错的信道
假设在传的过程中可能会出错，将分组中的比特翻转
![Pasted image 20251223094207.png|400](/img/user/accessory/Pasted%20image%2020251223094207.png)
这个时候EDC校验和就起作用了
发送方sending传送packet给接收方receiver，接收方可以校验有没有出错，如果没有出错，返回一个ACK(acknowledgment，确认应答)，这时候发送方可以发送下一个packet；如果检测发现出错了，返回一个NAK(Negative Acknowledgment)，发送方会重传
这种一次只发送一个等待确认的这种分组，称作stop and wait协议(停止等待协议)
所以这里的机制有：发送方做差错控制编码；接收方做差错控制解码；发送方发完之后要留副本；接收方要给反馈；发送方要能够识别反馈做出不同的动作
![Pasted image 20251223094830.png|400](/img/user/accessory/Pasted%20image%2020251223094830.png)
Rdt2.0 有一个致命的缺陷：ACK和NAK也可能出错！！
### Rdt 2.1:  处理出错的ACK/NAK
新的机制：序号 sequence number
整体思想就是如果发送方接收到一个不知道ACK还是NAK的消息，不管三七二十一，再传一遍刚刚传的$P_0$，由于引入了序号的机制，接收方能够识别你是否又给我发了一遍$P_0$,如果是，就知道我上次发送的ACK或者NAK出错了，然后再给出应答
![Pasted image 20251223095927.png|150](/img/user/accessory/Pasted%20image%2020251223095927.png)
发送方处理出错的ACK/NAK
![Pasted image 20251223100444.png|500](/img/user/accessory/Pasted%20image%2020251223100444.png)
接收方处理出错的ACK/NAK
![Pasted image 20251223101159.png|500](/img/user/accessory/Pasted%20image%2020251223101159.png)
具体来说整个过程：
发送方在收到上层发下来的数据后，封装成packet0（包括了差错控制编码），并且打出去，等待接收方来自packet0的反馈信息，ACK0或NAK0
如果收到正常的NAK或者收到不知道是什么的信息(corrupt(rcvpkt)),重新发送packet0，继续等待反馈信息
如果收到正常的ACK，就等待上层发下来新的数据，封装成packet1并打出去
接收方在收到packet后，假设接收方在等到序号0的分组，如果序号正确，校验正确，就可以解封装拿到data传给上层，并且给发送方一个ACK的反馈（ACK也要checksum），转为等待需要1的分组的状态
如果来了1当然好，但是如果来了一个没有出错的0号的分组序号，这代表接收方第一次发送的ACK发送方未能识别，重新发送一个ACK
由于这是只发送一个等待确认的协议，所以我们只需要一位来作为序号就可以了，1和0区分出老的和新的
事实上receiver并不知道发出去的确认是否被收到，因为没有一个确认的确认，如果安排一个确认的确认，那要不要有一个确认的确认的确认是一个问题；所以这里采取的措施就是上面讲的这种方式，通过收到的分组的序号，来区分发出去的确认有没有问题
### Rdt 2.2: 无NAK的协议
NAK free -- 没有NAK，只有ACK，对ACK编号
这里主要的思路是这样的：现在是停止等待的协议，发送一个等待一个回复，如果想变成流水线的协议，就需要对ACK和NAK编号，但是这样同时有ACK和NAK比较多比较麻烦，这样就用ACK0对等NAK1，换句话说，如果我在等1的确认，如果传过来错了，就给一个0的ACK就好了
![Pasted image 20251224162706.png|400](/img/user/accessory/Pasted%20image%2020251224162706.png)

![Pasted image 20251224163205.png|500](/img/user/accessory/Pasted%20image%2020251224163205.png)

![Pasted image 20251224163245.png|350](/img/user/accessory/Pasted%20image%2020251224163245.png)

### Rdt 3.0: 具有比特差错和分组丢失的信道
新的假设：分组在传输过程中丢失了
为什么会出现丢失的情况？
路由器有queue队列，来的分组需要排到队列再传，如果队列是满的话，就会丢掉(drop)
假设packet1丢失了，如果没有采取任何措施的话，sender收不到回复，receiver收不到packet1，就会形成死锁
采取的机制：超时重传机制 具体来说就是发出分组之后启动一个超时定时器，超时定时器所定义的超时的时间是正常往返还多一点的时间，如果正常往返还多一点的时间回复还没来（可能是packet丢了，也可能是回来的ACK丢了），sender就可以在把刚刚发的分组再发一遍
如果是回来的ACK丢了的话，实际上就是带来了重复，但是重复并不是一个问题，或者说前面我们已经解决过了
超时时间设置成多少合适？
如果两个主机中间连了一个很大的网络，经历了很多路由器，往返延迟就比较不固定，跟概率论上所学的知识有一定关系，短时间内会呈现一种分布，这时候有一个适应性时间，适应性的去算延迟时间
![Pasted image 20251224182706.png|200](/img/user/accessory/Pasted%20image%2020251224182706.png)
如果在数据链路层中，虽然时间也有分布，但很多的时间分布会比较集中，所以可能会设置成一个固定的时间
![Pasted image 20251224184427.png|400](/img/user/accessory/Pasted%20image%2020251224184427.png)
不过这里有一点的区别
![Pasted image 20251224185210.png|200](/img/user/accessory/Pasted%20image%2020251224185210.png)
当Packet1出现问题的时候，Receiver会回一个ACK0，按前面学的来说的话，应该Sender立即重发一个Packet1，但是这里也可以改成，Sender1不动，等待接受ACK1超时，然后重放Packet1，效果是一样的，但不能两个机制都有，保留等待的这一个
![Pasted image 20251224184444.png|400](/img/user/accessory/Pasted%20image%2020251224184444.png)

![Pasted image 20251224184514.png|400](/img/user/accessory/Pasted%20image%2020251224184514.png)
注意这里有一种比较奇葩的情况，收到了但耗费的时间比超时时间长，就会出现上图d中的情况
->超时计时器设置很重要，如果设置不好，虽然可以正常工作，但效率是正常效率的百分之五十甚至是更低

至此，Rdt3.0，一次发送一个未经确认的分组的这样一个stop and wait协议就讲完了。
但stop and wait协议的问题在于: 效率比较低，具体来说就是在信道容量比较大的情况下，效率低
所谓信道容量，可以把链路想象成一跟管道，packet像一个小水流，信道容量就是整跟管子能承载的水流的个数

![Pasted image 20251227143056.png|450](/img/user/accessory/Pasted%20image%2020251227143056.png)
![Pasted image 20251227143550.png|300](/img/user/accessory/Pasted%20image%2020251227143550.png)

![Pasted image 20251227145620.png|500](/img/user/accessory/Pasted%20image%2020251227145620.png)

### 流水线协议
![Pasted image 20251227145720.png|500](/img/user/accessory/Pasted%20image%2020251227145720.png)
一次发送多个分组的协议：pipeline协议(流水线协议)
![Pasted image 20251227151117.png|400](/img/user/accessory/Pasted%20image%2020251227151117.png)
一次性发送多个分组也就意味着，我们需要增加多个序号来表示分组，如果用n个bit来表示，那整个序号的空间就是$2^n$
除此之外，需要在发送方和接收方设置缓冲区，这是因为发送方发送速率和用户获取的速率可能是不一样的
流水线协议有两个：一个叫Go back N(GBN, 回退N步)，一个叫selective repeat协议(SR, 选择重传)
讲解两种流水线协议之前，先介绍了一种一般的协议叫 Slide window(滑动窗口)协议
**Slide window**

| 发送方发送窗口 | 接收方接受窗口 | 协议类型          |
| ------- | ------- | ------------- |
| SW=1    | RW=1    | stop and wait |
| SW>1    | RW=1    | GBN           |
| SW>1    | RW>1    | SR            |

几个基本的概念：
**发送缓冲区**
发送方发送完毕之后把分组放在缓冲区中以备检错重发，超时重发
一次最多可以发送多少个未经确认的分组叫发送缓冲区的大小 -- 那对于stop and wait协议来说，发送缓冲区的大小就是1，流水线协议的发送缓冲区大小是大于1的，但不是无限大，前面介绍过了，链路的信道容量是有限的
**发送窗口**
发送缓冲区内容的一个范围，是指的已经发送但未经确认的那些分组的空间
可是是整个发送缓冲区，也可以是发送缓冲区的一个子集
一开始发送方没有发送任何一个分组的时候，发送缓冲区应该是一个空集
当发送方发送分组之后，发送缓冲区的前沿就能够向前滑动，表示这个范围内的分组已经发送但未经确认
![Pasted image 20251227153822.png|350](/img/user/accessory/Pasted%20image%2020251227153822.png)
![Pasted image 20251227153835.png|350](/img/user/accessory/Pasted%20image%2020251227153835.png)
图中绿色的是发送缓冲区，蓝色的发送窗口
发送窗口的范围最大就是发送缓冲区的大小
![Pasted image 20251227153858.png|350](/img/user/accessory/Pasted%20image%2020251227153858.png)
收到老分组确认，整个发送缓冲区(后沿 前沿)移动，来了新的分组进入发送缓冲区 前沿可以继续滑动发送
![Pasted image 20251227153726.png|350](/img/user/accessory/Pasted%20image%2020251227153726.png)

真正滑动过程 v.s. 相对滑动表示
![Pasted image 20251227160833.png|400](/img/user/accessory/Pasted%20image%2020251227160833.png)

**接收窗口**
接收窗口(reveiving window)就等同于接收缓冲区
接收窗口是可以被接受的分组的序号构成的一个空间
只有落在接受窗口范围之内的分组是可以被接收的
接收窗口=1 
![Pasted image 20251227161846.png|350](/img/user/accessory/Pasted%20image%2020251227161846.png)
在这个例子中接收窗口=1，只有一个分组可以被接受；一开始接收窗口在0的位置，只有0号能够被接收，等待0来了之后，接收窗口向前滑动...
那如果接收窗口在1的位置，2号分组来了，是不收的，做这么几个动作：(1)把2号分组抛弃掉 (2) 给ACK0（这样告诉发送方要发1，我收1）
如果接受窗口尺寸大于1
![Pasted image 20251227162256.png|350](/img/user/accessory/Pasted%20image%2020251227162256.png)
可以接受范围内的任何一个分组
![Pasted image 20251227162509.png|350](/img/user/accessory/Pasted%20image%2020251227162509.png)
3号分组和4号分组到来，可以分别发送确认，但在2号分组到来之前，不能滑动
滑动的条件是：低区号窗口的到来
如果2号窗口这时候到来，做出的动作，做出ACK2，滑动窗口向前滑格
在RW>1的这种形式，实际上是Select Receive协议，在上面的例子中，3号分组到来的时候给出ACK3的确认，但此时2号分组并没有到来，所以在Select Receive这个协议中，它的确认叫做**非累计确认**或**单独确认**。
而在RW=1的情况下，包括stop and wait 和 Go back N协议，是给顺序到来的最高分组给确认，确认意味着前面所有的分组都已经到达，叫做**累计确认**

**正常情况下两个窗口互动**
顺序到达接受窗口
![Pasted image 20251227163610.png|400](/img/user/accessory/Pasted%20image%2020251227163610.png)
发送方分组发送 推动了 发送窗口前沿向前滑动 意味着 接收窗口前沿向前滑动
接收方的发送确认 推动了 发送窗口的后沿向前滑动
新的分组又可能落入到移动后的发送缓冲区中 从而 继续发送

**异常情况下GBN的两窗口互动**
乱序到达
![Pasted image 20251229202819.png|400](/img/user/accessory/Pasted%20image%2020251229202819.png)
GBN自身的接收窗口大小是1，所以如果窗口在2号，来了3号，丢弃掉并且发送ACK=1，接收窗口不滑动
由于发送方得到的老的序号的确认，发送窗口没法向前滑动，造成超时重发机制，发送方要把发送缓冲区里的所有分组都重发一遍：这是因为有可能是发送缓冲区后沿的分组没有接受，而前沿的那些在接收方都被丢弃掉了，所以要全部重发一遍
**异常情况下的SR两窗口互动**
也是乱序的一种情况
![Pasted image 20251229203603.png|400](/img/user/accessory/Pasted%20image%2020251229203603.png)
乱序到来，只要在接受窗口所罩的范围内，就能够被接收，但是不能向前滑动，需要后沿或者说第序号的分组到达之后统一滑动

**GBN协议和SR协议的异同**
![Pasted image 20251229204422.png|450](/img/user/accessory/Pasted%20image%2020251229204422.png)
**窗口的最大尺寸**
GBN: $2^n-1$
SR: $2^{n-1}$

为什么 其实中文书的147页给过一点解释
GBN：假设n=3，如果窗口大小=8，发送方发送了序号为 0, 1, 2, 3, 4, 5, 6, 7 的所有数据包，接收方也都正确收到了这些包，意味着接受窗口移动了，又移动到了新的0，但如果所有这些 ACK 都在路上丢了，那计时器超时后，发送方会重新发送序号为0的数据包，这个时候就发生歧义了！
SR：假设n=3，如果窗口大小为5，大于$2^{3-1}=2$, 即发送窗口为0,1,2,3,4 接受窗口也为0,1,2,3,4。如果发送方发送了0,1,2,3,4的包，接收方全部收到，意味着接受窗口向前滑动，变成了5,6,7,0,1。假设发送的ACK都丢失了，这时候发送方超时，仍然发送0,1,2,3,4号包，就造成了歧义！

