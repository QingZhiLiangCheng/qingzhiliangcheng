---
{"created":"2025-12-01T20:25","updated":"2025-12-23T11:04","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/3.4 可靠数据传输的原理/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
3.4主要讲RDT(reliable data transform，可靠数据传输)的原理
![Pasted image 20251222201540.png|500](/img/user/accessory/Pasted%20image%2020251222201540.png)
在这里学是因为常见的传输层的TCP实现了可靠数据传输，但其实在某些网络的数据链路层，某些网络的网络层也会实现RDT，这是网络Top3问题之一
这里讲的是一般化的可靠数据传输原理，上层的用户称之为应用层的Process，图中有一个sending process, receiver process，可靠数据传输要实现的就是sending process传下来的数据是什么样的，传到receiver process的数据就应该是什么样的，具体来说就是，不出错！不重复！不失序！不丢失！
下层的服务是UDT(不可靠数据传输)的，在本层要封装上一些东西，在图中是一个抽象的说法，封装成一个packet，（实际上在TCP上是封装成一个segment(报文段)），封装成packet之后，借助下层所提供的服务，调用一个原语（在图中是udt_send()), 把数据发走；对方通过原语收到之后，可能是乱序的，通过一定的措施，不管怎么样，会像上层交付一个原原本本的data
![Pasted image 20251222204130.png|500](/img/user/accessory/Pasted%20image%2020251222204130.png)
面临的问题简单来说就是：在下层所提供的服务是不可靠的情况下，本层协议实体要靠哪些资源机制的安排，为上层提供可靠的服务
这里的学习的方式是假设下面的channel是reliable的，不出错不丢失不乱序... 然后将这些假设一个个去掉，每去掉一个假设就需要增加一些机制
这里注意，数据的传输是双向的，但我们能把双向看做两个单向，所以这里只需要讲明白Sending发往Receiver就可以了，但是要注意里面可能会用到一些数据的反馈，Receiver给Sending的反馈 -- 换句话说，虽然只考虑单向数据传输，但是控制信息是双向的！
除此之外，我们使用有限状态机（FSM）来描述发送方和接收方，其实就是状态迁移的过程，就像我们在jyy操作系统课上学的C语言的状态机，操作系统的状态机一样
![Pasted image 20251222205947.png|500](/img/user/accessory/Pasted%20image%2020251222205947.png)

### Rdt 1.0: 在可靠信道上的可靠数据传输
假设不出错 不丢失
![Pasted image 20251223093608.png|400](/img/user/accessory/Pasted%20image%2020251223093608.png)
发送方接受数据，封装成packet，打走
接收方从下层接受packet，解封装，交给上层

### Rdt 2.0: 具有比特差错的信道
假设在传的过程中可能会出错，将分组中的比特翻转
![Pasted image 20251223094207.png|400](/img/user/accessory/Pasted%20image%2020251223094207.png)
这个时候EDC校验和就起作用了
发送方sending传送packet给接收方receiver，接收方可以校验有没有出错，如果没有出错，返回一个ACK(acknowledgment，确认应答)，这时候发送方可以发送下一个packet；如果检测发现出错了，返回一个NAK(Negative Acknowledgment)，发送方会重传
这种一次只发送一个等待确认的这种分组，称作stop and wait协议(停止等待协议)
所以这里的机制有：发送方做差错控制编码；接收方做差错控制解码；发送方发完之后要留副本；接收方要给反馈；发送方要能够识别反馈做出不同的动作
![Pasted image 20251223094830.png|400](/img/user/accessory/Pasted%20image%2020251223094830.png)
Rdt2.0 有一个致命的缺陷：ACK和NAK也可能出错！！
### Rdt 2.1:  处理出错的ACK/NAK
新的机制：序号 sequence number
整体思想就是如果发送方接收到一个不知道ACK还是NAK的消息，不管三七二十一，再传一遍刚刚传的$P_0$，由于引入了序号的机制，接收方能够识别你是否又给我发了一遍$P_0$,如果是，就知道我上次发送的ACK或者NAK出错了，然后再给出应答
![Pasted image 20251223095927.png|150](/img/user/accessory/Pasted%20image%2020251223095927.png)
发送方处理出错的ACK/NAK
![Pasted image 20251223100444.png|500](/img/user/accessory/Pasted%20image%2020251223100444.png)
接收方处理出错的ACK/NAK
![Pasted image 20251223101159.png|500](/img/user/accessory/Pasted%20image%2020251223101159.png)
具体来说整个过程：
发送方在收到上层发下来的数据后，封装成packet0（包括了差错控制编码），并且打出去，等待接收方来自packet0的反馈信息，ACK0或NAK0
如果收到正常的NAK或者收到不知道是什么的信息(corrupt(rcvpkt)),重新发送packet0，继续等待反馈信息
如果收到正常的ACK，就等待上层发下来新的数据，封装成packet1并打出去
接收方在收到packet后，假设接收方在等到序号0的分组，如果序号正确，校验正确，就可以解封装拿到data传给上层，并且给发送方一个ACK的反馈（ACK也要checksum），转为等待需要1的分组的状态
如果来了1当然好，但是如果来了一个没有出错的0号的分组序号，这代表接收方第一次发送的ACK发送方未能识别，重新发送一个ACK
由于这是只发送一个等待确认的协议，所以我们只需要一位来作为序号就可以了，1和0区分出老的和新的
事实上receiver并不知道发出去的确认是否被收到，因为没有一个确认的确认，如果安排一个确认的确认，那要不要有一个确认的确认的确认是一个问题；所以这里采取的措施就是上面讲的这种方式，通过收到的分组的序号，来区分发出去的确认有没有问题
### Rdt 2.2: 无NAK的协议
NAK free -- 没有NAK，只有ACK，对ACK编号
这里主要的思路是这样的：现在是停止等待的协议，发送一个等待一个回复，如果想变成流水线的协议，就需要对ACK和NAK编号，但是这样同时有ACK和NAK比较多比较麻烦，这样就用ACK0对等NAK1，换句话说，如果我在等1的确认，如果传过来错了，就给一个0的ACK就好了
![Pasted image 20251224162706.png|400](/img/user/accessory/Pasted%20image%2020251224162706.png)

![Pasted image 20251224163205.png|500](/img/user/accessory/Pasted%20image%2020251224163205.png)

![Pasted image 20251224163245.png|350](/img/user/accessory/Pasted%20image%2020251224163245.png)

### Rdt 3.0: 具有比特差错和分组丢失的信道
新的假设：分组在传输过程中丢失了
为什么会出现丢失的情况？
路由器有queue队列，来的分组需要排到队列再传，如果队列是满的话，就会丢掉(drop)
假设packet1丢失了，如果没有采取任何措施的话，sender收不到回复，receiver收不到packet1，就会形成死锁
采取的机制：超时重传机制 具体来说就是发出分组之后启动一个超时定时器，超时定时器所定义的超时的时间是正常往返还多一点的时间，如果正常往返还多一点的时间回复还没来（可能是packet丢了，也可能是回来的ACK丢了），sender就可以在把刚刚发的分组再发一遍
如果是回来的ACK丢了的话，实际上就是带来了重复，但是重复并不是一个问题，或者说前面我们已经解决过了
超时时间设置成多少合适？
如果两个主机中间连了一个很大的网络，经历了很多路由器，往返延迟就比较不固定，跟概率论上所学的知识有一定关系，会呈现一种分布，这时候有一个适应性时间，适应性的去算延迟时间
![Pasted image 20251224182706.png|200](/img/user/accessory/Pasted%20image%2020251224182706.png)
如果在数据链路层中，虽然时间也有分布，但很多的时间分布会比较集中，所以可能会设置成一个固定的时间
![Pasted image 20251224184427.png|400](/img/user/accessory/Pasted%20image%2020251224184427.png)
不过这里有一点的区别
![Pasted image 20251224185210.png|200](/img/user/accessory/Pasted%20image%2020251224185210.png)
当Packet1出现问题的时候，Receiver会回一个ACK0，按前面学的来说的话，应该Sender立即重发一个Packet1，但是这里也可以改成，Sender1不动，等待接受ACK1超时，然后重放Packet1，效果是一样的，但不能两个机制都有，保留等待的这一个
![Pasted image 20251224184444.png|400](/img/user/accessory/Pasted%20image%2020251224184444.png)

![Pasted image 20251224184514.png|400](/img/user/accessory/Pasted%20image%2020251224184514.png)
注意这里有一种比较奇葩的情况，收到了但耗费的时间比超时时间长，就会出现上图d中的情况
->超时计时器设置很重要，如果设置不好，虽然可以正常工作，但效率是正常效率的百分之五十甚至是更低