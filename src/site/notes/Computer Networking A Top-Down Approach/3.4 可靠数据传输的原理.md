---
{"created":"2025-12-01T20:25","updated":"2025-12-23T11:04","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/3.4 可靠数据传输的原理/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
3.4主要讲RDT(reliable data transform，可靠数据传输)的原理
![Pasted image 20251222201540.png|500](/img/user/accessory/Pasted%20image%2020251222201540.png)
在这里学是因为常见的传输层的TCP实现了可靠数据传输，但其实在某些网络的数据链路层，某些网络的网络层也会实现RDT，这是网络Top3问题之一
这里讲的是一般化的可靠数据传输原理，上层的用户称之为应用层的Process，图中有一个sending process, receiver process，可靠数据传输要实现的就是sending process传下来的数据是什么样的，传到receiver process的数据就应该是什么样的，具体来说就是，不出错！不重复！不失序！不丢失！
下层的服务是UDT(不可靠数据传输)的，在本层要封装上一些东西，在图中是一个抽象的说法，封装成一个packet，（实际上在TCP上是封装成一个segment(报文段)），封装成packet之后，借助下层所提供的服务，调用一个原语（在图中是udt_send()), 把数据发走；对方通过原语收到之后，可能是乱序的，通过一定的措施，不管怎么样，会像上层交付一个原原本本的data
![Pasted image 20251222204130.png|500](/img/user/accessory/Pasted%20image%2020251222204130.png)
面临的问题简单来说就是：在下层所提供的服务是不可靠的情况下，本层协议实体要靠哪些资源机制的安排，为上层提供可靠的服务
这里的学习的方式是假设下面的channel是reliable的，不出错不丢失不乱序... 然后将这些假设一个个去掉，每去掉一个假设就需要增加一些机制
这里注意，数据的传输是双向的，但我们能把双向看做两个单向，所以这里只需要讲明白Sending发往Receiver就可以了，但是要注意里面可能会用到一些数据的反馈，Receiver给Sending的反馈 -- 换句话说，虽然只考虑单向数据传输，但是控制信息是双向的！
除此之外，我们使用有限状态机（FSM）来描述发送方和接收方，其实就是状态迁移的过程，就像我们在jyy操作系统课上学的C语言的状态机，操作系统的状态机一样
![Pasted image 20251222205947.png|500](/img/user/accessory/Pasted%20image%2020251222205947.png)

### Rdt 1.0: 在可靠信道上的可靠数据传输
假设不出错 不丢失
![Pasted image 20251223093608.png|400](/img/user/accessory/Pasted%20image%2020251223093608.png)
发送方接受数据，封装成packet，打走
接收方从下层接受packet，解封装，交给上层

### Rdt 2.0: 具有比特差错的信道
假设在传的过程中可能会出错，将分组中的比特翻转
![Pasted image 20251223094207.png|400](/img/user/accessory/Pasted%20image%2020251223094207.png)
这个时候EDC校验和就起作用了
发送方sending传送packet给接收方receiver，接收方可以校验有没有出错，如果没有出错，返回一个ACK(acknowledgment，确认应答)，这时候发送方可以发送下一个packet；如果检测发现出错了，返回一个NAK(Negative Acknowledgment)，发送方会重传
这种一次只发送一个等待确认的这种分组，称作stop and wait协议(停止等待协议)
所以这里的机制有：发送方做差错控制编码；接收方做差错控制解码；发送方发完之后要留副本；接收方要给反馈；发送方要能够识别反馈做出不同的动作
![Pasted image 20251223094830.png|400](/img/user/accessory/Pasted%20image%2020251223094830.png)
Rdt2.0 有一个致命的缺陷：ACK和NAK也可能出错！！
### Rdt 2.1:  处理出错的ACK/NAK
新的机制：序号 sequence number
整体思想就是如果发送方接收到一个不知道ACK还是NAK的消息，不管三七二十一，再传一遍刚刚传的$P_0$，由于引入了序号的机制，接收方能够识别你是否又给我发了一遍$P_0$,如果是，就知道我上次发送的ACK或者NAK出错了，然后再给出应答
![Pasted image 20251223095927.png|150](/img/user/accessory/Pasted%20image%2020251223095927.png)
发送方处理出错的ACK/NAK
![Pasted image 20251223100444.png|500](/img/user/accessory/Pasted%20image%2020251223100444.png)
接收方处理出错的ACK/NAK
![Pasted image 20251223101159.png|500](/img/user/accessory/Pasted%20image%2020251223101159.png)
具体来说整个过程：
发送方在收到上层发下来的数据后，封装成packet0（包括了差错控制编码），并且打出去，等待接收方来自packet0的反馈信息，ACK0或NAK0
如果收到正常的NAK或者收到不知道是什么的信息(corrupt(rcvpkt)),重新发送packet0，继续等待反馈信息
如果收到正常的ACK，就等待上层发下来新的数据，封装成packet1并打出去
接收方在收到packet后，假设接收方在等到序号0的分组，如果序号正确，校验正确，就可以解封装拿到data传给上层，并且给发送方一个ACK的反馈（ACK也要checksum），转为等待需要1的分组的状态
如果来了1当然好，但是如果来了一个没有出错的0号的分组序号，这代表接收方第一次发送的ACK发送方未能识别，重新发送一个ACK
由于这是只发送一个等待确认的协议，所以我们只需要一位来作为序号就可以了，1和0区分出老的和新的
### Rdt 2.2: 无NAK的协议


### Rdt 3.0: 具有比特差错和分组丢失的信道