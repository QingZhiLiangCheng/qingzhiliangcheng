---
{"created":"2025-12-04T16:22","updated":"2025-12-04T19:46","dg-publish":true,"permalink":"/Computer Networking A Top-Down Approach/2.6 TCP 套接字编程 & UDP套接字编程/","dgPassFrontmatter":true,"noteIcon":""}
---

### Socket编程
怎么样将报文Message传送给远端的应用？对方怎么样按照协议规范返回一个报文？
报文的传输逻辑上是一个应用进程与另一个远端的应用进程的传输
但是实际上要通过层间接口，交给下层，借助于下层所提供的通讯和服务来实现的，换句话说，应用进程要远程的传输报文，需要依赖于传输层所提供的服务(这个服务包括网络层的服务，比如TCP就是对网络层的服务增强了) -- TCP-IP协议栈提供的是一种socket api的服务 -- 就是应用进程调用一系列的socket api(应用进程接口)来创建socket，使用socket，关闭socket
什么地方 -- 层间接口上
什么形式 -- socket api的形式
socket就像一个门一样，这边应用层通过socket往下交，对面的socket通过socket往上收
应用进程是不用考虑报文怎么传的，只要借助于socket api，建立socket，使用socket传收，最后关掉就完了，至于socket怎么传报文的，是下层传输层的事儿

2中传输层服务的socket类型：TCP，UDP
TCP提供可靠的，连接的服务，但值得注意的是，TCP是一个字节流的服务，所谓的字节流的服务是说只保证按照流来说是对的，不保证报文的界限 -- 需要应用层自己来区分报文之间的界限
UDP提供的不可靠，无连接的服务

### TCP套接字编程
Socket前面的例子学过，就是一个整数，一个句柄，在[[Computer Networking A Top-Down Approach/2.1 应用层协议原理\|2.1 应用层协议原理]]提到过，它其实就像 对文件描述符操作就像对文件从操作 一样， 对socket这个整数操作，就相当于对会话上的两个应用进程的操作
TCP的socket代表的是一个四元组(源IP，源Port，目标IP，目标Port)，代表的就是两个进程之间的一个连接关系
整个过程是这样的：
服务器首先运行，等待并建立连接，会首先建立一个socket，操作系统会返回一个整数，即在socket表中建立一个socket表项，这个socket会和（本地IP, 本地端口）相捆绑，叫welcome socket，然后调用accept函数，等待来自远端进程建立会话关系建立TCP连接，这个函数是阻塞的，一直在等
客户端也会建立一个socket，操作系统返回一个整数，注意这个整数是本地的操作系统返回的，不见得和服务器那边的那个socket的值是一样的。同样这个socekt也会和客户端的本机的IP和端口捆绑，然后对这个socket调用一个函数叫connect，然后这个函数也阻塞。
在客户端这边，服务器建立请求的报文传回来的时候，解除阻塞，socket api返回一个有效值，这个时候连接就会建立起来。
在服务器这边，如果来了一个连接建立请求，它的TCP一方面会同意建立连接请求，这个时候客户端那边会收到一个请求同意，解除阻塞。另外一方面welcome socket解除阻塞，返回一个新的socket值，这个socket叫connection socket，这个connection socket就是一个四元组(源IP，源Port，目标IP，目标Port)
这个时候连接就建立起来了，这个时候可以进行收和发，完成之后会关掉socket，关掉连接，welcome socket仍然守候着

两个重要的结构体
```cpp
struct sockaddr_in{ 
	short sin_family; //AF_INET 
	u_short sin_port; // port 
	struct in_addr sin_addr; // IP address, unsigned long 
	char sin_zero[8]; // align  对齐
};
// ----------------------------------------------
struct hostent { 
	char *h_name; 
	char **h_aliases; 
	int h_addrtype;
	int h_length; /*地址长度*/ 
	char **h_addr_list; 
	//defineh_addrh_addr_list[0];
};
```

![Pasted image 20251204172240.png|300](/img/user/accessory/Pasted%20image%2020251204172240.png)

![Pasted image 20251204172201.png|300](/img/user/accessory/Pasted%20image%2020251204172201.png)
后面这个结构体的主要作用就是一个域名解析的作用，给一个域名，在最后的列表中找到一个IP地址，copy到第一个结构体的IP地址的位置
第一个结构体的作用就是放IP放端口，代表的是应用进程本地的端节点

整个过程：
假设Server的IP是1.1.1.1，端口号是80端口
客户端的IP是2.2.2.2 端口号是777端口
第一步是Server先建立Welcome Socket，socket函数中填入的是什么类型的Socket，比如是TCP的还是UDP的；操作系统会返回一个整数，比如这里是23，这个时候还没有绑定本地的IP和本地的端口
![Pasted image 20251204191519.png](/img/user/accessory/Pasted%20image%2020251204191519.png)
第二步会调用一个bind函数来绑定本机的IP和端口，传进去的第一个参数是socket的参数，第二个参数就是上面介绍过的第一个结构体
![Pasted image 20251204191647.png](/img/user/accessory/Pasted%20image%2020251204191647.png)
第三步服务器调用accept这个Socket API，等待来自远端进程建立会话关系建立TCP连接
![Pasted image 20251204191855.png](/img/user/accessory/Pasted%20image%2020251204191855.png)

客户端想要建立连接的时候，会在本地创建一个socket；值得注意的是，在客户端中可能不需要像在服务器中那样显式的绑定端节点，这是以为服务器需要等待对方来请求，所以要指明在哪个端口等，而在客户端中，一般操作系统会隐式的帮我们把本机IP和Port绑定进去，在这里的例子返回了一个22的socket，注意这时候这个socket的状态还是无效的一个状态
![Pasted image 20251204192216.png](/img/user/accessory/Pasted%20image%2020251204192216.png)
然后客户端会调用connect方法，传入自己的socket和服务器的端节点结构体，这里在客户端本地的表中就填好了socket的表项，但是仍然是无效的状态。
同时客户端会像Server发送链接请求
![Pasted image 20251204192744.png](/img/user/accessory/Pasted%20image%2020251204192744.png)
服务器正在阻塞中的accept函数会接收到来自client的端节点的结构体，返回正确的新的connectionSocket
同时给客户端返回建立请求的确认
![Pasted image 20251204193319.png](/img/user/accessory/Pasted%20image%2020251204193319.png)
客户端正在阻塞的connect函数收到后会返回一个有效的标志，将本地的这个socket状态改为有效
![Pasted image 20251204193459.png](/img/user/accessory/Pasted%20image%2020251204193459.png)
然后双方就可以进行相互接受，最后关闭socket，welcome socket重新回到等待的状态
![Pasted image 20251204194649.png](/img/user/accessory/Pasted%20image%2020251204194649.png)
到底怎么借助socket传输的，怎么对应起来两个socket，是TCP的事儿
也可以变成一个多进程的一个服务，当建立连接后创建一个新的进程去执行socket的发和收，然后让welcome socket继续等待接受请求
