---
{"dg-publish":true,"permalink":"/LCU principles of computer composition/中断系统/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-11-28T11:11:16.529+08:00","updated":"2025-03-30T15:08:12.665+08:00"}
---


### 概述
引发中断的因素
	人为设置的中断
	程序性事故
	硬件故障
	IO设备
	外部事件

中断系统需解决的问题
- 各中断源如何向CPU提出请求？
- 各中断源同时提出请求怎么办？
- CPU什么条件、什么时间、以什么方式响应中断？
- 如何保护现场？
- 如何寻找入口地址？
- 如何恢复现场，如何返回？
- 处理中断的过程中又出现新的中断怎么办？

### 中断请求标记和中断判优逻辑
如何提出中断请求的问题
中断请求标记  INTR 每一个中断源都有一个INTR中断请求标记触发器
逻辑上形成了中断请求标记寄存器
![Pasted image 20241216100917.png|400](/img/user/accessory/Pasted%20image%2020241216100917.png)

注意是逻辑上，事实上INTR是分散在各个中断源的接口电路中的或者集中在CPU中断系统内

多个中断源提出中断请求怎么办的问题：
显然是响应那个对系统影响最大的，最严重的，或者说是最重要的
就用到中断判优逻辑：
硬件实现：排队器  前面讲到过
	1. 分散在各个中断源的接口电路中----链式排队器，见[[LCU principles of computer composition/程序中断方式\|程序中断方式]]
	2. 集中在CPU内的
		![Pasted image 20241216101600.png|400](/img/user/accessory/Pasted%20image%2020241216101600.png)
		其实就是前面的限制后面的，最终的输出只有一个为1
软件实现：程序查询 [[LCU principles of computer composition/程序查询方式\|程序查询方式]]
	![Pasted image 20241216101754.png|300](/img/user/accessory/Pasted%20image%2020241216101754.png)

### 中断服务程序入口地址的寻找
如何找到中断服务程序的入口地址的问题
1. 硬件向量法  在[[LCU principles of computer composition/程序中断方式\|程序中断方式]]中就用到的这种方式
	排队器的输出只有一位为1 代表着哪一个中断源要响应  生成中断向量地址去找中断服务程序的入口地址
	中断服务程序的入口地址有两种办法给出
		1. 中断向量地址的那个存储单元中存放一条跳转指令
		2. 中断向量地址的那个存储单元中存放的直接就是入口地址
	![Pasted image 20241216102418.png|400](/img/user/accessory/Pasted%20image%2020241216102418.png)
2. 软件查询法
	通过中断识别程序查询中断源的触发器D（完成触发器）是否为1，如果为1 就转到1#的程序，如果为0 就跳过下一条指令  进入下一个中断源的检测
	![Pasted image 20241216103338.png|400](/img/user/accessory/Pasted%20image%2020241216103338.png)
### 中断响应
解决cpu在什么时间、什么条件下响应中断？
1. 响应中断的条件
	允许中断触发器 EINT=1
2. 响应中断的时间
	指令执行阶段结束以后由CPU发出查询信号 ，与中断源同时作用 连接到排队器
	![Pasted image 20241216104307.png|300](/img/user/accessory/Pasted%20image%2020241216104307.png)
3. 中断隐指令
	保护程序断点
		断点保存于特定地址（0号地址）内
		或者断点进栈
	寻找服务程序入口地址
	硬件关中断
		将中断允许触发器的值置为1
	![Pasted image 20241216105223.png|400](/img/user/accessory/Pasted%20image%2020241216105223.png)
	INT---- 中断标记
	EINT-----允许中断
	R-S ----- 触发器
	关中断后EINT输出为1  然后与排队器一起作用到中断标记上 既有中断源请求又允许中断，那么INT会变为1  反作用与EINT 使得中断允许变为0   任何都不能打断
	同时排队器的结果还会给向量地址形成部件

	所谓隐指令是说这三个操作都是由计算机的硬件完成的，而不是在一条具体指令驱动下完成的

### 保存现场和恢复现场
保护现场：
- 保存断点  -----   中断隐指令
- 保存寄存器内容 ------ 中断服务程序
恢复现场  ------ 中断服务程序

中断服务程序的步骤：
- 保护现场    ------ PUSH
- 其他服务程序
- 恢复现场  ------ POP
- 中断返回  ------ IRET

### 多重中断
如果在执行中断服务程序的过程中，出现了更重要的，需要及时处理的新事件，该怎么办？
多重中断就是指当执行过程中有更高优先级的中断请求 当前的中断服务要被打断，去执行新的中断服务请求
![Pasted image 20241216152651.png|300](/img/user/accessory/Pasted%20image%2020241216152651.png)
实现多重中断的条件
EINT要提前被打开---- 提前设置开中断指令
![Pasted image 20241216153113.png|400](/img/user/accessory/Pasted%20image%2020241216153113.png)

中断屏蔽技术
屏蔽触发器
![Pasted image 20241216153341.png|200](/img/user/accessory/Pasted%20image%2020241216153341.png)
排队器中的应用
![Pasted image 20241216153442.png|300](/img/user/accessory/Pasted%20image%2020241216153442.png)
其实是使一个中断源无法向CPU提出中断服务请求，也不能参加中断优先级排队器的排队

屏蔽字
![Pasted image 20241216153916.png|300](/img/user/accessory/Pasted%20image%2020241216153916.png)
如果1号中断服务在执行，从1号到16号中断源提出的中断服务请求都被屏蔽了，都没法进入到中断排队器当中进行排队

屏蔽技术改变的是处理优先级：响应优先级是硬件电路决定的 ----- 不可改变    处理优先级----可以通过重新设置屏蔽器，让高优先级的中断不能进入到中断排队器当中去排队
![Pasted image 20241216154448.png|300](/img/user/accessory/Pasted%20image%2020241216154448.png)
响应优先级：A->B->C->D
处理优先级：A->D->C->B

![Pasted image 20241216155309.png|300](/img/user/accessory/Pasted%20image%2020241216155309.png)
![Pasted image 20241216155401.png|300](/img/user/accessory/Pasted%20image%2020241216155401.png)
在执行完A后，中断屏蔽字又变成了主程序的屏蔽字，四个都是0
bcd都进入到中断排队器进行排队，由于响应优先级是abcd  所以先响应b 中断屏蔽字置为0100，在执行b的过程中 c和d还是会提出中断服务请求并且这个中断服务请求能够进入到中断排队器中进行排队  响应c  ………… 响应d


人为设置屏蔽字 屏蔽某个中断源的请求
![Pasted image 20241216160032.png|200](/img/user/accessory/Pasted%20image%2020241216160032.png)

多重中断的断点保护
之前说断点保护的两种方式
- 进栈
- 断点存入特定地址
	![Pasted image 20241216160352.png|300](/img/user/accessory/Pasted%20image%2020241216160352.png)
	都存入同一个特定地址，会造成至少两个断点的信息丢失
解决办法：
	 内容转存
	 ![Pasted image 20241216160737.png|400](/img/user/accessory/Pasted%20image%2020241216160737.png)
