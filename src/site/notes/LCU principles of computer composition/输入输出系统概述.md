---
{"dg-publish":true,"tags":["LCU机组"],"permalink":"/LCU principles of computer composition/输入输出系统概述/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-11-15T10:03:45.675+08:00","updated":"2025-04-19T09:58:07.653+08:00"}
---


### 输入输出系统发展概述
- 早期
	分散连接
	CPU和IO设备 串行 
	程序查询方式
- 接口模块和DMA阶段
	IO接口和DMA与CPU相互配合，完成输入输出功能
	总线连接
	CPU和IO设备 并行 工作
	两种信息交换的传输
		中断方式
		DMA方式
- 具有通道结构的阶段
	通道可以看做是小型的处理器或者是小型的功能更强的DMA控制器
	通道有自己的指令系统 通过执行程序  控制IO设备直接与主机进行信息传输
- IO处理机阶段

### IO系统的组成
#### IO软件
- IO指令
	CPU指令的一部分
	格式： 操作码  命令码   设备码
		操作码相当于IO指令的一种标识
		命令码就相当于普通指令的一个操作码：指明了要对IO设备做什么操作
		设备码：IO设备的编码：IO设备的地址或者是其中的某个寄存器（IO端口）
- 通道指令
	通道自身的指令
	编程人员在编写程序的时候  比如在应用程序中需要调用IO设备
	需要增加广义IO指令
		包括参加数据传输的IO设备
		数据传输主存的首地址
		传输数据的长度
		传输方向
	操作系统根据广义IO指令给出的参数以及要求的操作 会编写一个有通道指令组成的通道程序，并且把通道程序放到内存或者是通道自己内存的指定位置之后，启动通道进行工作
#### IO硬件
- 设备 IO接口
- 设备 设备控制器 子通道 通道

### IO设备与主机的联系方式
#### IO设备编址方式
1. 统一编址
	把IO地址看作是内存地址的一部分
	比如说内存地址是1兆
	比如说我们把这1M 低地址部分或者是高地址部分拿出64k  作为IO设备或者端口的地址
	如果输入输出指令或访存指令地址码部分的地址落入到了io地址部分
	那这次读写操作是针对io设备进行的

	这就是说在这种情况下，我们使用的是取数和存数指令
	我们不需要单独的IO指令
	只要取数或者读数指令落入到了IO地址部分就可以
2. 不统一编址  单独编址
	专门设置一个地址空间
	有专门的IO指令
#### 设备选址
设备选择电路识别是否被选中
#### 传送方式
1. 串行
2. 并行
#### 联络方式
外部设备接收或者发送数据的响应情况
1. 立即响应
2. 异步工作采用应答信号
	1. 并行情况
		主要是IO接口和IO设备之间采用的
		IO设备和IO接口之间有多条类似总线的数据线来完成数据并行的输入和输出
		双方之间存在应答信号
		端口准备好后会告诉IO设备我已经准备好了
		![Pasted image 20241115160923.png](/img/user/accessory/Pasted%20image%2020241115160923.png)
	2. 串行情况
		先给出一位低电平  然后是数据字  然后是 两位的高电平为终止位
		![Pasted image 20241115161308.png](/img/user/accessory/Pasted%20image%2020241115161308.png)
	3. 同步工作采用同步时标
		设备和主机之间要同步工作的话，两者之间需要有一个定宽定距的时标 
		所谓的时标就是来控制某一个时间点必须开始某一项工作 在某个时间点某个工作必须结束

### IO设备与主机信息传送的控制方式
1. 程序查询方式
	CPU 和 外设采取串行方式工作
	![Pasted image 20241115163336.png|300](/img/user/accessory/Pasted%20image%2020241115163336.png)
	![Pasted image 20241115163552.png|300](/img/user/accessory/Pasted%20image%2020241115163552.png)
	简单来说就是CPU从准备的时候就开始等
2. 程序中断方式
	CPU实现了部分并行工作
	换句话说就是IO设备在准备数据的时候，CPU还可以执行自己的程序
	![Pasted image 20241115164108.png|300](/img/user/accessory/Pasted%20image%2020241115164108.png)
	![Pasted image 20241115164355.png|300](/img/user/accessory/Pasted%20image%2020241115164355.png)
	我们发现在CPU启动了IO设备之后，还在继续执行后面的程序
	知道第k行开始 暂停执行 并保存了程序现场
	转而执行中断服务程序
	执行完调回来（具体的过程在CSAPP后面应该也会学到的叭）
	可是问题是：
		并没有完全将CPU解放出来
		如果只传递一丢丢的字符  CPU可能要用十几条指令来保存这个代码现场
	![Pasted image 20241115170240.png|400](/img/user/accessory/Pasted%20image%2020241115170240.png)
3.  DMA方式
	外部设备和内存建立直接的连接
	CPU进一步解放
	采用的方式：周期窃取 周期挪用
	![Pasted image 20241117135208.png](/img/user/accessory/Pasted%20image%2020241117135208.png)
	事实上，如果DAM想要利用数据线 控制线 地址线这些总线来传输数据 那么势必就会占用总线 这个存取周期就都交给DMA进行调用
	如图所示，整个过程是这样的
		CPU执行现有程序
		发出启动IO设备的指令，然后CPU和DMA并行运行，DMA完成数据的准备
		然后DMA发出DAM请求 占用总线的使用权，占用一个存取周期
		存取周期实现IO设备与内存之间数据的交换
		周期结束后 对内存的使用权又归还给了CPU
	值得注意的是并不是说这个存取周期CPU就不工作了，其实在现代计算机中，一般我们会预取若干条指令到cpu指令缓冲当中。