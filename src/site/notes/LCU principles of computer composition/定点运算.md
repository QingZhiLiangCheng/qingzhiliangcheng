---
{"dg-publish":true,"tags":["LCU机组"],"permalink":"/LCU principles of computer composition/定点运算/","dgPassFrontmatter":true,"noteIcon":"","created":"2025-08-15T09:39:29.339+08:00","updated":"2025-04-19T09:57:38.858+08:00"}
---


csapp中其实介绍过移位运算和加减法和乘法的运算[[CSAPP Computer-System-A-Program-Perspective/Integer Arithmetic\|Integer Arithmetic]] 但是只是介绍了整数的，在机组中，会介绍移位运算和整数和浮点数的加减法和乘法   除此之外还会介绍除法
在机组中的总体介绍思路就是先介绍运算方法和溢出的判断  然后介绍硬件配置
### 移位运算
由于CSAPP介绍过符号位的移位规则 这里就不在赘述
![Pasted image 20241130115705.png|400](/img/user/accessory/Pasted%20image%2020241130115705.png)
#### 算术移位的硬件实现
真值为正的左移操作：
![Pasted image 20241130124312.png|200](/img/user/accessory/Pasted%20image%2020241130124312.png)
真值为正的右移操作：由于符号位是0 所以是自我复制后右移   符号位就移过去了但是复制了一个
![Pasted image 20241130124412.png|200](/img/user/accessory/Pasted%20image%2020241130124412.png)
负数原码的左移和右移：
![Pasted image 20241130124454.png|200](/img/user/accessory/Pasted%20image%2020241130124454.png)
负数的补码左移和右移：
![Pasted image 20241130124631.png|200](/img/user/accessory/Pasted%20image%2020241130124631.png)
负数的反码的左移和右移：
![Pasted image 20241130124715.png|200](/img/user/accessory/Pasted%20image%2020241130124715.png)

### 加减法运算
之前介绍过原码加减法的问题，所以引入了补码来找到了一个与负数等价的一个正数。
加法运算公式
整数 $[A]_补 + [b]_补 =[A+B]_补 （mod 2^{n+1})$
小数 $[A]_补 + [b]_补 =[A+B]_补 （mod 2)$
减法
$A-B=A+(-B)$
值得注意的是，对于补码的运算，连同符号位一起相加，符号位产生的进位自然丢掉
eg：设A=0.1011,B=-0.0101 求$[A+B]_补$
	$[A]_{补}=0.1011$
	$[B]_补 = 1.1011$
	$[A+B]_补 = 10.0110  mod 2 =0.0110$
eg: 设A=-9 B=-5 求$[A+B]_补$
	真值：A=- (8 + 1)    ----    -1001
	真值：B=-(4+1)   ----- -0101
	$[A]_补= 10111$
	$[B]_补 = 11011$
	$[A+B]_补 = 110010 mod = 10010$
eg：设机器字长为8位（含1位符号位）且A=15 B=24 用补码求A-B
	别记错了啊  正数的源码补码反码都一样啊 只有负数才会用那个取反的方法啊 
	A= 15 = 8 + 4 + 2 + 1 =0,0001111
	-B=-24 =-(16+8)= 1,0011000
	$[A]_补 = 0,0001111$
	$[B]_补=1,1101000$
	$[A-B]_补= 1,1110111 mod =1,1110111$
	A-B=1,0001001 = -9
eg: 设 x = $\frac{9}{16}$ y=$\frac{11}{16}$  用补码求x+y
	注意分数怎么表示成补码啊
	x=$\frac{2^3+2^0}{2^4}=2^{-1}+2^{-4}=+0.1001$
	$[x]=0.1001$
	$y=\frac{2^3+2^1+1}{2^4}=2^{-1}+2^{-3}+2^{-4}=+0.1011$
	$[y]=0.1011$
	$[x]+[y]= 1.0100$
	x+y= 1.1100=-0.1100=$-(2^{-1}+2^{-2})$=$\frac{12}{16}$
#### 溢出判断
##### 一位符号位判溢出
如果参加操作的两个数符号相同，结果的符号与原来操作数的符号不同，即为溢出
硬件实现：
最高有效位的进位  和 符号位的进位  ⊕ =1  说明出错  ⊕的特点就是如果两个相应位不同，结果为1
比如说两个数都是正数相加  假设数值为7位  加符号位为1
如果说第七位算出来要往第八位进位   就进到了符号位   但是由于 符号位原来就是两个0 不会往上进位了
也就是说最高有效位的进位是1  符号位的进位是0    -------   溢出
如果是两个负数的时候，由于两个符号位都是1 进位为1  符号位进位为1  如果最高有效进位为0算溢出

其实我有一个问题 我以为比如说1100 和1100  这样 变成11000的过程也算是  溢出  但其实 最后的结果1000是正确的  不算是溢出  也就是说最高有效位进1的过程竟然是正确的

##### 两位符号位溢出
我们看到一位符号位最致命的缺点就是没有判断是发生了正溢出还是负溢出  所以引入了两位符号位判断溢出
第一位实际上是真正的符号位  第二位实际上是溢出的部分
结果的双符号位相同  未溢出
结果的双符号位不同  溢出   10----负溢出   01-----正溢出
- 01： 符号位00+00 不进位  数值首位进位
- 10： 符号位11+11 进位，数值首位不进位
实际上还是一位符号位判断的那个规则
### 补码加减法的硬件配置
![Pasted image 20241130134535.png|300](/img/user/accessory/Pasted%20image%2020241130134535.png)
核心：n+1位的加法器
另外有两个寄存器   上面一个是ACC   表示的被加数
下面一个就是那个X  一般表示加数或者是被减数
另外两个标志 如果加法 GA置为1   如果减法 GS置为1
由于减法需要做一个从B的补码变为-B补码的这样一个过程  所以还有求补的控制逻辑 
只是取反啊 还得+1 
事实上计算机中是采用的 进位的一个操作
加法器有三个输入的   两个是要操作的数，，，另一个是送上来的进位
最低位就将进位上来的置为1
溢出判断将V置为1了  
[[CSAPP Computer-System-A-Program-Perspective/Instructions and Condition Codes\|Instructions and Condition Codes]]当时在CSAPP中讲了一个Flag的那个 叫condition code  里面就有溢出的比较我记得 这里就联系起来了

### 乘法运算
#### 笔算和笔算的改进
![Pasted image 20241130191834.png|200](/img/user/accessory/Pasted%20image%2020241130191834.png)
- 符号位单独处理
- 乘数的某一位决定是否加被乘数】
- 4个位积一起相加    ---   存在左移哈
- 乘积的位数扩大一倍

 对于第一点  符号位单独处理 用一个异或电路就能够解决
- 如果 xxx 是负数，则它的符号位是 `1`，与掩码 `0x80000000` 进行 **异或** 后，得到的结果会有符号位为 `1`。
- 如果 xxx 是正数或零，则符号位是 `0`，与掩码 `0x80000000` 进行 **异或** 后，结果符号位为 `0`。
有关掩码的信息 详见CSAPP[[CSAPP Computer-System-A-Program-Perspective/Information Storage\|Information Storage]]里面起到了异或和掩码的知识

对于第二点，可以把第二个数放到一个寄存器然后进行右移   然后只需要判断最后一位就可以

对于第三点  可以采取四个寄存器两个两个加的形式   然后要采取左移和右移的方法

对于第四点  位数扩大一倍  用两个寄存器来保存乘积的值就好了

笔算方法的改进
![Pasted image 20241130193518.png|500](/img/user/accessory/Pasted%20image%2020241130193518.png)
我们发现这么处理之后   我们发现很有规律 
我们是从0开始看的
被乘数A+0  ----   右移一位得到新的部分积   -----   看一下下一位如果是1 在加A ----- 再右移

A为被乘数  B为乘数   A=0.1101  B=0.1011
在计算完0.0000+0.1101后得到0.1101  右移一位 变为0.0110  最右边这一位1会把B的1011往右顶一下，变为1 101  然后判断最低位是0还是1决定+A还是+0

<font color="#4bacc6">被乘数放在X寄存器 乘数放在了乘商寄存器中  乘法累加值的高位放在了ACC中，低位被移到了MQ寄存器  MQ所保存的乘数在不断被顶着右移</font>
被乘数只是和部分积的最高位相加，其实就是我们笔算是给下面的数左移  在这里是不断第一个数右移
3个寄存器  2个具有移位功能
1个全加器  n+1位

#### 原码乘法
##### 原码一位乘
![Pasted image 20241201085504.png|300](/img/user/accessory/Pasted%20image%2020241201085504.png)
![Pasted image 20241201085828.png|300](/img/user/accessory/Pasted%20image%2020241201085828.png)

eg: x=-0.1110 y=0.1101  求$[x · y]$
	符号位单独处理    负号
	0.1110 * 0.1101
	0.0000+01110=0.1110  -》 0.0111  ----   0110
	0.0111+0=0.0111  -》 0.0011   ---- 1011
	0.0011+0.1110 =1.0001 -》    0.1000  ---- 1101
	0.1000+0.1110=1.0110  -》 0.1011  ---- 0110
	=》0.1011 0110
	=》1.1011 0110
##### 原码一位乘的硬件配置
![Pasted image 20241201090649.png|300](/img/user/accessory/Pasted%20image%2020241201090649.png)
X放着被乘数     A是n+1 位  但是前面的例子也说明了 不是符号位  而是会有进位
随着计算低位移入Q 把Q中最低位顶出来  判断是否要加上X里的被乘数
计数器C记录的是

对于除法运算 考试不考  等寒假我再来补充