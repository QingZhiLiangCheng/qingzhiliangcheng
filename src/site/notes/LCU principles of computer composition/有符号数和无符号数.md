---
{"dg-publish":true,"tags":["LCU机组"],"permalink":"/LCU principles of computer composition/有符号数和无符号数/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-11-28T08:56:16.869+08:00","updated":"2025-04-19T09:58:32.416+08:00"}
---


其实对于有符号数和无符号数在[[CSAPP Computer-System-A-Program-Perspective/Integer Representations\|Integer Representations]]中就有过涉及。
但是机组中还有移码 反码的介绍   在CSAPP中我是着重研究的补码  而且我研究的是integer   不懂小数的原码表示等，因为当时学的时候直接学了IEEE  其实IEEE机组后面也会讲
而且后面还会介绍加减乘除 CSAPP介绍的没有那么全面
而作为机组的课程，在了解完这些性质后，在讲实现
### 无符号数
就是CSAPP中讲的unsigned
范围与寄存器的位数有关  计算的方法  也和CSAPP中学到的一样
这里没啥说的
### 有符号数
数值部分   和  符号部分
#### 机器数与真值
其实之前好像不太知道机器数和真值这两个叫法
- 机器数就是符号数字化的数  就是存储在计算机中的值  我们可能用二进制表示 更多的可能用16进制表示
- 真值就是带符号的真实的值 用0和1表示
这里值得提出的是，没有表示小数点的符号，计算机中的小数点，都是以约定的方式给出的
#### 原码表示法
 ![Pasted image 20241128091141.png|300](/img/user/accessory/Pasted%20image%2020241128091141.png)
 正数第一位为0    负数为1   如果是n位的话  加上n+1位就相当于给数的绝对值加了2的n次方
 eg:
 x=+1110   $[x]_原=0,1110$
 x=-1110    $[x]原=1,1110$  其实就是加了2的n次方   真值就是减去2的n次方 说白了就是去掉第一个1
注意：用逗号将符号位和数值部分可开

小数的源码表示：
![Pasted image 20241128092047.png|300](/img/user/accessory/Pasted%20image%2020241128092047.png)

小数点前面的那一位作为符号位来表示，用0和1表示  所以说对于负数  相当于加了1
eg:
x=+0.1101  $[x]原=0.1101$
x=-0.1101  $[x]原=1.1101$

原码的特点：简单、直观
运算的时候会出现一些问题：
![Pasted image 20241128092908.png|300](/img/user/accessory/Pasted%20image%2020241128092908.png)
对于运算器来说 有时候做加法  有时候做减法 比较麻烦
我们是想都做加法 操作  换句话说 就是我们希望找到一个与减法等价的正数  来代替负数
这就不得不提补码了！
#### 补码表示法
![Pasted image 20241128093219.png|400](/img/user/accessory/Pasted%20image%2020241128093219.png)
1. 一个负数加上”模“即得到该负数的补数
2. 一个正数和一个负数互为补数的时候，他们的绝对值之和即为模数
而如果一个寄存器是4位的 那么模就是16   大于16 大于的部分会丢弃  有点像时钟了这就
![Pasted image 20241128093756.png|300](/img/user/accessory/Pasted%20image%2020241128093756.png)
正数的补数是自己
![Pasted image 20241128093938.png|300](/img/user/accessory/Pasted%20image%2020241128093938.png)
我们发现负数的补数   -1011的补数也是0101
那这个0101到底是正数的补数 还是 负数的补数
为了区别，加了符号位
0,0101 为 +0101的补数
1,0101 为 -1011的补数
为了实现加上的符号位 实际上我们是加的$2^{4+1}$
![Pasted image 20241128094425.png|300](/img/user/accessory/Pasted%20image%2020241128094425.png)

![Pasted image 20241128094857.png|300](/img/user/accessory/Pasted%20image%2020241128094857.png)

一般负数求补码快捷的有两种办法：
其实原码求补码也是这样的   因为负数的补码 其实就是符号位的差别

1. 方法一：符号位不变，按位取反 +1
2. 方法二：右边第一个1（包含）往后都不变，左边所有的位除了符号位都取反
（当然如果是真值就是加符号位）

补码求真值和原码也是一样的  唯一要注意的就是小数的负数的情况

#### 反码表示法
![Pasted image 20241128101007.png|300](/img/user/accessory/Pasted%20image%2020241128101007.png)
![Pasted image 20241128101039.png|300](/img/user/accessory/Pasted%20image%2020241128101039.png)
![Pasted image 20241128101116.png|300](/img/user/accessory/Pasted%20image%2020241128101116.png)
![Pasted image 20241128101150.png|300](/img/user/accessory/Pasted%20image%2020241128101150.png)
整数不变
负数按位取反
#### 移码表示法
计算机中一般都是用补码表示的  CSAPP中也有学过的
但是补码很难直接判断其真值大小
![Pasted image 20241128101415.png|300](/img/user/accessory/Pasted%20image%2020241128101415.png)
其实就是补码的符号位取反了
只有整数有移码


总结一下做题的步骤就是先写真值
一般我会先列出         16 8 4 2 0  这样子 然后将给的数去拆成这样相加  然后标0和1
然后写原码就很简单 注意符号位就好了   然后注意小数 符号位是小数点前一位
然后补码  反码  移码的方法在上面都介绍了
补码就是 右边第一个1往右的复制，左边的除了符号 都取反
反码就是除了符号位都取反
移码就是补码符号位取反  但是注意小数没有移码