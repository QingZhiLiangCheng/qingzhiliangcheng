---
{"dg-publish":true,"permalink":"/LCU principles of computer composition/程序中断方式/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-11-19T19:15:19.354+08:00","updated":"2025-03-30T15:06:47.917+08:00"}
---


### 中断的概念
![Pasted image 20241119200722.png|400](/img/user/accessory/Pasted%20image%2020241119200722.png)
### 中断的产生
中断源：主机内外 cpu内外 引发CPU发生中断的因素
以打印机为例：
![Pasted image 20241119200835.png|500](/img/user/accessory/Pasted%20image%2020241119200835.png)
### 接口电路
1. 配置中断请求触发器和中断屏蔽触发器
	有时候CPU中运行的程序的重要性比发起中断的程序高 这个时候中断屏蔽触发器就会被屏蔽掉
2. 排队器
	可能同一时刻多个设备发出中断请求 但是各个设备的优先级是不一样的
	高速设备的优先级可能要高一点，因为如果不及时相应 高速设备的数据就会丢失
3. 中断向量地址形成部件
	形成中断程序的入口地址

#### 程序中断方式接口电路的基本组成
![Pasted image 20241119201947.png|300](/img/user/accessory/Pasted%20image%2020241119201947.png)

#### 排队器
排队器分为硬件排队器和软件排队器
硬件排队器就是我们现在要介绍的，在CPU内或在接口电路中的链式排队器
![Pasted image 20241121151846.png|600](/img/user/accessory/Pasted%20image%2020241121151846.png)
在图上越往左电路的优先级越高
每一个接口的电路包括了两个门电路
- 非门
- 与非门
具体来说：
	如果没有中断请求信号，那么所有的$\overline{INTR}$都是1.
	假如说第一个设备有请求，那么$\overline{INTR_1}=0$
	然后经过与非门就变成了1（与非门：只有存在一个0就是1）
	那么后面下一个电路经过一个非门其实网上输出的地方就变成0了 然后变为1 变为0，但是后面所有的往上输出的点都变成了0

如果第一个设备没有中断请求，第二个设备有中断请求
那么电路就是下面这种情况
![Pasted image 20241121153117.png|600](/img/user/accessory/Pasted%20image%2020241121153117.png)
其中黄色的线表示高电平，紫色的线表示低电平
我们发现其实输出的是若干个1 后面跟了若干个0
我们想选的是若干个1最后面的这个1
	课本上采用的方式是将INTR（注意不是$\overline{INTR}$)与INTP输出的结果进行与非
	这样由于$INTR_1$是低电平，那么与非之后变为1
	事实上除了$INTR_2$这一个是两个高电平输出0之外，其余都是输出1
这样我们再取一个非 就把这个该选的信号选出来了

#### 中断向量地址形成部件
在筛选出中断请求的设备之后  下面一个最重要的事情就是如何找出中断程序的入口地址
入口地址的产生有两种
- 软件产生   第八章
- 硬件向量法 
	由硬件产生向量地址，再由向量地址找到入口地址

几个概念：
- 中断号：8086机器中有256个中断，被编码成0~255 这个就叫中断号
- 中断向量：中断服务程序的段地址和偏移量组成的一个向量？
	chatGPT：**中断向量**（Interrupt Vector）是指在计算机系统中，用于处理中断请求的**入口地址**或**存储区域指针**。它是中断处理机制的一部分，用来定位中断服务程序（Interrupt Service Routine, ISR）的具体位置。
- 向量地址：中断向量保存的内存地址
![Pasted image 20241121155042.png|200](/img/user/accessory/Pasted%20image%2020241121155042.png)
中断向量地址生成部件的输入是排队器的输出，排队器的输出只有一位为高电平，其余都是低电平
输出是向量地址，这个向量地址可能是中断服务程序入口地址，也可能是跳转指令的地址，将来跳转到中断服务程序的入口！
![Pasted image 20241121155752.png|300](/img/user/accessory/Pasted%20image%2020241121155752.png)
#### 程序中断方式接口电路的基本组成
![Pasted image 20241122130817.png|500](/img/user/accessory/Pasted%20image%2020241122130817.png)

### 中断处理过程
1. CPU响应中断的条件和时间
	允许中断触发器 EINT=1
	开中断指令 将 eint置为1
	关中断指令 或者硬件自动复位 将eint置为0
	当D=1 （任何时候都可以） 且MASK =0 时 发起中断
	在每条指令执行阶段的结束的时候 查询是否有中断请求（CPU发出中断查询信号，INTR置为1）
2. IO中断处理过程
	以输入为例：
	CPU在执行程序的时候会执行到一条输入指令：这条输入指令要求制定的外部设备把数据输入到主机当中
	CPU根据这条设备指令 给出 设备的地址
	通过地址线送到接口电路
	在设备选择电路中，通过选择器与设备地址进行比较，如果被选中，SEL信号有效
	CPU送来启动命令，在接口电路中译码，当启动命令和SEL信号都有效，B为设为1，启动设备，D被设为0
	数据准备好以后，会送到DBR 数据存储寄存器  同时D和B分别被设置为0和1
	数据准备好，CPU随时可以把数据拿走
	如果没有被屏蔽，也就是说mask的非端为1  D的输出也是1
	两个1 经过与非门 再经过非门 为1 送入INTR
	CPU的执行结束后会发出中断查询信号 这个时候五号线为1
	INTR为1，同时，启动排队器
	经过排队器排队之后 只输出一个1
	CPU发出中断响应信号INTA
	形成向量地址  通过数据线传给pc
	pc利用地址取出中断服务程序的路口地址或者取出跳转指令
	cpu执行中断服务程序  取走数据

### 中断服务程序的流程
1. 保护现场
	1. 程序断点的保护：保存PC中的下一条指令执行的地址  和  程序执行的状态
		中断隐指令：并不是真的指令，而是硬件执行的一系列操作
	2. 寄存器内容的保护（好像在CSAPP上看到过）
2. 中断服务：不同设备功能不同
3. 恢复现场：可能是栈  也可能不是栈
4. 中断返回

1. 单重中断：CPU在执行中断程序过程中，如果有了新的中断程序，不管优先级有多高，都不能停止现在的中断
2. 多重中断：允许级别更高的中断源中断现行的中断服务程序

单重中断和多重中断的服务流程程序：
![Pasted image 20241122193736.png|400](/img/user/accessory/Pasted%20image%2020241122193736.png)

主程序和服务程序抢占CPU示意图：
![Pasted image 20241122194158.png|400](/img/user/accessory/Pasted%20image%2020241122194158.png)
宏观上CPU和IO并行工作
微观上CPU中断现行程序为IO服务

