---
{"dg-publish":true,"permalink":"/LCU principles of computer composition/高速缓冲存储器/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-11-11T17:08:42.654+08:00","updated":"2025-03-30T15:05:49.656+08:00"}
---


#### 为什么用Cache
1. 避免CPU空等现象
	静态ram做成的
	![Pasted image 20241111171909.png|300](/img/user/accessory/Pasted%20image%2020241111171909.png)
	程序访问的局部性原理：
	- 时间的局部性
		当前正在使用的指令和数据 在不久的将来 还会使用到
		那么当前正在使用的数据和指令，我们就需要放到Cache中
	- 空间的局部性
		现在在使用的指令和数据  在不久的将来 相邻的指令和数据就可能会被用到
		现在的和相邻的 都放入Cache
#### Cache的工作原理
##### 主存和缓存的编址
![Pasted image 20241112131318.png|700](/img/user/accessory/Pasted%20image%2020241112131318.png)
把主存和Cache分成大小相等的块  （块大小相等，数量不相同）
主存M块 Cache C块

内存块和Cache块的大小是相同的，块内地址的位数是相同的。
内存和Cache之间的数据传递是整体进行传递，顺序不会发生任何变化
内存和Cache 的块内地址部分是完全相同的

Cache上有个标记，标记了主存快和Cache块之间的对应关系
如果我们把主存中的一块 调入到 Cache当中
那么我们就可以把主存块号 写入到标记中
比如说CPU给出了一个主存地址，需要先看一下这个快有没有被送到Cache当中 那么会先拿出主存块号看看有没有出现在Cache中

所以对于主存和缓存的编址来说：
1. 主存和缓存都是按块存储
2. 块的大小相同
3. 快内地址完全一样

##### 命中和不命中
命中是说用到的主存调入了缓存
未命中是说未用到的主存快未调入缓存

其实命中就是主存和Cache之间建立气了一个对应关系，而这个对应关系就是Cache中的主存快号

我们希望我们拿的数据都放到了缓存当中，也就是说都命中
所以说命中是一个评价指标
叫命中率

##### 命中率
Cache的命中率和Cache的容量与块长有关
- 容量：整个Cache的容量小 那么命中率自然低 这很好理解
- 块长：
	块长过短 那么取出来的指令没读两条 就得取新的块
	快长过长 那么会有好多别的无用的指令，这样也会影响命中率
所以一般块长是取4~8个字
块长取一个存取周期内从主存调出的信息长度
$$
h=\frac{N_c}{Nc+N_m}
$$
- h: cache命中率
- $N_c$ ：cache完成存取的次数
- $N_m$: 主存完成存取的次数
##### Cache-主存系统的效率
效率e与命中率有关
$$
e=\frac{访问Cache的时间}{平均访问时间} \times 100\% = \frac{t_c}{h\times t_c+(1-h) \times t_m}
$$
Cache 和 主存 是并行进行的  这个平均访问时间才是这个公式
#### Cache的基本结构
![Pasted image 20241112140357.png|700](/img/user/accessory/Pasted%20image%2020241112140357.png)
CPU给出地址，这个地址包括块号和快内地址
快内地址直接就变成了Cache地址中的快内地址
主存块号要经过主存Cache地址映射变换机构 转换成 Cache的快号

主存Cache地址映射机构要判断是否命中，也就是Cache中是否有
如果命中就直接访问Cache 将数据送入数据总线 然后传回CPU

如果没有命中 就需要判断Cache是否还能装入新的块
如果可以那么就直接访问主存然后装入Cache中
如果Cache已经满了 就需要通过Cache替换机构来替换

Cache替换机构通过替换算法来决定：
替换还是不替换，替换的时候 是把被替换的存回主存 还是直接销毁掉

值得注意的是  如果不命中 那么其实是先把主存中的数据通过数据线直接送到CPU中 然后这个快同时装入Cache

Cache的基本结构：
- Cache存储体
- 主存Cache地址映射变换机构
- Cache替换机构
#### Cache的读写操作
##### 读
![Pasted image 20241112142736.png|700](/img/user/accessory/Pasted%20image%2020241112142736.png)
注意否的时候这两条路都要走 同时发生
而且这里不是看Cache是不是满了 而是看允许你这个内存块儿放的那些地方是否满了

##### 写
对Cache写 可能造成主存和Cache的不一致
所以写操作的一个基本的问题是 要解决Cache和主存的不一致的问题
- *Write through* 写直达法
	既写入Cache又写入主存
	时刻保持了Cache和主存的一致性
	写操作时间其实就是访问主存的时间（按大的算？）
	但是如果比如说求和  需要在更新sum的时候重复的对内存读写
- *Write back* 写回法
	只对Cache进行更新
	写操作时间就是访问Cache的时间
	Cache块退出的时候，被替换的块写会主存
	也有一定的问题  比如不同Cache都改了？不一致的问题？
#### Cache的改进
1. 增加Cache的级数
	处理器里面有片内Cache
	主板上有片外Cache
	之间在机组上还有CSAPP中看到的金字塔都是Cache3级
2. 统一缓存和分级缓存
	冯诺依曼体系结构其实是将指令和数据放到一个Cache中
	但是现在计算机有的会将指令和数据放到不同的Cache中

### Cache-主存的地址映射
#### 直接映射
![Pasted image 20241114112733.png](/img/user/accessory/Pasted%20image%2020241114112733.png)
直接映射说白了就是把Cache当做一个尺子 把主存分成若干个Cache大小的大块（分成若干个区）
然后Cache里面的字块0只能和各个大块中的字块0映射
主存给出一个地址：
- 区号 主存字块标记 t位
- 块号  Cache字块地址  c位
- 块内偏移地址 b位

Cache中的这个快是第几个区   叫区号  就是图中的标记
Cache中的第几个块（整个Cache） 其实也是这个区的第几块 叫块号
字块内地址呢其实就是一个字块也是有好几个字  里面具体的地址

确认地址已经被加载到Cache：
	通过块号找到这个块 比较标记和区号

存在的问题：
	比如说我第一次运行指令的时候 是字块0   然后跳转到下一个字块0了
	但是这个字块0只能存在Cache的第一条中 即使别的字块都是空余的也不行

#### 全相联映射
感觉是走了另外一个极端哈哈哈哈
他是说主存中的任何一个块都可以被放入到Cache的任何一个块中
![Pasted image 20241114152651.png|500](/img/user/accessory/Pasted%20image%2020241114152651.png)
 由于主存储器的块可能会被放入任何一个Cache中块中 所以比较的时候需要跟所有Cache中有的块进行比较 而且比较的位数也比较多 

#### 组相联映射
是直接映射和全相联映射的折中
先把Cache分块  然后分组  每组可以有两块 四块 八块 甚至十六块
对主存储器分区 每个区的大小 和Cache块中的组数是相同的
![Pasted image 20241114170932.png](/img/user/accessory/Pasted%20image%2020241114170932.png)
映射的时候，每个区的低0块 都可以放入Cache中第零组的任意一个位置

比较的时候 给定的组里面的几个快的标记和区号进行比较就可以了

靠近CPU的Cache层次  高速度 用直接相连  或者路数较少的组相连
中间组相连
距离CPU最远的 可以采用全相联

### 替换算法
#### 先进先出（FIFO）
其实就是把最早进入Cache的块扔出去  我们认为这个在不久的将来CPU会不会调用了
事实上仔细想想 这样是不对的
我们最先进来的可能是一直在用的一个工具
#### 近期最少使用（LRU）算法
很好的体现了局部性原理
