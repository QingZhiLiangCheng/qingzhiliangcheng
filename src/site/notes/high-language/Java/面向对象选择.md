---
{"tags":["Java"],"dg-publish":true,"created":"2025-05-06T19:58:05.691+08:00","updated":"2025-05-06T21:34:20.468+08:00","permalink":"/high-language/Java/面向对象选择/","dgPassFrontmatter":true,"noteIcon":""}
---

在Java中,关于继承，类只支持单继承 可以实现多个接口

如果父类的成员不希望被子类重写,可以在声明父类的成员时使用的修饰关键字的是 final

下列关于静态代码块、构造代码块和构造方法的执行顺序正确的是（）
A、静态代码块→构造方法→构造代码块
<font color="#f79646">B、静态代码块→构造代码块→构造方法</font>
C、构造代码块→静态代码块→构造方法
D、构造方法→构造代码块→静态代码块

接口
接口中定义的方法默认使用public abstract修饰
接口中的变量默认使用public static final修饰

下列关于对象的类型转换的描述中错误的是（）
A、对象的类型转换可通过自动转换或强制转换进行
<font color="#f79646">B、无继承关系的两个类的对象之间试图转换时会出现编译错误</font>
C、由new语句创建的父类对象可以强制转换为子类对象
D、子类对象转换为父类类型后,父类对象不能调用子类的特有方法

因为都是Object子类？

匿名内部类
原本我们需要创建子类或者实现类，去继承父类和实现接口，才能重写其中的方法。但是有时候我们这样做了，然而子类和实现类却只使用了一次（定义了一个对象）。这个时候我们就可以使用匿名内部类，不用去写子类和实现类，起到简化代码的作用。
```java
interface MyInterface {
    void doSomething();
}

public class Main {
    public static void main(String[] args) {
        MyInterface myObject = new MyInterface() {
            @Override
            public void doSomething() {
                System.out.println("This is an implementation of MyInterface using an anonymous inner class.");
            }
        };
        myObject.doSomething();
    }
}
```

```java
abstract class MyAbstractClass {
    public abstract void doSomething();
}

public class Main {
    public static void main(String[] args) {
        MyAbstractClass myObject = new MyAbstractClass() {
            @Override
            public void doSomething() {
                System.out.println("This is an implementation of MyAbstractClass using an anonymous inner class.");
            }
        };
        myObject.doSomething();
    }
}
```


对于声明为private、protected及public的类成员在类外部（）
A、只能访问声明为public的类成员
<font color="#f79646">B、只能访问声明为protected和public类的成员</font>
C、都可以访问
D、都不能访问

不管写不写访问权限,接口中方法的访问权限永远是（）
A、private
B、default
C、protected
<font color="#f79646">D、public</font>

在Java中，方法修饰符用于控制类、方法、变量等的访问权限。它们决定了哪些类可以访问这些方法或变量。Java提供了四种方法修饰符：public、private、protected和default（即没有修饰符）
- `public`是最宽松的访问修饰符。当一个类、方法或变量被声明为`public`时，它可以在任何其他类中被访问。这意味着，无论这些类是否在同一个包（package）中，都可以自由地访问和使用这个`public`成员。
- `private`是最严格的访问修饰符。当一个类、方法或变量被声明为`private`时，它只能在声明它的类内部被访问。这意味着，其他类无法直接访问或使用这个`private`成员。
- `protected`修饰符的访问权限介于`public`和`private`之间。当一个类、方法或变量被声明为`protected`时，它可以在声明它的类内部以及同一个包中的其他类中被访问。此外，子类也可以访问父类中的`protected`成员，无论这些子类是否在同一个包中。
- 当类、方法或变量没有显式地声明为`public`、`private`或`protected`时，它们的访问权限默认为`default`。这意味着，这些成员只能在声明它们的类内部以及同一个包中的其他类中被访问。


Java中没有动态代码块的说法

![Pasted image 20250507081642.png](/img/user/accessory/Pasted%20image%2020250507081642.png)

![Pasted image 20250507081739.png](/img/user/accessory/Pasted%20image%2020250507081739.png)
引用数据类型见[[CS 61B/Lecture 03 List I：References, Recursion, and Lists\|Lecture 03 List I：References, Recursion, and Lists]]

![Pasted image 20250507081936.png](/img/user/accessory/Pasted%20image%2020250507081936.png)

在构造方法中,使用this调用其他构造方法的语句必须位于第一行,且只能出现一次
正确

Java中的instanceof关键字可以判断一个对象是否为某个类(或接口)的实例
正确

一个栈内存空间可以指向多个堆内存空间
正确
