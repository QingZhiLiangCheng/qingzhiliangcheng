---
{"created":"2025-11-17T10:31","updated":"2026-01-07T17:35","dg-publish":true,"permalink":"/LCU软件设计和体系结构/设计模式/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
需要学的设计模式
![Pasted image 20251117113655.png|500](/img/user/accessory/Pasted%20image%2020251117113655.png)
记住三种类型以及三种类型下有哪些模式！
描述设计模式的四个基本要素：模式名称、问题描述、解决方案、效果

| 原则                  | 核心                                                      | 通俗理解                                                            |
| ------------------- | ------------------------------------------------------- | --------------------------------------------------------------- |
| 单一职责原则(SRP)         | 一个类应该只有一个引起它变化的原因                                       | 一个类只做一件事儿                                                       |
| 开闭原则(OCP)           | 对扩展开放，对修改关闭                                             | 不改旧代码，只加新代码                                                     |
| 里氏替换原则(LSP)         | 所有引用基类的地方必须能透明地使用其子类的对象，而不能出现任何错误                       | 子类应该能够完全替换掉它的父类，并且程序的功能不受到任何影响。子类可以有自己的新行为，但绝不能改变或违反父类已经承诺的行为。  |
| 接口隔离原则(ISP)         | 客户端不应该被强迫依赖于它们不使用的方法。接口应该小而专一                           | 接口要小而精                                                          |
| 依赖倒置原则(DIP)         | 1. 高层模块不应该依赖底层模块。两种都应该依赖于抽象。<br>2. 抽象不应该依赖于细节，细节应该依赖于抽象 | 面相接口编程！并不关心具体实现                                                 |
| 迪米特原则(LoD)          | 一个对象对其他对象又尽可能少的了解                                       | 个类应该只和它的成员变量、方法的参数、它自己创建的对象进行交互。不要去调用“朋友的朋友”的方法。这有助于降低类与类之间的耦合。 |
| 组合/聚合复用原则(CARR/CRP) | 尽量使用组合/聚合的方式，而不是使用继承来达到代码复用的目的                          | has-a 而不是 is-a                                                  |


### 简单工厂模式
![Pasted image 20251117105533.png|500](/img/user/accessory/Pasted%20image%2020251117105533.png)
简单工厂模式比较简单，说白了就是一个专门的工厂类，根据传入的参数，来决定创建哪一种产品类的实例
其实从这句话里也能得出一些信息，首先要有一个工厂类，要有一个create方法，create方法中要有if判断来决定返回什么产品。要想返回不同产品类的实例，那就只能让Factory返回一个抽象产品类或接口，然后真正的产品类继承或实现
如果把这个创建的方法变成静态的，就是静态简单工厂模式
![Pasted image 20251117105949.png|500](/img/user/accessory/Pasted%20image%2020251117105949.png)

**我觉着简单工厂的核心就是将所有的产品抽象出一个produce接口，客户端通过工厂类传入name 通过if-else判断产生不同的对应的具体product。**

优点: 职责分离，工厂类负责创建对象，客户端使用对象，符合单一职责原则
缺点：不符合开闭原则。当增加新的产品时，必须修改类中的判断逻辑，违背了“对修改关闭”的原则
### 工厂方法模式
工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
这里的核心是为了解决简单工厂不符合开闭原则的问题，这里引入了子类这种具体的工厂将原来工厂中的判断逻辑分开了。
客户端需要什么产品去找对应的工厂
![Pasted image 20251117110602.png|500](/img/user/accessory/Pasted%20image%2020251117110602.png)

![Pasted image 20251117110648.png|500](/img/user/accessory/Pasted%20image%2020251117110648.png)

符合单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护
符合开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。
缺点：应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

**我觉得工厂模式的核心是在简单模式的基础上，将工厂抽象具体到了特定的工厂产生特定的产品，解耦了原来中的if-else，客户端生产什么产品自己去找对应的客户端**

eg问题
> [!question]
> Dell生产电脑
> - Dell公司生产的电脑产品
>     - 多种型号，随时有可能增加新型号
>     - 各型号的电脑，具体装置各不相同
>     - 客户只需提供型号名称，即可获得相应电脑产品，Dell的工厂负责生产和提供不同型号的电脑产
> 
> 型号有: XPS13(i7处理器, 16GB内存), AlienwareR15(i9处理器，32GB内存)

第一步：设计图
![Pasted image 20260104155435.png|500](/img/user/accessory/Pasted%20image%2020260104155435.png)
第二步：用EA生成Java文件 -- 基本框架就形成了
第三步：填写业务代码
首先填写抽象产品的代码，我这里把代码变成了abstract
```java
public abstract class DellComputer {  
  
    protected String cpu;  
    protected String memory;  
  
    public abstract void assemble();  
  
}
```
然后填写具体实现产品的代码（以AlienwareR15为例）, 这里的assemble有点像show，是生产完了再调用的
```java
public class AlienwareR15 extends DellComputer {  
  
    public AlienwareR15(){  
        this.cpu="i9";  
        this.memory="32GB";  
    }  
  
    public void assemble(){  
        System.out.println("start AlienwareR15");  
        System.out.println(cpu+" "+memory);  
        System.out.println("end AlienwareR15");  
    }  
  
}
```
然后抽象工厂类
```java
public abstract class DellFactory {  
  
    public abstract DellComputer produce(String computer) ;  
  
}
```
具体工厂类：生成特定的产品
```java
public  class AlienwareR15Factory extends DellFactory {  
  
    public  DellComputer produce(String computer){  
        System.out.println("AlienwareR15Factory");  
        return new AlienwareR15();  
    }  
  
}
```
client具体使用：
```java
public static void main(String[] args) {  
   DellFactory xpsFactory = new XPS13Factory();  
   DellComputer xps =xpsFactory.produce("xps");  
   xps.assemble();  
  
  
   DellFactory alienwareR15Factory = new AlienwareR15Factory();  
   DellComputer alienwareR15=alienwareR15Factory.produce("alienwareR15");  
   alienwareR15.assemble();  
}
```

### 抽象工厂模式
![Pasted image 20251117112130.png|400](/img/user/accessory/Pasted%20image%2020251117112130.png)
这里的核心是抽象工厂模式与简单工厂和工厂方法（它们都只专注于创建**一种**产品）不同，抽象工厂模式的重点是创建**一整套（一个家族）相互关联的产品**，而无需指定它们的具体类。

首先，要给每种产品提供明确的结构
![Pasted image 20251117112445.png|300](/img/user/accessory/Pasted%20image%2020251117112445.png)

```java
// 抽象产品 1: 椅子
interface Chair {
    void showStyle();
}

// 抽象产品 2: 沙发
interface Sofa {
    void showStyle();
}

// 抽象产品 3: 咖啡桌
interface CoffeeTable {
    void showStyle();
}


// --- 维多利亚产品族 ---
class VictorianChair implements Chair {
    public void showStyle() { System.out.println("这是一把维多利亚风格的椅子。"); }
}
class VictorianSofa implements Sofa {
    public void showStyle() { System.out.println("这是一个维多利亚风格的沙发。"); }
}
class VictorianCoffeeTable implements CoffeeTable {
    public void showStyle() { System.out.println("这是一个维多利亚风格的咖啡桌。"); }
}

// --- 现代产品族 ---
class ModernChair implements Chair {
    public void showStyle() { System.out.println("这是一把现代风格的椅子。"); }
}
class ModernSofa implements Sofa {
    public void showStyle() { System.out.println("这是一个现代风格的沙发。"); }
}
class ModernCoffeeTable implements CoffeeTable {
    public void showStyle() { System.out.println("这是一个现代风格的咖啡桌。"); }
}

```

定义抽象工厂创建所有类型产品，然后创建具体工厂，每种工厂对应一种风格
![Pasted image 20251117112706.png|400](/img/user/accessory/Pasted%20image%2020251117112706.png)

```java
// 抽象工厂接口
interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
    CoffeeTable createCoffeeTable();
}

// 具体工厂 1: 维多利亚家具工厂
class VictorianFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new VictorianChair();
    }
    @Override
    public Sofa createSofa() {
        return new VictorianSofa();
    }
    @Override
    public CoffeeTable createCoffeeTable() {
        return new VictorianCoffeeTable();
    }
}

// 具体工厂 2: 现代家具工厂
class ModernFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new ModernChair();
    }
    @Override
    public Sofa createSofa() {
        return new ModernSofa();
    }
    @Override
    public CoffeeTable createCoffeeTable() {
        return new ModernCoffeeTable();
    }
}


```

客户端
```java
public class Client {
    public static void main(String[] args) {
        System.out.println("--- 客户需要一套维多利亚风格的家具 ---");
        // 1. 选择风格：获取维多利亚家具工厂
        FurnitureFactory victorianFactory = new VictorianFurnitureFactory();

        // 2. 从该工厂获取一套家具
        Chair victorianChair = victorianFactory.createChair();
        Sofa victorianSofa = victorianFactory.createSofa();
        CoffeeTable victorianCoffeeTable = victorianFactory.createCoffeeTable();

        // 3. 验证风格是否统一
        victorianChair.showStyle(); // 输出: 这是一把维多利亚风格的椅子。
        victorianSofa.showStyle();   // 输出: 这是一个维多利亚风格的沙发。
        victorianCoffeeTable.showStyle(); // 输出: 这是一个维多利亚风格的咖啡桌。

        System.out.println("\n--- 客户需要一套现代风格的家具 ---");
        // 1. 切换风格：获取现代家具工厂
        FurnitureFactory modernFactory = new ModernFurnitureFactory();
        
        // 2. 从新工厂获取一套家具
        Chair modernChair = modernFactory.createChair();
        Sofa modernSofa = modernFactory.createSofa();

        // 3. 验证风格
        modernChair.showStyle(); // 输出: 这是一把现代风格的椅子。
        modernSofa.showStyle();  // 输出: 这是一个现代风格的沙发。
    }
}

```
那其实就是这样
![Pasted image 20251117113253.png|400](/img/user/accessory/Pasted%20image%2020251117113253.png)
即
![Pasted image 20251117112758.png|500](/img/user/accessory/Pasted%20image%2020251117112758.png)
**抽象工厂模式的核心就是每个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。具体的做法就是抽象工厂接口定义了生产不同产品的方法。具体不同的工厂实现抽象工厂并实现生成特定风格的产品的方法。**
具体实现的方法我觉得就是 先给不同类型与产品变体绘制一个矩阵，然后实现纵向的抽象产品和具体产品。然后实现横向的抽象工厂和具体工厂

**example:** 
房屋销售查询系统
> [!question]
> 一个房屋销售查询系统，以便查询不同类型的房屋的介绍、价格和地址等。为简单起见，只考虑两种类型的房屋：别墅(House)和公寓(Condo)，并假设每种房屋类型都包含：豪华(Super)、中等(Medium)两个等级。要求能够查看房屋信息和房屋价格，请使用创建型设计模式解决该问题，画出设计类图。

可以适当画一个这样的正方形的表
![Pasted image 20260104161648.png|350](/img/user/accessory/Pasted%20image%2020260104161648.png)
第一步先实现所有的点(具体产品)以及两个竖方向的抽象产品 一般两个抽象产品用的是抽象类，因为可能有自己需要的属性
![Pasted image 20260104164411.png|300](/img/user/accessory/Pasted%20image%2020260104164411.png)
第二步实现两个具体风格工厂以及抽象工厂
![Pasted image 20260104164424.png|500](/img/user/accessory/Pasted%20image%2020260104164424.png)
第三步用EA生成代码框架
第四步增加具体产品以及抽象产品业务代码，如
```java
// -- House抽象类
public abstract class House {       
    public abstract void address();  
    public abstract void introduce();  
    public abstract void price();  
}

// -- Condo抽象类
public abstract class Condo {  
    public abstract void address();  
    public abstract void introduce();  
    public abstract void price();  
  
}

public class SuperHouse extends House {  
  
    public SuperHouse(){  
        //可以定义变量 price等等  
    }  
  
    public void address(){  
        System.out.println("this is a superHouse address");  
    }  
  
    public void introduce(){  
        System.out.println("this is a superHouse introduce");  
    }  
  
    public void price(){  
        System.out.println("this is a superHouse price");  
    }  
  
}
// ... 
```
第五步，增加抽象工厂和具体类别工厂的业务代码
```java
//抽象工厂代码不用改
public interface AbstractFactory {  
    public House produceHouse();  
    public Cando produceCondo();  
}

public class SuperFactory implements AbstractFactory {  
  
    public SuperFactory(){  
  
    }  
  
    public House produceHouse(){  
        return new SuperHouse();  
    }  
  
    public Condo produceCondo(){  
        return new SuperCondo();  
    }  
  
}

```
第六步，Client
```java
public static void main(String[] args) {  
    AbstractFactory superFactory = new SuperFactory();  
    Condo superCondo = superFactory.produceCondo();  
    superCondo.address();  
    superCondo.price();  
    superCondo.introduce();  
  
    House superhouse = superFactory.produceHouse();  
    superhouse.price();  
    superhouse.introduce();  
    superhouse.address();  
  
    AbstractFactory mediumFactory = new MediumFactory();  
    Condo mediumCondo = mediumFactory.produceCondo();  
    mediumCondo.address();  
    mediumCondo.introduce();  
    mediumCondo.price();  
  
    House mediumHouse = new MediumHouse();  
    mediumHouse.address();  
    mediumHouse.introduce();  
    mediumHouse.price();  
  
}
```

### 生成器模式
**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
![Pasted image 20251117151231.png|500](/img/user/accessory/Pasted%20image%2020251117151231.png)
如果创建一个House对象，不同的房子都继承House 这样可能会有很多子类，而且有很多重复的地方
如果不用子类，你可以在House基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题
![Pasted image 20251117151432.png|400](/img/user/accessory/Pasted%20image%2020251117151432.png)
会出现绝大多数参数没用的情况
解决方法，就是使用Builder，把每一个组件都抽取出来，通过.buildWalls()方法来创建墙
![Pasted image 20251117151505.png|400](/img/user/accessory/Pasted%20image%2020251117151505.png)
当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。
![Pasted image 20251117151636.png|400](/img/user/accessory/Pasted%20image%2020251117151636.png)

使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。
当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。
符合单一职责原则
生成器的核心在于Builder接口中规定了所有的要素，在不同的具体的Builder类中重写要素的不同的样式。具体的生成在Director中，Director中有含有不同要素的物品的具体的生成方法
我觉得具体的实现方式就是在抽象生成器中声明步骤，为不同形式的产品(比如物品和它的使用手册）创建具体的生成器类，然后通过Director类来执行具体生成不同构造的产品。然后再客户端给Director指明要生成那种形式的产品，然后生成那种构造的这种产品

**example**
> [!question]
> Dell公司生产电脑产品
> 多种型号Vostro、Optplex，随时有可能增加新型号（例如XPS）
> 各型号的电脑，需要按照指定流程完成生产装配，各型号的生产线按流程装配的相应部件
> 客户选择电脑型号，该型号的生产线生产和提供电脑产品

假设组装电脑都是以 组装cpu -> 组装memory内存 -> 组装硬盘的顺序
第一步先创建两个不一样的电脑实体 除了基本的属性之外，我又加了一个show来展示内容
![Pasted image 20260105092015.png|300](/img/user/accessory/Pasted%20image%2020260105092015.png)
第二步创建Builder接口以及具体的构造类Builder
注意DellBuilder接口除了三步builder还有一个reset函数，其实就有点像构造函数(我感觉可以直接写在构造函数中也行），主要是在下面具体函数中初始化result属性的
具体构造类中要有result属性和getResult函数！
![Pasted image 20260105092032.png|300](/img/user/accessory/Pasted%20image%2020260105092032.png)
第三步 创建Director
![Pasted image 20260105092157.png|500](/img/user/accessory/Pasted%20image%2020260105092157.png)
Director要有一个具体的DellBuilder属性，利用construct函数调用对应的一系列链式builder函数构造出产品来 同时要有setBuilder来改变不同的构造器，在client只需要建一个Director主管类就可以了，通过Director来建造产品。
**一个要注意的点是，像VostroBuilder的属性是Vostro类型，DellDirector的属性是DellBuilder，连线用关联关系（箭头直线）**
第四步，生成代码框架
第五步，增加对应业务代码，(之前我设置的Vostro的属性是private的，所以VostroBuilder想设置对应值可能需要set方法)
但核心主要在Builder构造类和Director类的业务代码
```java
//以Vostro为例 
// VostroBuilder
public class VostroBuilder implements DellBuilder {  
  
    private Vostro result;  
  
  
    public void reset(){  
        result = new Vostro();  
    }  
  
    public void buildCpu(){  
        result.setCpu("Inter Core i9");  
    }  
  
    public void buildMemory(){  
        result.setMemory("64GB DDR5");  
    }  
  
    public void buildDish(){  
        result.setDish("1TB SSD");  
    }  
  
    public Vostro getResult(){  
       return result;  
    }  
  
}
// DellDirector
public class DellDirector {  
  
    private DellBuilder builder;  
  
  
    public void construct(){  
        builder.buildCpu();  
        builder.buildMemory();  
        builder.buildDish();  
    }  
  
    public void setBuilder(DellBuilder builder){  
        this.builder = builder;  
    }  
  
}
// Client
public class Client {  
  
    public static void main(String[] args) {  
        DellDirector dellDirector = new DellDirector();  
        VostroBuilder vostroBuilder = new VostroBuilder();  
        vostroBuilder.reset();  
        dellDirector.setBuilder(vostroBuilder);  
  
        dellDirector.construct();  
  
        Vostro vostro = vostroBuilder.getResult();  
        vostro.show();  
    }  
  
}
```


> [!question]
> 生成器模式可以用于描述肯德基KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、牛肉饭等）、配餐（如新奥尔良烤翅、香辣鸡翅、吮指原味鸡等）和饮料（如果汁、可乐等）等三个组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。套餐假设目前有如下几个套餐：午餐套餐(Lunch Suit)、晚餐套餐(Supper Suit)、豪华套餐(Luxury Suit)。请用生成器模式设计该应用，画出其设计类图



### 单例模式
单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
![Pasted image 20251117153711.png|400](/img/user/accessory/Pasted%20image%2020251117153711.png)
```java
public class Emperor {
    // 1. 类加载时就立即创建实例，所以是“饿汉”
    private static final Emperor instance = new Emperor();

    // 2. 构造方法私有化，防止外部创建实例
    private Emperor() {
        System.out.println("一位皇帝诞生了！ (饿汉式)");
    }

    // 3. 提供全局访问点
    public static Emperor getInstance() {
        return instance;
    }

    // 皇帝可以处理政务
    public void handleGovernmentAffairs(String minister) {
        System.out.println("皇帝正在与 " + minister + " 商议国事...");
    }
}

```

违反了单一职责原则
线程问题
### 组合模式
组合模式让你用“树形结构”来表示整体-部分的层级关系，让客户端“一致地”处理单个对象和对象集合。
![Pasted image 20251118140735.png|300](/img/user/accessory/Pasted%20image%2020251118140735.png)
对于Composite: add, remove, getChildren是一定要有的， execute才是真正要执行的业务代码，可能有多个
不同的叶子元素是不同的实体类，击沉Component
如果有好几种不同业务的composite还要建立实体类继承composite

```text
考研复习
 ├── 高数
 │    ├── 第一章：函数极限
 │    ├── 第二章：一元微分学
 │    └── 第三章：不定积分
 ├── 英语
 │    └── 完型 & 阅读
 └── 专业课
      ├── 基础部分
      └── 算法部分

```

```java
// Compoent
interface Task {
    void show(int indent);
}

// Leaf: 不可再分的任务
class SimpleTask implements Task {
    private String name;

    public SimpleTask(String name) {
        this.name = name;
    }

    @Override
    public void show(int indent) {
        System.out.println(" ".repeat(indent) + "- " + name);
    }
}


// Composite: 包含子任务的大人物
import java.util.ArrayList;
import java.util.List;

class CompositeTask implements Task {
    private String name;
    private List<Task> children = new ArrayList<>();

    public CompositeTask(String name) {
        this.name = name;
    }

    public void add(Task t) {
        children.add(t);
    }

    @Override
    public void show(int indent) {
        System.out.println(" ".repeat(indent) + "[ " + name + " ]");
        for (Task t : children) {
            t.show(indent + 2);
        }
    }
}


//客户端使用
public class Main {
    public static void main(String[] args) {
        CompositeTask exam = new CompositeTask("考研复习");
        CompositeTask math = new CompositeTask("高数");
        CompositeTask english = new CompositeTask("英语");
        CompositeTask cs = new CompositeTask("专业课");

        // 高数子任务
        math.add(new SimpleTask("第一章：函数极限"));
        math.add(new SimpleTask("第二章：一元微分学"));
        math.add(new SimpleTask("第三章：不定积分"));

        // 英语
        english.add(new SimpleTask("完型 & 阅读"));

        // 专业课
        cs.add(new SimpleTask("基础部分"));
        cs.add(new SimpleTask("算法部分"));

        // 整体考研任务
        exam.add(math);
        exam.add(english);
        exam.add(cs);

        exam.show(0);
    }
}


```

如果你需要实现树状对象结构， 可以使用组合模式。
如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。
符合开闭原则

**example**
> [!question]
> 文件系统中的文件有不同类型，不同类型的文件其浏览方式有所区别，如文本文件和图片文件、视频文件的浏览方式就不相同。对文件夹的浏览实际上就是对其中所包含文件的浏览，而客户端可以一致地对文件和文件夹进行操作，无须关心它们的区别。请使用组合模式来模拟文件的浏览操作(display)，画出设计类图。

第一步，先实现组件接口（只有业务方法）
第二步，实现各个单个叶子节点元素实体，继承组件接口, 这里实体都有自己的属性，比如name 这里省去了getter setter方法
第三步，实现容器或者叫根节点元素实体，一方面它属于元素的一种，另一方面这个元素要有一个属性能包括叶子结点元素的数组，除了业务方法，还要有add, remove, getChildren方法
![Pasted image 20260105102442.png|400](/img/user/accessory/Pasted%20image%2020260105102442.png)
或者这里直接实现抽象类Component或许更好
然后要注意联系中，Composite包含类型为Component的数组，要用聚合关系Aggregation

> [!question]
> 计算机DIY选件计价
> 电子市场提供计算机配件时，有两种方式：
> 单一的独立配件：CPU、RAM、Mainboard、HardDisk、Mouse、Keyboard、CaseBox、PowerSupply等；
> 配套好的组合配件：MB With CPU+RAM、Mouse+KB、CaseBox+PowerSupply等。
> 需要提供功能：已选配件信息（名称、单价）显示、总计价格计算和显示。
> 为上述场景使用Composite模式完成设计，并编写代码验证功能。

大致：
![Pasted image 20260105103005.png|500](/img/user/accessory/Pasted%20image%2020260105103005.png)


### 适配器模式
适配器模式让原本接口不兼容的类能够一起工作，就像给老设备配一个转接头一样
运作方式:
1. 适配器实现与其中一个现有对象兼容的接口。
2. 现有对象可以使用该接口安全地调用适配器方法。
3. 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。

适配器模式有两种：类适配器模式和对象适配器模式
![Pasted image 20260105103609.png|500](/img/user/accessory/Pasted%20image%2020260105103609.png)

![Pasted image 20260105103536.png|500](/img/user/accessory/Pasted%20image%2020260105103536.png)

![Pasted image 20251118142300.png|400](/img/user/accessory/Pasted%20image%2020251118142300.png)
```java
// === Client Interface (Target) ===
// 客户端希望使用的接口：getRadius()
public class RoundPeg {
    protected double radius;

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}

// 不是适配器四大角色之一，但作为“客户端逻辑”使用 Target
public class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public boolean fits(RoundPeg peg) {
        return peg.getRadius() <= this.radius;
    }
}

// === Service (Adaptee) ===
// 现有的类，没有 radius，接口不兼容
public class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }
}

// === Adapter ===
// 继承 Target（RoundPeg），包装 Adaptee（SquarePeg）
// 使方钉表现得像圆钉（提供 getRadius()）
public class SquarePegAdapter extends RoundPeg {
    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        super(0);  // 先随便给父类 radius
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        // 将方钉的宽度转换为等效圆的半径（半对角线）
        return peg.getWidth() * Math.sqrt(2) / 2;
    }
}


// === Client ===
// 客户端只认识 RoundPeg（Target），却能使用 SquarePeg（Adaptee）
// 因为我们通过 Adapter 进行了适配
public class Main {
    public static void main(String[] args) {

        RoundHole hole = new RoundHole(5);

        RoundPeg roundPeg = new RoundPeg(5);
        System.out.println(hole.fits(roundPeg)); // true

        SquarePeg smallSqPeg = new SquarePeg(5);
        SquarePeg largeSqPeg = new SquarePeg(10);

        // 适配器让方钉变成“看起来像圆钉”
        SquarePegAdapter smallAdapter = new SquarePegAdapter(smallSqPeg);
        SquarePegAdapter largeAdapter = new SquarePegAdapter(largeSqPeg);

        System.out.println(hole.fits(smallAdapter)); // true
        System.out.println(hole.fits(largeAdapter)); // false
    }
}


```

当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。
符合单一职责原则
符合开闭原则

**example**
> [!question]
> 下图所示为一个整数排序的Java程序设计类图。该设计使用类适配器模式。
> ![Pasted image 20260105105026.png|400](/img/user/accessory/Pasted%20image%2020260105105026.png)
> 问题：
> （1） 请说明使用该设计有什么问题？
> （2） 画出新的设计类图。

这是一个类适配器模式的图像，但是Java是不支持多重继承的，所以我们要将is-a的关系改为has-a的关系，使用对象适配器模式，Adapter维持需要适配的对象的实例
![Pasted image 20260105204243.png|500](/img/user/accessory/Pasted%20image%2020260105204243.png)


> [!question]
> 美国和加拿大的邮政编码有不同的格式，美国的邮政编码由5位阿拉伯数字组成加破折号，再加4位阿拉伯数字组成，即美国的邮政编码形状为ddddd-dddd，其中d是介于0与9之间的整数。加拿大的邮政编码是由6位字母与数字混合组成，格式为：cdc dcd，其中第1，3，5位是英语字母，第2，4，6位是阿拉伯数字，如：M4B 1G5。假设有一个网上贸易软件，原来的客户是美国公民，但是，随着业务的扩展，将要允许加拿大公民使用该系统。假如已经有两个经过充分测试的类，一个是USZipCode，另外一个是CAPostalCode。这两个类中分别有一个方法，isValidZipCode(zip:String), 和isValidCaPostalCode(pcode: String)，用于确认用户输入的邮政编码是否正确。虽然这两个接口（方法）的参数都是String类型的，但是方法名字是不同的，而且，它们的具体的确认算法是不同的。现在要写一个网上邮政编码确认程序，该程序使用一个统一的接口，允许客户程序使用该接口的时候，既可以使用美国的邮政编码又可以使用加拿大的邮政编码。请使用适配器模式进行设计，画出设计类图。

第一步，创建通用的与Client交互的接口CheckPostCode，要有isValidZipCode和isValidCaPostalCode两个方法
第二步，创建适配器，实现CheckPostCode接口，适配器类要有USZipCode和CAPostalCode两个Adaptee类组成
第三步，创建两个原来提供方法的类 并且聚合到Adapter中
![Pasted image 20260105205212.png|500](/img/user/accessory/Pasted%20image%2020260105205212.png)


> [!question]
> 现需要设计一个可以模拟各种动物行为的机器人。目前，在机器人中已定义了一系列方法：叫喊方法cry()、移动方法move()。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫wang()，像狗一样跑run()，使用适配器模式进行设计，绘制设计类图。


### 外观模式
外观模式用一个类来简化复杂系统的使用，为用户提供一个更容易调用的统一接口。
当你遇到下面情况时：
- 一个复杂系统有许多子模块，调用方式繁琐
- 你希望给客户端一个更简单的入口
- 想隐藏内部细节，让代码更易用、更可维护

典型用途：
- 封装复杂库（如 FFmpeg、OpenCV）
- 封装复杂业务流程（如支付流程）
- 为旧系统提供友好的“统一入口”

![Pasted image 20251118143325.png|400](/img/user/accessory/Pasted%20image%2020251118143325.png)
1. **外观** （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
2. 创建**附加外观** （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。
4. **客户端** （Client） 使用外观代替对子系统对象的直接调用。

![Pasted image 20251118145323.png|400](/img/user/accessory/Pasted%20image%2020251118145323.png)


```java
//外观提供了进行视频转换的简单接口
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println("VideoConversionFacade: conversion started.");
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println("VideoConversionFacade: conversion completed.");
        return result;
    }
}


//Demo
package refactoring_guru.facade.example;

import refactoring_guru.facade.example.facade.VideoConversionFacade;

import java.io.File;

public class Demo {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo("youtubevideo.ogg", "mp4");
        // ...
    }
}
```

> [!question]
> 考察一个电源总开关的例子。为了使用方便，一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备。请使用外观模式设计该系统，画出设计类图。

第一步，创建Facade类，是四盏灯、一个风扇、一台空调和一台电视机的聚合，具有turnOnAll和turnOnOff两个方法
第二步，创建各种实体类，包含开和关两个方法，聚合成Facade类
![Pasted image 20260105211405.png|500](/img/user/accessory/Pasted%20image%2020260105211405.png)

### 桥接模式
![Pasted image 20251118152230.png|400](/img/user/accessory/Pasted%20image%2020251118152230.png)

我们可以将颜色相关的代码抽取到拥有 `红色`和 `蓝色`两个子类的颜色类中， 然后在 `形状`类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 `形状`和 `颜色`之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。

![Pasted image 20251118152307.png|400](/img/user/accessory/Pasted%20image%2020251118152307.png)
1. **抽象部分** （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。
2. **实现部分** （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。
    抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。
3. **具体实现** （Concrete Implementations） 中包括特定于平台的代码。
4. **精确抽象** （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。
5. 通常情况下， **客户端** （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。

![Pasted image 20251118152343.png|400](/img/user/accessory/Pasted%20image%2020251118152343.png)
- Remote (遥控器) 是一个基础遥控器，它定义了高层控制逻辑，比如开关、调节音量、切换频道等。
- AdvancedRemote (高级遥控器) 继承自 Remote，并在其基础上增加了新功能，比如 mute() (静音)。
- 我们可以想象，这个遥控器的“抽象”层次结构可以继续扩展，比如未来可以有 SmartRemote (智能遥控器)，增加语音控制等功能。这个维度的变化是关于 “遥控器有什么样的功能按钮”。
- Device (设备) 是一个接口，它定义了所有设备都应该具备的基础操作，如 isEnabled (是否开启), enable (开启), disable (关闭), getVolume (获取音量) 等。这是底层的、平台相关的具体操作。
- Radio (收音机) 和 TV (电视) 是 Device 接口的具体实现类。它们各自实现了如何开关、如何调节音量等具体逻辑。
- 这个设备的“实现”层次结构也可以独立扩展，比如未来可以加入 DVDPlayer (DVD播放器)、Projector (投影仪) 等新设备。这个维度的变化是关于 “设备具体如何执行这些操作”

“桥”就是 Remote 类中包含的一个 Device 类型的成员变量 (protected Device device;)。Remote 类并不关心它具体控制的是 TV 还是 Radio。它只知道它持有一个遵循 Device 接口的对象
当客户端 (Client) 调用 remote.togglePower() 时，Remote 类内部的逻辑会去调用它所持有的 device 对象的 enable() 或 disable() 方法。它将高层逻辑（“切换电源”）的请求 委托 (Delegate) 给了实现部分（具体的设备）来完成。
```java
/**
 * 实现部分的接口 (Implementor)
 * 定义了所有设备需要实现的基础操作。
 */
public interface Device {
    boolean isEnabled();
    void enable();
    void disable();
    int getVolume();
    void setVolume(int percent);
    int getChannel();
    void setChannel(int channel);
}

/**
 * 具体的设备实现：电视 (Concrete Implementor)
 */
public class Tv implements Device {
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
        System.out.println("电视: 已开机");
    }

    @Override
    public void disable() {
        on = false;
        System.out.println("电视: 已关机");
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int percent) {
        if (percent > 100) {
            this.volume = 100;
        } else if (percent < 0) {
            this.volume = 0;
        } else {
            this.volume = percent;
        }
        System.out.println("电视: 音量设置为 " + this.volume + "%");
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
        System.out.println("电视: 切换到频道 " + this.channel);
    }
}

/**
 * 具体的设备实现：收音机 (Concrete Implementor)
 */
public class Radio implements Device {
    private boolean on = false;
    private int volume = 20;
    private int channel = 1; // 代表FM频率，简化为整数

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
        System.out.println("收音机: 已开启");
    }

    @Override
    public void disable() {
        on = false;
        System.out.println("收音机: 已关闭");
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int percent) {
        if (percent > 100) {
            this.volume = 100;
        } else if (percent < 0) {
            this.volume = 0;
        } else {
            this.volume = percent;
        }
        System.out.println("收音机: 音量设置为 " + this.volume + "%");
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
        System.out.println("收音机: 调频到 FM " + this.channel);
    }
}


/**
 * 抽象部分 (Abstraction)
 * 定义了遥控器的高层控制逻辑，并通过一个Device引用与实现部分连接。
 */
public class Remote {
    // 使用 protected 使得子类可以访问，这就是“桥”
    protected Device device;

    public Remote(Device device) {
        this.device = device;
    }

    public void togglePower() {
        System.out.println("遥控器: 按下电源键");
        if (device.isEnabled()) {
            device.disable();
        } else {
            device.enable();
        }
    }

    public void volumeDown() {
        System.out.println("遥控器: 按下音量减小键");
        device.setVolume(device.getVolume() - 10);
    }

    public void volumeUp() {
        System.out.println("遥控器: 按下音量增大键");
        device.setVolume(device.getVolume() + 10);
    }

    public void channelDown() {
        System.out.println("遥控器: 按下频道减小键");
        device.setChannel(device.getChannel() - 1);
    }

    public void channelUp() {
        System.out.println("遥控器: 按下频道增大键");
        device.setChannel(device.getChannel() + 1);
    }
}


/**
 * 精确抽象 (Refined Abstraction)
 * 继承并扩展了基础遥控器的功能。
 */
public class AdvancedRemote extends Remote {
    public AdvancedRemote(Device device) {
        // 调用父类的构造函数来建立桥接
        super(device);
    }

    public void mute() {
        System.out.println("高级遥控器: 按下静音键");
        device.setVolume(0);
    }
}

public class BridgePatternDemo {
    public static void main(String[] args) {
        System.out.println("--- 测试基础遥控器和电视 ---");
        Device tv = new Tv();
        Remote basicRemote = new Remote(tv);
        basicRemote.togglePower(); // 开机
        basicRemote.volumeUp();    // 音量增大
        basicRemote.channelUp();   // 频道增加
        basicRemote.togglePower(); // 关机

        System.out.println("\n==============================\n");

        System.out.println("--- 测试高级遥控器和收音机 ---");
        Device radio = new Radio();
        // 注意，这里我们用了高级遥控器 AdvancedRemote
        AdvancedRemote advancedRemote = new AdvancedRemote(radio);
        advancedRemote.togglePower(); // 开机
        advancedRemote.volumeUp();    // 音量增大
        advancedRemote.mute();        // 使用高级遥控器特有的静音功能
        advancedRemote.togglePower(); // 关机
    }
}


```


> [!question]
> 假如公司需要设计一个特工信息系统。特工的信息被加密并且被存入文本文档或者数据库。有三种方法加密特工的名字和代码，该加密名字和代码的任务由三个类完成，这三个类是EncryptedInfo1，EncryptedInfo2，EncryptedInfo3。请使用桥接模式设计该特工信息保密系统，画出设计类图。

分析：数据库和文档使用三种加密方法来存储信息，抽象就是数据库和文档，实现是三种加密方式，具体加密这个动作就是抽象这个类中的一个方法，抽象类不关心加密方法是哪个，指需要调用他所持有的实现类中的加密方法就可以了
![Pasted image 20260106083346.png|500](/img/user/accessory/Pasted%20image%2020260106083346.png)


> [!question]
> 设计一个飞行员信息管理系统。假设飞行员分为战斗机飞行员和轰炸机飞行员；在性别上又分为男飞行员和女飞行员。请使用桥接模式进行设计，画出设计类图

分析：飞行员驾驶飞机 所以抽象是飞行员，实现是飞机，抽象持有实现类并有动作方法(驾驶)

### 迭代器模式
迭代器模式其实就是cpp上的迭代器和java中的迭代器那样的模式
![Pasted image 20251118162418.png|400](/img/user/accessory/Pasted%20image%2020251118162418.png)
1. **迭代器** （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。
2. **具体迭代器** （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。
3. **集合** （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。
4. **具体集合** （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。
5. **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。

符合单一职责原则
符合开闭原则

example
> [!question]
> 随机生成一个整数矩阵，矩阵可以看做是聚合类型的数据。使用迭代器模式设计，对该矩阵进行不同的遍历：（1）奇数遍历(OddIterator)，访问并统计矩阵中的所有奇数。（2）偶数遍历(EvenIterator)，访问并统计矩阵中的所有偶数。（3）斜对角线遍历(DiagonalIterator), 按照斜对角线迭代遍历矩阵。请应用迭代器模式进行设计，画出设计类图。

第一步，先创建Iterator接口和Collection接口；Collection能够创建不同的Iterator，Iterator应该有标准的hasNext和Next方法
第二步，实现具体的集合类和Iterator类
![Pasted image 20260106091059.png|500](/img/user/accessory/Pasted%20image%2020260106091059.png)

### 访问者模式
将数据结构与数据操作分离。使得你可以在不改变数据结构（类）的前提下，定义作用于这些元素的新操作。
![Pasted image 20251120155646.png|400](/img/user/accessory/Pasted%20image%2020251120155646.png)

```java
interface Visitor {
    void visit(Book book);
    void visit(Fruit fruit);
}
```

```java
// 抽象元素
interface Item {
    void accept(Visitor v);
    double getPrice();
}

// 具体元素：书
class Book implements Item {
    private double price;
    public Book(double price) { this.price = price; }
    public double getPrice() { return price; }

    @Override
    public void accept(Visitor v) {
        // 关键！双重分派的第二步：
        // 把“自己（this）”交给 visitor，
        // 这样 visitor 就知道现在访问的是 Book 而不是 Fruit。
        v.visit(this); 
    }
}

// 具体元素：水果
class Fruit implements Item {
    private double price;
    private double weight;
    public Fruit(double price, double weight) { 
        this.price = price; 
        this.weight = weight;
    }
    public double getPrice() { return price; }
    public double getWeight() { return weight; }

    @Override
    public void accept(Visitor v) {
        v.visit(this); // 把自己交给 visitor
    }
}
```

```java
// 访问者1：结账（计算价格）
class CheckoutVisitor implements Visitor {
    private double totalPrice = 0;

    @Override
    public void visit(Book book) {
        // 书打9折
        totalPrice += book.getPrice() * 0.9; 
    }

    @Override
    public void visit(Fruit fruit) {
        // 水果按重量计算运费等逻辑...
        totalPrice += fruit.getPrice() * fruit.getWeight();
    }
    
    public double getTotal() { return totalPrice; }
}

// 访问者2：导出清单（打印XML）
class XmlExportVisitor implements Visitor {
    @Override
    public void visit(Book book) {
        System.out.println("<book price='" + book.getPrice() + "' />");
    }

    @Override
    public void visit(Fruit fruit) {
        System.out.println("<fruit weight='" + fruit.getWeight() + "' />");
    }
}
```

```java
public static void main(String[] args) {
    // 对象结构
    List<Item> cart = new ArrayList<>();
    cart.add(new Book(100));
    cart.add(new Fruit(10, 2.5));

    // 1. 使用结账访问者
    CheckoutVisitor checkout = new CheckoutVisitor();
    for (Item item : cart) {
        item.accept(checkout); // 双重分派入口
    }
    System.out.println("总价: " + checkout.getTotal());

    // 2. 使用XML导出访问者（无需修改 Book 或 Fruit 类）
    XmlExportVisitor xmlExport = new XmlExportVisitor();
    for (Item item : cart) {
        item.accept(xmlExport);
    }
}
```


课上案例
![Pasted image 20251121161859.png](/img/user/accessory/Pasted%20image%2020251121161859.png)

> [!question]
> 案例4.4我让AI帮我改的：
> 你正在为一个名为“跃动步伐 (Dynamic Steps)”的运动品牌开发一套销售终端软件。该品牌的核心产品线非常稳定，主要包含两大系列： “风行者 (AirRunner)” 系列，原价 450 元。 “水舞者 (AquaWalker)” 系列，原价 380 元。软件的基础功能是显示鞋子的描述信息，并计算顾客最终需要支付的价格。然而，公司的市场部非常活跃，经常推出各种花样的打折促销活动。例如：活动A： 全场商品打 8 折。 活动B： 推出 满 300 减 40 的优惠券。

第一步，创建Element抽象和具体的Element，Element除了自己的属性和业务方法之外，要有一个accept方法，把自己交给vistor
第二步，创建Vistor抽象以及具体的Vistor，每一种方式就算一种具体vistor；Vistor要有能够vist每一个具体element的方法，方法内提供业务代码
	![Pasted image 20260107094715.png|500](/img/user/accessory/Pasted%20image%2020260107094715.png)



![Pasted image 20251121161935.png](/img/user/accessory/Pasted%20image%2020251121161935.png)
注意这里目录和文件夹之间是一种组合关系吧
![Pasted image 20260107100507.png|500](/img/user/accessory/Pasted%20image%2020260107100507.png)


### 命令模式
**命令模式**是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。
![Pasted image 20251118164910.png|500](/img/user/accessory/Pasted%20image%2020251118164910.png)
![Pasted image 20251118165038.png|450](/img/user/accessory/Pasted%20image%2020251118165038.png)
1. **发送者** （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。
2. **命令** （Command） 接口通常仅声明一个执行命令的方法。
3. **具体命令** （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。
4. **接收者** （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。
5. **客户端** （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。

![Pasted image 20251118165130.png|450](/img/user/accessory/Pasted%20image%2020251118165130.png)

符合单一职责原则
符合开闭原则

> [!question]
>  室内温度控制软件设计。室内温度控制需要具备窗户、风扇、空调的自动开启与关闭功能。因此，该应用需要设计三个类，分别用于封装窗户、风扇、空调。请利用命令模式设计该应用，画出设计类图。

命令模式
这里面的主要命令或者动作就是：窗户，风扇，空调的开和关
命令模式第一步就是创建核心的Invoker或者叫Sender，里面要包含一个executeCommand的方法
第二步是创建命令抽象类或接口和具体的命令类，在抽象类中或者具体的命令类中要持有要命令的物品类，并且每个命令都应该有一个execute方法
第三步，创建每个接受命令的对象
![Pasted image 20260107102317.png|500](/img/user/accessory/Pasted%20image%2020260107102317.png)
第四部，额不知道为啥client要挨着连接一遍


![Pasted image 20251120214004.png](/img/user/accessory/Pasted%20image%2020251120214004.png)


![Pasted image 20260107111626.png|500](/img/user/accessory/Pasted%20image%2020260107111626.png)

### 中介者模式
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
![Pasted image 20251119095838.png|450](/img/user/accessory/Pasted%20image%2020251119095838.png)
1. 组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。
2. 中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。
3. 具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。
4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。
 
对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。
符合单一职责原则
符合开闭原则

课上eg：
![Pasted image 20251121160854.png](/img/user/accessory/Pasted%20image%2020251121160854.png)

具体的动作就是Hotel, Airline和Tour的receive和send以及通知inform
中介者模式的核心在于每个个体Hotel, Airline, Tour都要持有中介者Mediator
中介者要持有所有的个体，并且有registerXXX方法进行注册加入自己的中介者的列表，从而能够通过inform方法通知所有的个体
![Pasted image 20260107104850.png|500](/img/user/accessory/Pasted%20image%2020260107104850.png)


> [!question]
> 此类图中包含了几个动物类，Tiger、Dog和Cat，它们都包含各自的功能，三个类相互协作并紧密耦合，以便完成类似于动物世界的游戏功能。请用中介者模式重新设计，保持功能不变，画出设计类图。

![Pasted image 20260107102540.png|500](/img/user/accessory/Pasted%20image%2020260107102540.png)


### 策略模式
策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。
![Pasted image 20251119102826.png|400](/img/user/accessory/Pasted%20image%2020251119102826.png)
1. 上下文 （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。
2. 策略 （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。
3. 具体策略 （Concrete Strategies） 实现了上下文所用算法的各种不同变体。
4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。
5. 客户端 （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。

Starategy接口，声明了各种算法各个版本共有的操作
```java
/**
 * 策略接口声明了某个算法各个不同版本间所共有的操作。
 * 上下文会使用该接口来调用由具体策略定义的算法。
 */
public interface Strategy {
    int execute(int a, int b);
}
```

ConcreteStrategy具体策略类： 各种策略算法
```java
/**
 * 具体策略会在遵循策略基础接口的情况下实现算法。
 * 该接口实现了它们在上下文中的互换性。
 */
class ConcreteStrategyAdd implements Strategy {
    @Override
    public int execute(int a, int b) {
        System.out.println("执行加法策略...");
        return a + b;
    }
}

class ConcreteStrategySubtract implements Strategy {
    @Override
    public int execute(int a, int b) {
        System.out.println("执行减法策略...");
        return a - b;
    }
}

class ConcreteStrategyMultiply implements Strategy {
    @Override
    public int execute(int a, int b) {
        System.out.println("执行乘法策略...");
        return a * b;
    }
}
```

Context: 持有一个Strategy类型的引用但并不知道引用的具体类型是哪种具体的算法 通过setStrategy给他设定是具体哪种策略 然后执行对应的execute.
```java
/**
 * 上下文定义了客户端关注的接口。
 */
public class Context {
    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。
    // 上下文必须通过策略接口来与所有策略进行交互。
    private Strategy strategy;

    /**
     * 上下文通常会通过构造函数来接收策略对象，
     * 同时还提供设置器以便在运行时切换策略。
     * @param strategy 要使用的策略
     */
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    /**
     * 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return 策略执行后的结果
     */
    public int executeStrategy(int a, int b) {
        if (strategy == null) {
            throw new IllegalStateException("策略未设置，请先调用 setStrategy()。");
        }
        return strategy.execute(a, b);
    }
}
```
client
```java
import java.util.Scanner;

/**
 * 客户端代码会选择具体策略并将其传递给上下文。
 * 客户端必须知晓策略之间的差异，才能做出正确的选择。
 */
public class ExampleApplication {
    public static void main(String[] args) {
        // 创建上下文对象
        Context context = new Context();

        Scanner scanner = new Scanner(System.in);

        System.out.print("请输入第一个数字: ");
        int firstNumber = scanner.nextInt();

        System.out.print("请输入第二个数字: ");
        int secondNumber = scanner.nextInt();

        System.out.print("请输入期望进行的行为 (add, subtract, multiply): ");
        String action = scanner.next();

        scanner.close();

        // 客户端根据用户的输入决定使用哪种策略
        if ("add".equalsIgnoreCase(action)) {
            context.setStrategy(new ConcreteStrategyAdd());
        } else if ("subtract".equalsIgnoreCase(action)) {
            context.setStrategy(new ConcreteStrategySubtract());
        } else if ("multiply".equalsIgnoreCase(action)) {
            context.setStrategy(new ConcreteStrategyMultiply());
        } else {
            System.out.println("未知的行为！");
            return;
        }

        // 上下文执行选定的策略
        int result = context.executeStrategy(firstNumber, secondNumber);

        // 打印结果
        System.out.println("结果是: " + result);
    }
}
```

策略方法的核心就是 有Strategy接口规定具体策略需要实现的方法，有具体的策略类实现不同的算法。客户端通过context设置不同的策略类从而实现不同策略类的算法。
符合开闭原则

课上eg:
![Pasted image 20251121160258.png](/img/user/accessory/Pasted%20image%2020251121160258.png)


练习:
![Pasted image 20251121160537.png|400](/img/user/accessory/Pasted%20image%2020251121160537.png)


![Pasted image 20260107110728.png|500](/img/user/accessory/Pasted%20image%2020260107110728.png)



> [!question]
> 使用状态模式设计软件。在一个面向儿童的人/机对抗游戏中有两个角色，mood_guy代表计算机游戏软件，玩家为儿童。玩家可以容易地影响mood_guy。mood_guy有三个状态：愉快、恼怒和疯狂。当它在愉快的状态时，它将唱歌；当它在恼怒的状态时，它将告诉它的朋友，抱怨某事；当它在疯狂的状态时，它将故意损坏一些东西。mood_guy可以自动改变心情状态：如果玩家忽略它超过20秒，无论处于何种状态，mood_guy将自动进入愉快状态。mood_guy的状态也可以由玩家的行为而改变：如果它处于愉快状态，玩家给它一个酸梨，则它进入恼怒状态；如果它处于恼怒状态，玩家给它一个辣椒，它将进入疯狂状态；如果它处于疯狂状态，玩家给它一个香蕉，它将进入愉快状态。要求使用状态模式设计该问题，并且：画出设计类图，该类图中应该包含两个方法：act( )和changeMood( )。

> [!question]
> 设计一个使用几种排序算法对整数进行排序的程序。该程序可以计算出每种排序算法的执行时间，以便比较各种排序算法的速度。该程序可以支持插入排序（InsertionSort）、快速排序（QuickSort）、冒泡排序（BubbleSort）、堆排序（HeapSort）。请使用策略模式进行设计，画出设计类图。



### 状态模式
状态模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类
![Pasted image 20251120152548.png|450](/img/user/accessory/Pasted%20image%2020251120152548.png)
1. 上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。
2. 状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。
3. 具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。
4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

eg: 订单的三种状态: 待支付，已支付，已发货
首先定义抽象状态接口，并实现三种具体的状态
```java
interface OrderState {
    void handlePay(OrderContext ctx);
    void handleCancel(OrderContext ctx);
}

class PendingState implements OrderState {
    @Override
    public void handlePay(OrderContext ctx) {
        System.out.println("支付成功！");
        // 核心：状态流转，把自己切换成已支付状态
        ctx.setState(new PaidState()); 
    }

    @Override
    public void handleCancel(OrderContext ctx) {
        System.out.println("订单直接取消。");
    }
}

class PaidState implements OrderState {
    @Override
    public void handlePay(OrderContext ctx) {
        System.out.println("您已经付过款了，请勿重复支付。");
    }

    @Override
    public void handleCancel(OrderContext ctx) {
        System.out.println("发起退款流程...");
    }
}


```

定义ordercontext持有orderstate当前状态,并且能够修改状态
```java
class OrderContext {
    // 持有当前状态
    private OrderState currentState;

    public OrderContext() {
        // 初始状态
        this.currentState = new PendingState(); 
    }

    public void setState(OrderState state) {
        this.currentState = state;
    }

    // 动作委托给当前状态去处理
    public void pay() {
        currentState.handlePay(this);
    }

    public void cancel() {
        currentState.handleCancel(this);
    }
}
```
client
```java
public static void main(String[] args) {
    OrderContext order = new OrderContext();
    
    order.pay();    // 输出：支付成功！(内部状态自动变为 PaidState)
    order.pay();    // 输出：您已经付过款了...
    order.cancel(); // 输出：发起退款流程...
}
```

eg2:
![Pasted image 20251121155038.png](/img/user/accessory/Pasted%20image%2020251121155038.png)

符合单一职责原则
符合开闭原则

练习
![Pasted image 20251121155341.png](/img/user/accessory/Pasted%20image%2020251121155341.png)

第一步，创建抽象状态和具体状态，不同的状态发送不同的提示，所以应该有一个tipmessage的方法
第二步，创建Context，持有不同的状态，这里的Context应该是Account，持有state就要有一个changeState的方法改变持有的状态；同时正经的业务逻辑要写在Context，clinet和Context交互，这里是打电话dial
![Pasted image 20260107152510.png|500](/img/user/accessory/Pasted%20image%2020260107152510.png)

> [!question]
> 利用状态模式设计的Weather State的实例。在本例中，考虑天气状态。天气状态可以分为：晴天状态(Sunny State)，下雨状态(Rainy State)，刮风状态(Windy State)，下雪（Snowing State）。在晴天状态，阳光普照；在雨天状态乌云密布，下雨不停；在刮风状态，大风刮得天昏地暗；在下雪状态，大雪纷飞。用状态模式封装天气状态。为了表达天有不测风云的思想，假设天气状态是随机改变的，即在四种状态之间的切换是根本没有规律可循的，因此，考虑在抽象类WeatherState中的方法changeState(Context cxt)的实现中，使用能产生随机整数的Random类。因此，具体状态的改变，由抽象类WeatherState负责实现。请采用常规的状态模式进行设计，画出设计类图。


### 观察者模式
定义对象间的一种 一对多（One-to-Many） 的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
就像我们在b站上关注了一个up主，up主更新，所有人都会得到推送
![Pasted image 20251120153509.png|450](/img/user/accessory/Pasted%20image%2020251120153509.png)
1. 发布者 （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。
2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。
3. 订阅者 （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 `update`更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。
4. 具体订阅者 （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。
5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。
6. 客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

```java
import java.util.ArrayList;
import java.util.List;

// ==========================================
// 3. Subscriber Interface (对应图中标注 3)
// ==========================================
interface Subscriber {
    // 图中是 update(context)，这里 context 就是 Publisher 本身
    void update(Publisher publisher); 
}

// ==========================================
// 1. Publisher (对应图中标注 1)
// ==========================================
class Publisher {
    // 维护订阅者列表
    private List<Subscriber> subscribers = new ArrayList<>();
    
    // mainState (对应图中标注 1 的 mainState)
    private String productName;
    private boolean inStock = false; // 核心状态：是否有货

    public Publisher(String name) {
        this.productName = name;
    }

    public void subscribe(Subscriber s) {
        subscribers.add(s);
    }

    public void unsubscribe(Subscriber s) {
        subscribers.remove(s);
    }

    public boolean isInStock() {
        return inStock;
    }

    public String getProductName() {
        return productName;
    }

    // 对应图中标注 2 (上面的框)：通知逻辑
    public void notifySubscribers() {
        for (Subscriber s : subscribers) {
            // 关键点：s.update(this) -> 把自己传过去
            s.update(this); 
        }
    }

    // 对应图中标注 2 (下面的框)：业务逻辑
    public void restock() {
        System.out.println("【商城】: " + productName + " 补货上架了！");
        this.inStock = true; // mainState = newState
        notifySubscribers(); // 触发通知
    }
}

// ==========================================
// 4. Concrete Subscribers (对应图中标注 4)
// ==========================================

// 具体订阅者A：普通玩家
class Gamer implements Subscriber {
    private String name;

    public Gamer(String name) {
        this.name = name;
    }

    @Override
    // 对应图中标注 5：具体的响应逻辑
    public void update(Publisher publisher) {
        if (publisher.isInStock()) {
            System.out.println(name + " (玩家):收到通知，" + publisher.getProductName() + " 有货了！我要买！");
        }
    }
}

// 具体订阅者B：黄牛
class Scalper implements Subscriber {
    @Override
    // 对应图中标注 5：具体的响应逻辑
    public void update(Publisher publisher) {
        if (publisher.isInStock()) {
            System.out.println("黄牛 (脚本): 检测到 " + publisher.getProductName() + " 上架，正在启动自动抢购程序...");
        }
    }
}

// ==========================================
// 6. Client (对应图中标注 6)
// ==========================================
public class Client {
    public static void main(String[] args) {
        // 1. 创建 Publisher
        Publisher rtx4090 = new Publisher("RTX 4090 显卡");

        // 2. 创建具体 Subscribers
        Subscriber player1 = new Gamer("小明");
        Subscriber player2 = new Gamer("小红");
        Subscriber scalper = new Scalper();

        // 3. 注册 (subscribe)
        rtx4090.subscribe(player1);
        rtx4090.subscribe(player2);
        rtx4090.subscribe(scalper);

        // 4. 触发业务逻辑
        System.out.println("--- 此时显卡还没货 ---");
        
        // 这一步对应图中标注 2 (mainBusinessLogic)
        // 状态改变 -> 自动通知所有订阅者
        rtx4090.restock(); 
    }
}
```

![Pasted image 20260107190730.png](/img/user/accessory/Pasted%20image%2020260107190730.png)

![db0b643fd0f0d118516f5bf6b2e47b1b.jpg](/img/user/accessory/db0b643fd0f0d118516f5bf6b2e47b1b.jpg)
