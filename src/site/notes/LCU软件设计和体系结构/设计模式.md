---
{"created":"2025-11-17T10:31","updated":"2025-11-21T15:41","dg-publish":true,"permalink":"/LCU软件设计和体系结构/设计模式/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
需要学的设计模式
![Pasted image 20251117113655.png|500](/img/user/accessory/Pasted%20image%2020251117113655.png)

描述设计模式的四个基本要素：模式名称、问题描述、解决方案、效果

| 原则                  | 核心                                                      | 通俗理解                                                            |
| ------------------- | ------------------------------------------------------- | --------------------------------------------------------------- |
| 单一职责原则(SRP)         | 一个类应该只有一个引起它变化的原因                                       | 一个类只做一件事儿                                                       |
| 开闭原则(OCP)           | 对扩展开放，对修改关闭                                             | 不改旧代码，只加新代码                                                     |
| 里氏替换原则(LSP)         | 所有引用基类的地方必须能透明地使用其子类的对象，而不能出现任何错误                       | 子类应该能够完全替换掉它的父类，并且程序的功能不受到任何影响。子类可以有自己的新行为，但绝不能改变或违反父类已经承诺的行为。  |
| 接口隔离原则(ISP)         | 客户端不应该被强迫依赖于它们不使用的方法。接口应该小而专一                           | 接口要小而精                                                          |
| 依赖倒置原则(DIP)         | 1. 高层模块不应该依赖底层模块。两种都应该依赖于抽象。<br>2. 抽象不应该依赖于细节，细节应该依赖于抽象 | 面相接口编程！并不关心具体实现                                                 |
| 迪米特原则(LoD)          | 一个对象对其他对象又尽可能少的了解                                       | 个类应该只和它的成员变量、方法的参数、它自己创建的对象进行交互。不要去调用“朋友的朋友”的方法。这有助于降低类与类之间的耦合。 |
| 组合/聚合复用原则(CARR/CRP) | 尽量使用组合/聚合的方式，而不是使用继承来达到代码复用的目的                          | has-a 而不是 is-a                                                  |


### 简单工厂模式
![Pasted image 20251117105533.png|500](/img/user/accessory/Pasted%20image%2020251117105533.png)
简单工厂模式比较简单，说白了就是一个专门的工厂类，根据传入的参数，来决定创建哪一种产品类的实例
其实从这句话里也能得出一些信息，首先要有一个工厂类，要有一个create方法，create方法中要有if判断来决定返回什么产品。要想返回不同产品类的实例，那就只能让Factory返回一个抽象产品类或接口，然后真正的产品类继承或实现
如果把这个创建的方法变成静态的，就是静态简单工厂模式
![Pasted image 20251117105949.png|500](/img/user/accessory/Pasted%20image%2020251117105949.png)

**我觉着简单工厂的核心就是将所有的产品抽象出一个produce接口，客户端通过工厂类传入name 通过if-else判断产生不同的对应的具体product。**

优点: 职责分离，工厂类负责创建对象，客户端使用对象，符合单一职责原则
缺点：不符合开闭原则。当增加新的产品时，必须修改类中的判断逻辑，违背了“对修改关闭”的原则
### 工厂方法模式
工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
这里的核心是为了解决简单工厂不符合开闭原则的问题，这里引入了子类这种具体的工厂将原来工厂中的判断逻辑分开了。
客户端需要什么产品去找对应的工厂
![Pasted image 20251117110602.png|500](/img/user/accessory/Pasted%20image%2020251117110602.png)

![Pasted image 20251117110648.png|500](/img/user/accessory/Pasted%20image%2020251117110648.png)

```java
// 1. 抽象产品
interface Chart {
    void display();
}

// 2. 具体产品
class PieChart implements Chart {
    public void display() { System.out.println("显示饼图"); }
}

class LineChart implements Chart {
    public void display() { System.out.println("显示折线图"); }
}


// 3. 抽象工厂
interface ChartFactory {
    // 这就是“工厂方法”，返回一个抽象产品
    Chart createChart(); 
}

// 4. 具体工厂
class PieChartFactory implements ChartFactory {
    @Override
    public Chart createChart() {
        System.out.println("饼图工厂：正在生产饼图...");
        return new PieChart();
    }
}

class LineChartFactory implements ChartFactory {
    @Override
    public Chart createChart() {
        System.out.println("折线图工厂：正在生产折线图...");
        return new LineChart();
    }
}

//5. 客户端
public class Client {
    public static void main(String[] args) {
        // 我需要一个饼图，所以我找到饼图工厂
        ChartFactory pieFactory = new PieChartFactory();
        Chart pieChart = pieFactory.createChart();
        pieChart.display();

        System.out.println("-----------------");

        // 我需要一个折线图，所以我找到折线图工厂
        ChartFactory lineFactory = new LineChartFactory();
        Chart lineChart = lineFactory.createChart();
        lineChart.display();
    }
}

```

当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。
如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法
如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。
符合单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护
符合开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。
缺点：应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。
**与其他模式的关系**
抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。

**我觉得工厂模式的核心是在简单模式的基础上，将工厂抽象具体到了特定的工厂产生特定的产品，解耦了原来中的if-else，客户端生产什么产品自己去找对应的客户端**


### 抽象工厂模式
![Pasted image 20251117112130.png|400](/img/user/accessory/Pasted%20image%2020251117112130.png)
这里的核心是抽象工厂模式与简单工厂和工厂方法（它们都只专注于创建**一种**产品）不同，抽象工厂模式的重点是创建**一整套（一个家族）相互关联的产品**，而无需指定它们的具体类。

首先，要给每种产品提供明确的结构
![Pasted image 20251117112445.png|300](/img/user/accessory/Pasted%20image%2020251117112445.png)

```java
// 抽象产品 1: 椅子
interface Chair {
    void showStyle();
}

// 抽象产品 2: 沙发
interface Sofa {
    void showStyle();
}

// 抽象产品 3: 咖啡桌
interface CoffeeTable {
    void showStyle();
}


// --- 维多利亚产品族 ---
class VictorianChair implements Chair {
    public void showStyle() { System.out.println("这是一把维多利亚风格的椅子。"); }
}
class VictorianSofa implements Sofa {
    public void showStyle() { System.out.println("这是一个维多利亚风格的沙发。"); }
}
class VictorianCoffeeTable implements CoffeeTable {
    public void showStyle() { System.out.println("这是一个维多利亚风格的咖啡桌。"); }
}

// --- 现代产品族 ---
class ModernChair implements Chair {
    public void showStyle() { System.out.println("这是一把现代风格的椅子。"); }
}
class ModernSofa implements Sofa {
    public void showStyle() { System.out.println("这是一个现代风格的沙发。"); }
}
class ModernCoffeeTable implements CoffeeTable {
    public void showStyle() { System.out.println("这是一个现代风格的咖啡桌。"); }
}

```

定义抽象工厂创建所有类型产品，然后创建具体工厂，每种工厂对应一种风格
![Pasted image 20251117112706.png|400](/img/user/accessory/Pasted%20image%2020251117112706.png)

```java
// 抽象工厂接口
interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
    CoffeeTable createCoffeeTable();
}

// 具体工厂 1: 维多利亚家具工厂
class VictorianFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new VictorianChair();
    }
    @Override
    public Sofa createSofa() {
        return new VictorianSofa();
    }
    @Override
    public CoffeeTable createCoffeeTable() {
        return new VictorianCoffeeTable();
    }
}

// 具体工厂 2: 现代家具工厂
class ModernFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new ModernChair();
    }
    @Override
    public Sofa createSofa() {
        return new ModernSofa();
    }
    @Override
    public CoffeeTable createCoffeeTable() {
        return new ModernCoffeeTable();
    }
}


```

客户端
```java
public class Client {
    public static void main(String[] args) {
        System.out.println("--- 客户需要一套维多利亚风格的家具 ---");
        // 1. 选择风格：获取维多利亚家具工厂
        FurnitureFactory victorianFactory = new VictorianFurnitureFactory();

        // 2. 从该工厂获取一套家具
        Chair victorianChair = victorianFactory.createChair();
        Sofa victorianSofa = victorianFactory.createSofa();
        CoffeeTable victorianCoffeeTable = victorianFactory.createCoffeeTable();

        // 3. 验证风格是否统一
        victorianChair.showStyle(); // 输出: 这是一把维多利亚风格的椅子。
        victorianSofa.showStyle();   // 输出: 这是一个维多利亚风格的沙发。
        victorianCoffeeTable.showStyle(); // 输出: 这是一个维多利亚风格的咖啡桌。

        System.out.println("\n--- 客户需要一套现代风格的家具 ---");
        // 1. 切换风格：获取现代家具工厂
        FurnitureFactory modernFactory = new ModernFurnitureFactory();
        
        // 2. 从新工厂获取一套家具
        Chair modernChair = modernFactory.createChair();
        Sofa modernSofa = modernFactory.createSofa();

        // 3. 验证风格
        modernChair.showStyle(); // 输出: 这是一把现代风格的椅子。
        modernSofa.showStyle();  // 输出: 这是一个现代风格的沙发。
    }
}

```
那其实就是这样
![Pasted image 20251117113253.png|400](/img/user/accessory/Pasted%20image%2020251117113253.png)
即
![Pasted image 20251117112758.png|500](/img/user/accessory/Pasted%20image%2020251117112758.png)
**抽象工厂模式的核心就是每个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。具体的做法就是抽象工厂接口定义了生产不同产品的方法。具体不同的工厂实现抽象工厂并实现生成特定风格的产品的方法。**
具体实现的方法我觉得就是 先给不同类型与产品变体绘制一个矩阵，然后实现纵向的抽象产品和具体产品。然后实现横向的抽象工厂和具体工厂

### 生成器模式
**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
![Pasted image 20251117151231.png|500](/img/user/accessory/Pasted%20image%2020251117151231.png)
如果创建一个House对象，不同的房子都继承House 这样可能会有很多子类，而且有很多重复的地方
如果不用子类，你可以在House基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题
![Pasted image 20251117151432.png|400](/img/user/accessory/Pasted%20image%2020251117151432.png)
会出现绝大多数参数没用的情况
解决方法，就是使用Builder，把每一个组件都抽取出来，通过.buildWalls()方法来创建墙
![Pasted image 20251117151505.png|400](/img/user/accessory/Pasted%20image%2020251117151505.png)
当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。
![Pasted image 20251117151636.png|400](/img/user/accessory/Pasted%20image%2020251117151636.png)

```java
// 这是我们的一个产品：一个复杂的实体房子对象
public class House {
    private int windows;
    private int doors;
    private int rooms;
    private boolean hasGarage;
    private boolean hasSwimmingPool;
    private boolean hasGarden;

    // 为了简洁，我们省略了所有setter和getter，只留下一个toString()来展示结果
    @Override
    public String toString() {
        return "实体房子: \n" +
                "  窗户=" + windows + "\n" +
                "  门=" + doors + "\n" +
                "  房间=" + rooms + "\n" +
                "  是否有车库=" + hasGarage + "\n" +
                "  是否有泳池=" + hasSwimmingPool + "\n" +
                "  是否有花园=" + hasGarden + "\n";
    }
    
    // setter们会被Builder调用
    public void setWindows(int windows) { this.windows = windows; }
    public void setDoors(int doors) { this.doors = doors; }
    public void setRooms(int rooms) { this.rooms = rooms; }
    public void setHasGarage(boolean hasGarage) { this.hasGarage = hasGarage; }
    public void setHasSwimmingPool(boolean hasSwimmingPool) { this.hasSwimmingPool = hasSwimmingPool; }
    public void setHasGarden(boolean hasGarden) { this.hasGarden = hasGarden; }
}


// 这是我们的另一个产品：一个描述房子规格的蓝图/手册
public class HouseBlueprint {
    private StringBuilder description = new StringBuilder();

    public void addPart(String partDescription) {
        description.append(partDescription).append("\n");
    }

    @Override
    public String toString() {
        return "房子蓝图/手册:\n" + description.toString();
    }
}


// 对应UML图中的 <<interface>> Builder
public interface IHouseBuilder {
    void reset();
    void buildWindows(int number);
    void buildDoors(int number);
    void buildRooms(int number);
    void buildGarage();
    void buildSwimmingPool();
    void buildGarden();
}

// 对应UML图中的 Builder1
public class HouseBuilder implements IHouseBuilder {
    private House house;

    public HouseBuilder() {
        this.reset();
    }
    
    @Override
    public void reset() {
        this.house = new House();
    }

    @Override
    public void buildWindows(int number) {
        house.setWindows(number);
    }

    @Override
    public void buildDoors(int number) {
        house.setDoors(number);
    }

    @Override
    public void buildRooms(int number) {
        house.setRooms(number);
    }

    @Override
    public void buildGarage() {
        house.setHasGarage(true);
    }

    @Override
    public void buildSwimmingPool() {
        house.setHasSwimmingPool(true);
    }

    @Override
    public void buildGarden() {
        house.setHasGarden(true);
    }

    // 这是获取最终产品的方法
    public House getResult() {
        return this.house;
    }
}

// 对应UML图中的 Builder2
public class HouseBlueprintBuilder implements IHouseBuilder {
    private HouseBlueprint blueprint;

    public HouseBlueprintBuilder() {
        this.reset();
    }

    @Override
    public void reset() {
        this.blueprint = new HouseBlueprint();
    }

    @Override
    public void buildWindows(int number) {
        blueprint.addPart("添加 " + number + " 个窗户的施工说明。");
    }

    @Override
    public void buildDoors(int number) {
        blueprint.addPart("添加 " + number + " 个门的施工说明。");
    }

    @Override
    public void buildRooms(int number) {
        blueprint.addPart("规划并建造 " + number + " 个房间。");
    }

    @Override
    public void buildGarage() {
        blueprint.addPart("添加车库建造规范：地基、尺寸、材料等。");
    }

    @Override
    public void buildSwimmingPool() {
        blueprint.addPart("添加泳池建造规范：挖掘、防水、过滤系统等。");
    }

    @Override
    public void buildGarden() {
        blueprint.addPart("添加花园设计和施工说明：土壤、植物选择、灌溉系统。");
    }

    // 获取最终产品
    public HouseBlueprint getResult() {
        return this.blueprint;
    }
}


// 对应UML图中的 Director
public class Director {
    // 指挥建造一个“家庭别墅” (House with garden)
    public void buildFamilyVilla(IHouseBuilder builder) {
        builder.reset();
        builder.buildDoors(3);
        builder.buildWindows(6);
        builder.buildRooms(5);
        builder.buildGarage();
        builder.buildGarden();
    }

    // 指挥建造一个“豪华泳池别墅” (House with swimming pool)
    public void buildLuxuryPoolVilla(IHouseBuilder builder) {
        builder.reset();
        builder.buildDoors(5);
        builder.buildWindows(10);
        builder.buildRooms(8);
        builder.buildGarage();
        builder.buildSwimmingPool();
    }
}

//客户端
public class Demo {
    public static void main(String[] args) {
        // 创建一个项目经理
        Director director = new Director();

        System.out.println("--- 建造一栋家庭别墅 ---");

        // 1. 建造实体房子
        HouseBuilder houseBuilder = new HouseBuilder();
        director.buildFamilyVilla(houseBuilder); // 项目经理指挥施工队
        House familyVilla = houseBuilder.getResult(); // 从施工队获取成果
        System.out.println("建造完成的实体房子：");
        System.out.println(familyVilla);

        // 2. 使用完全相同的流程，生成对应的蓝图
        HouseBlueprintBuilder blueprintBuilder = new HouseBlueprintBuilder();
        director.buildFamilyVilla(blueprintBuilder); // 同一个项目经理，用同样的流程指挥
        HouseBlueprint familyVillaBlueprint = blueprintBuilder.getResult(); // 从蓝图团队获取成果
        System.out.println("生成的房子蓝图：");
        System.out.println(familyVillaBlueprint);
        
        System.out.println("========================================\n");
        
        System.out.println("--- 建造一栋豪华泳池别墅 ---");
        
        // 3. 建造豪华泳池别墅的实体
        director.buildLuxuryPoolVilla(houseBuilder); // 复用houseBuilder
        House luxuryVilla = houseBuilder.getResult();
        System.out.println("建造完成的实体房子：");
        System.out.println(luxuryVilla);
        
        // 4. 生成豪华泳池别墅的蓝图
        director.buildLuxuryPoolVilla(blueprintBuilder); // 复用blueprintBuilder
        HouseBlueprint luxuryVillaBlueprint = blueprintBuilder.getResult();
        System.out.println("生成的房子蓝图：");
        System.out.println(luxuryVillaBlueprint);
    }
}

```
使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。
当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。

符合单一职责原则

生成器的核心在于Builder接口中规定了所有的要素，在不同的具体的Builder类中重写要素的不同的样式。具体的生成在Director中，Director中有含有不同要素的物品的具体的生成方法

我觉得具体的实现方式就是在抽象生成器中声明步骤，为不同形式的产品(比如物品和它的使用手册）创建具体的生成器类，然后通过Director类来执行具体生成不同构造的产品。然后再客户端给Director指明要生成那种形式的产品，然后生成那种构造的这种产品

### 单例模式
单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
![Pasted image 20251117153711.png|400](/img/user/accessory/Pasted%20image%2020251117153711.png)
```java
public class Emperor {
    // 1. 类加载时就立即创建实例，所以是“饿汉”
    private static final Emperor instance = new Emperor();

    // 2. 构造方法私有化，防止外部创建实例
    private Emperor() {
        System.out.println("一位皇帝诞生了！ (饿汉式)");
    }

    // 3. 提供全局访问点
    public static Emperor getInstance() {
        return instance;
    }

    // 皇帝可以处理政务
    public void handleGovernmentAffairs(String minister) {
        System.out.println("皇帝正在与 " + minister + " 商议国事...");
    }
}

```

违反了单一职责原则
线程问题
### 组合模式
组合模式让你用“树形结构”来表示整体-部分的层级关系，让客户端“一致地”处理单个对象和对象集合。
![Pasted image 20251118140735.png|300](/img/user/accessory/Pasted%20image%2020251118140735.png)
1. **组件** （Component） 接口描述了树中简单项目和复杂项目所共有的操作。
2. **叶节点** （Leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。
3. **容器** （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。
4. **客户端** （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。

```text
考研复习
 ├── 高数
 │    ├── 第一章：函数极限
 │    ├── 第二章：一元微分学
 │    └── 第三章：不定积分
 ├── 英语
 │    └── 完型 & 阅读
 └── 专业课
      ├── 基础部分
      └── 算法部分

```

```java
// Compoent
interface Task {
    void show(int indent);
}

// Leaf: 不可再分的任务
class SimpleTask implements Task {
    private String name;

    public SimpleTask(String name) {
        this.name = name;
    }

    @Override
    public void show(int indent) {
        System.out.println(" ".repeat(indent) + "- " + name);
    }
}


// Composite: 包含子任务的大人物
import java.util.ArrayList;
import java.util.List;

class CompositeTask implements Task {
    private String name;
    private List<Task> children = new ArrayList<>();

    public CompositeTask(String name) {
        this.name = name;
    }

    public void add(Task t) {
        children.add(t);
    }

    @Override
    public void show(int indent) {
        System.out.println(" ".repeat(indent) + "[ " + name + " ]");
        for (Task t : children) {
            t.show(indent + 2);
        }
    }
}


//客户端使用
public class Main {
    public static void main(String[] args) {
        CompositeTask exam = new CompositeTask("考研复习");
        CompositeTask math = new CompositeTask("高数");
        CompositeTask english = new CompositeTask("英语");
        CompositeTask cs = new CompositeTask("专业课");

        // 高数子任务
        math.add(new SimpleTask("第一章：函数极限"));
        math.add(new SimpleTask("第二章：一元微分学"));
        math.add(new SimpleTask("第三章：不定积分"));

        // 英语
        english.add(new SimpleTask("完型 & 阅读"));

        // 专业课
        cs.add(new SimpleTask("基础部分"));
        cs.add(new SimpleTask("算法部分"));

        // 整体考研任务
        exam.add(math);
        exam.add(english);
        exam.add(cs);

        exam.show(0);
    }
}


```

如果你需要实现树状对象结构， 可以使用组合模式。
如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。

符合开闭原则

### 适配器模式
适配器模式让原本接口不兼容的类能够一起工作，就像给老设备配一个转接头一样
运作方式:
1. 适配器实现与其中一个现有对象兼容的接口。
2. 现有对象可以使用该接口安全地调用适配器方法。
3. 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。

![Pasted image 20251118141844.png|400](/img/user/accessory/Pasted%20image%2020251118141844.png)
1. **客户端** （Client） 是包含当前程序业务逻辑的类。
2. **客户端接口** （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。
3. **服务** （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。
4. **适配器** （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。
5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。

![Pasted image 20251118142300.png|400](/img/user/accessory/Pasted%20image%2020251118142300.png)
```java
// === Client Interface (Target) ===
// 客户端希望使用的接口：getRadius()
public class RoundPeg {
    protected double radius;

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}

// 不是适配器四大角色之一，但作为“客户端逻辑”使用 Target
public class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public boolean fits(RoundPeg peg) {
        return peg.getRadius() <= this.radius;
    }
}

// === Service (Adaptee) ===
// 现有的类，没有 radius，接口不兼容
public class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }
}

// === Adapter ===
// 继承 Target（RoundPeg），包装 Adaptee（SquarePeg）
// 使方钉表现得像圆钉（提供 getRadius()）
public class SquarePegAdapter extends RoundPeg {
    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        super(0);  // 先随便给父类 radius
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        // 将方钉的宽度转换为等效圆的半径（半对角线）
        return peg.getWidth() * Math.sqrt(2) / 2;
    }
}


// === Client ===
// 客户端只认识 RoundPeg（Target），却能使用 SquarePeg（Adaptee）
// 因为我们通过 Adapter 进行了适配
public class Main {
    public static void main(String[] args) {

        RoundHole hole = new RoundHole(5);

        RoundPeg roundPeg = new RoundPeg(5);
        System.out.println(hole.fits(roundPeg)); // true

        SquarePeg smallSqPeg = new SquarePeg(5);
        SquarePeg largeSqPeg = new SquarePeg(10);

        // 适配器让方钉变成“看起来像圆钉”
        SquarePegAdapter smallAdapter = new SquarePegAdapter(smallSqPeg);
        SquarePegAdapter largeAdapter = new SquarePegAdapter(largeSqPeg);

        System.out.println(hole.fits(smallAdapter)); // true
        System.out.println(hole.fits(largeAdapter)); // false
    }
}


```

当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。
符合单一职责原则
符合开闭原则

### 外观模式
外观模式用一个类来简化复杂系统的使用，为用户提供一个更容易调用的统一接口。
当你遇到下面情况时：
- 一个复杂系统有许多子模块，调用方式繁琐
- 你希望给客户端一个更简单的入口
- 想隐藏内部细节，让代码更易用、更可维护

典型用途：
- 封装复杂库（如 FFmpeg、OpenCV）
- 封装复杂业务流程（如支付流程）
- 为旧系统提供友好的“统一入口”

![Pasted image 20251118143325.png|400](/img/user/accessory/Pasted%20image%2020251118143325.png)
1. **外观** （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
2. 创建**附加外观** （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。
4. **客户端** （Client） 使用外观代替对子系统对象的直接调用。

![Pasted image 20251118145323.png|400](/img/user/accessory/Pasted%20image%2020251118145323.png)


```java
//外观提供了进行视频转换的简单接口
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println("VideoConversionFacade: conversion started.");
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println("VideoConversionFacade: conversion completed.");
        return result;
    }
}


//Demo
package refactoring_guru.facade.example;

import refactoring_guru.facade.example.facade.VideoConversionFacade;

import java.io.File;

public class Demo {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo("youtubevideo.ogg", "mp4");
        // ...
    }
}
```

### 桥接模式
![Pasted image 20251118152230.png|400](/img/user/accessory/Pasted%20image%2020251118152230.png)

我们可以将颜色相关的代码抽取到拥有 `红色`和 `蓝色`两个子类的颜色类中， 然后在 `形状`类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 `形状`和 `颜色`之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。

![Pasted image 20251118152307.png|400](/img/user/accessory/Pasted%20image%2020251118152307.png)
1. **抽象部分** （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。
2. **实现部分** （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。
    抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。
3. **具体实现** （Concrete Implementations） 中包括特定于平台的代码。
4. **精确抽象** （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。
5. 通常情况下， **客户端** （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。

![Pasted image 20251118152343.png|400](/img/user/accessory/Pasted%20image%2020251118152343.png)
- Remote (遥控器) 是一个基础遥控器，它定义了高层控制逻辑，比如开关、调节音量、切换频道等。
- AdvancedRemote (高级遥控器) 继承自 Remote，并在其基础上增加了新功能，比如 mute() (静音)。
- 我们可以想象，这个遥控器的“抽象”层次结构可以继续扩展，比如未来可以有 SmartRemote (智能遥控器)，增加语音控制等功能。这个维度的变化是关于 “遥控器有什么样的功能按钮”。

- Device (设备) 是一个接口，它定义了所有设备都应该具备的基础操作，如 isEnabled (是否开启), enable (开启), disable (关闭), getVolume (获取音量) 等。这是底层的、平台相关的具体操作。
- Radio (收音机) 和 TV (电视) 是 Device 接口的具体实现类。它们各自实现了如何开关、如何调节音量等具体逻辑。
- 这个设备的“实现”层次结构也可以独立扩展，比如未来可以加入 DVDPlayer (DVD播放器)、Projector (投影仪) 等新设备。这个维度的变化是关于 “设备具体如何执行这些操作”

桥”就是 Remote 类中包含的一个 Device 类型的成员变量 (protected Device device;)。Remote 类并不关心它具体控制的是 TV 还是 Radio。它只知道它持有一个遵循 Device 接口的对象
当客户端 (Client) 调用 remote.togglePower() 时，Remote 类内部的逻辑会去调用它所持有的 device 对象的 enable() 或 disable() 方法。它将高层逻辑（“切换电源”）的请求 委托 (Delegate) 给了实现部分（具体的设备）来完成。
```java
/**
 * 实现部分的接口 (Implementor)
 * 定义了所有设备需要实现的基础操作。
 */
public interface Device {
    boolean isEnabled();
    void enable();
    void disable();
    int getVolume();
    void setVolume(int percent);
    int getChannel();
    void setChannel(int channel);
}

/**
 * 具体的设备实现：电视 (Concrete Implementor)
 */
public class Tv implements Device {
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
        System.out.println("电视: 已开机");
    }

    @Override
    public void disable() {
        on = false;
        System.out.println("电视: 已关机");
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int percent) {
        if (percent > 100) {
            this.volume = 100;
        } else if (percent < 0) {
            this.volume = 0;
        } else {
            this.volume = percent;
        }
        System.out.println("电视: 音量设置为 " + this.volume + "%");
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
        System.out.println("电视: 切换到频道 " + this.channel);
    }
}

/**
 * 具体的设备实现：收音机 (Concrete Implementor)
 */
public class Radio implements Device {
    private boolean on = false;
    private int volume = 20;
    private int channel = 1; // 代表FM频率，简化为整数

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
        System.out.println("收音机: 已开启");
    }

    @Override
    public void disable() {
        on = false;
        System.out.println("收音机: 已关闭");
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int percent) {
        if (percent > 100) {
            this.volume = 100;
        } else if (percent < 0) {
            this.volume = 0;
        } else {
            this.volume = percent;
        }
        System.out.println("收音机: 音量设置为 " + this.volume + "%");
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
        System.out.println("收音机: 调频到 FM " + this.channel);
    }
}


/**
 * 抽象部分 (Abstraction)
 * 定义了遥控器的高层控制逻辑，并通过一个Device引用与实现部分连接。
 */
public class Remote {
    // 使用 protected 使得子类可以访问，这就是“桥”
    protected Device device;

    public Remote(Device device) {
        this.device = device;
    }

    public void togglePower() {
        System.out.println("遥控器: 按下电源键");
        if (device.isEnabled()) {
            device.disable();
        } else {
            device.enable();
        }
    }

    public void volumeDown() {
        System.out.println("遥控器: 按下音量减小键");
        device.setVolume(device.getVolume() - 10);
    }

    public void volumeUp() {
        System.out.println("遥控器: 按下音量增大键");
        device.setVolume(device.getVolume() + 10);
    }

    public void channelDown() {
        System.out.println("遥控器: 按下频道减小键");
        device.setChannel(device.getChannel() - 1);
    }

    public void channelUp() {
        System.out.println("遥控器: 按下频道增大键");
        device.setChannel(device.getChannel() + 1);
    }
}


/**
 * 精确抽象 (Refined Abstraction)
 * 继承并扩展了基础遥控器的功能。
 */
public class AdvancedRemote extends Remote {
    public AdvancedRemote(Device device) {
        // 调用父类的构造函数来建立桥接
        super(device);
    }

    public void mute() {
        System.out.println("高级遥控器: 按下静音键");
        device.setVolume(0);
    }
}

public class BridgePatternDemo {
    public static void main(String[] args) {
        System.out.println("--- 测试基础遥控器和电视 ---");
        Device tv = new Tv();
        Remote basicRemote = new Remote(tv);
        basicRemote.togglePower(); // 开机
        basicRemote.volumeUp();    // 音量增大
        basicRemote.channelUp();   // 频道增加
        basicRemote.togglePower(); // 关机

        System.out.println("\n==============================\n");

        System.out.println("--- 测试高级遥控器和收音机 ---");
        Device radio = new Radio();
        // 注意，这里我们用了高级遥控器 AdvancedRemote
        AdvancedRemote advancedRemote = new AdvancedRemote(radio);
        advancedRemote.togglePower(); // 开机
        advancedRemote.volumeUp();    // 音量增大
        advancedRemote.mute();        // 使用高级遥控器特有的静音功能
        advancedRemote.togglePower(); // 关机
    }
}


```


### 迭代器模式
迭代器模式其实就是cpp上的迭代器和java中的迭代器那样的模式
![Pasted image 20251118162418.png|400](/img/user/accessory/Pasted%20image%2020251118162418.png)
1. **迭代器** （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。
2. **具体迭代器** （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。
3. **集合** （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。
4. **具体集合** （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。
5. **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。

eg: 迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器
![Pasted image 20251118162736.png|400](/img/user/accessory/Pasted%20image%2020251118162736.png)
当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。
使用该模式可以减少程序中重复的遍历代码。
如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。
符合单一职责原则
符合开闭原则

### 访问者模式
将数据结构与数据操作分离。使得你可以在不改变数据结构（类）的前提下，定义作用于这些元素的新操作。
![Pasted image 20251120155646.png|400](/img/user/accessory/Pasted%20image%2020251120155646.png)

```java
interface Visitor {
    void visit(Book book);
    void visit(Fruit fruit);
}
```

```java
// 抽象元素
interface Item {
    void accept(Visitor v);
    double getPrice();
}

// 具体元素：书
class Book implements Item {
    private double price;
    public Book(double price) { this.price = price; }
    public double getPrice() { return price; }

    @Override
    public void accept(Visitor v) {
        // 关键！双重分派的第二步：
        // 把“自己（this）”交给 visitor，
        // 这样 visitor 就知道现在访问的是 Book 而不是 Fruit。
        v.visit(this); 
    }
}

// 具体元素：水果
class Fruit implements Item {
    private double price;
    private double weight;
    public Fruit(double price, double weight) { 
        this.price = price; 
        this.weight = weight;
    }
    public double getPrice() { return price; }
    public double getWeight() { return weight; }

    @Override
    public void accept(Visitor v) {
        v.visit(this); // 把自己交给 visitor
    }
}
```

```java
// 访问者1：结账（计算价格）
class CheckoutVisitor implements Visitor {
    private double totalPrice = 0;

    @Override
    public void visit(Book book) {
        // 书打9折
        totalPrice += book.getPrice() * 0.9; 
    }

    @Override
    public void visit(Fruit fruit) {
        // 水果按重量计算运费等逻辑...
        totalPrice += fruit.getPrice() * fruit.getWeight();
    }
    
    public double getTotal() { return totalPrice; }
}

// 访问者2：导出清单（打印XML）
class XmlExportVisitor implements Visitor {
    @Override
    public void visit(Book book) {
        System.out.println("<book price='" + book.getPrice() + "' />");
    }

    @Override
    public void visit(Fruit fruit) {
        System.out.println("<fruit weight='" + fruit.getWeight() + "' />");
    }
}
```

```java
public static void main(String[] args) {
    // 对象结构
    List<Item> cart = new ArrayList<>();
    cart.add(new Book(100));
    cart.add(new Fruit(10, 2.5));

    // 1. 使用结账访问者
    CheckoutVisitor checkout = new CheckoutVisitor();
    for (Item item : cart) {
        item.accept(checkout); // 双重分派入口
    }
    System.out.println("总价: " + checkout.getTotal());

    // 2. 使用XML导出访问者（无需修改 Book 或 Fruit 类）
    XmlExportVisitor xmlExport = new XmlExportVisitor();
    for (Item item : cart) {
        item.accept(xmlExport);
    }
}
```

课上案例
![Pasted image 20251121161859.png](/img/user/accessory/Pasted%20image%2020251121161859.png)

![Pasted image 20251121161935.png](/img/user/accessory/Pasted%20image%2020251121161935.png)


### 命令模式
**命令模式**是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。
![Pasted image 20251118164910.png|500](/img/user/accessory/Pasted%20image%2020251118164910.png)
![Pasted image 20251118165038.png|450](/img/user/accessory/Pasted%20image%2020251118165038.png)
1. **发送者** （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。
2. **命令** （Command） 接口通常仅声明一个执行命令的方法。
3. **具体命令** （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。
4. **接收者** （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。
5. **客户端** （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。

![Pasted image 20251118165130.png|450](/img/user/accessory/Pasted%20image%2020251118165130.png)

符合单一职责原则
符合开闭原则

![Pasted image 20251120214004.png](/img/user/accessory/Pasted%20image%2020251120214004.png)

### 中介者模式
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
![Pasted image 20251119095838.png|450](/img/user/accessory/Pasted%20image%2020251119095838.png)
1. 组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。
2. 中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。
3. 具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。
4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。
 
对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。
eg:
![Pasted image 20251119102133.png|400](/img/user/accessory/Pasted%20image%2020251119102133.png)
Mediator中定义了与Component通信的标准方法
```java
/**
 * 中介者接口声明了一个能让组件将各种事件通知给中介者的方法。
 * 中介者可对这些事件做出响应并将执行工作传递给其他组件。
 */
public interface Mediator {
    void notify(Component sender, String event);
}
```

Compoent基类和具体时间，他们都持有一个中介者的引用，并通过它来发送通知
```java
/**
 * 组件会使用中介者接口与中介者进行交互。
 * 它们不知道其他组件的存在，只有一个交流渠道，那就是中介者。
 */
public abstract class Component {
    protected Mediator dialog;

    public Component(Mediator dialog) {
        this.dialog = dialog;
    }

    // 模拟点击事件，通知中介者
    public void click() {
        dialog.notify(this, "click");
    }

    // 模拟按键事件，通知中介者
    public void keypress() {
        dialog.notify(this, "keypress");
    }
}

/**
 * 具体组件之间无法直接进行交流。
 */
class Button extends Component {
    public Button(Mediator dialog) {
        super(dialog);
    }
    // Button特有的属性和方法可以在这里添加, e.g., setText, setEnabled, etc.
}

class Textbox extends Component {
    private String text = "";

    public Textbox(Mediator dialog) {
        super(dialog);
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
        System.out.println("文本框内容更新为: " + text);
    }
}

class Checkbox extends Component {
    public boolean checked = false;

    public Checkbox(Mediator dialog) {
        super(dialog);
    }

    // Checkbox特有的check方法
    public void check() {
        this.checked = !this.checked;
        dialog.notify(this, "check");
    }
}```
 ConcreteMediator (具体中介者)这是模式的核心。`AuthenticationDialog` 类实现了 `Mediator` 接口，并包含了所有复杂的交互逻辑。
```java
/**
 * 具体中介者类可解开各组件之间相互交叉的连接关系，并将复杂的交互逻辑转移到自身。
 */
public class AuthenticationDialog implements Mediator {
    private String title;
    private Checkbox loginOrRegisterChkBx;
    private Textbox loginUsername, loginPassword;
    private Textbox registrationUsername, registrationPassword, registrationEmail;
    private Button okBtn, cancelBtn;

    public AuthenticationDialog() {
        // 在构造函数中创建所有组件对象，并将当前中介者(this)传递给其构造函数以建立连接。
        System.out.println("认证对话框已创建。");
        this.loginOrRegisterChkBx = new Checkbox(this);
        this.loginUsername = new Textbox(this);
        this.loginPassword = new Textbox(this);
        this.registrationUsername = new Textbox(this);
        this.registrationPassword = new Textbox(this);
        this.registrationEmail = new Textbox(this);
        this.okBtn = new Button(this);
        this.cancelBtn = new Button(this);

        // 初始状态为登录
        this.title = "登录";
        this.loginOrRegisterChkBx.checked = true;
        System.out.println("--- 初始状态 ---");
        System.out.println("窗口标题: " + this.title);
        System.out.println("显示登录表单组件。");
        System.out.println("隐藏注册表单组件。");
        System.out.println("-----------------");
    }

    /**
     * 当组件中有事件发生时，它会通知中介者。
     * 中介者接收到通知后可自行处理，也可将请求传递给另一个组件。
     * @param sender 发出通知的组件
     * @param event 事件类型
     */
    @Override
    public void notify(Component sender, String event) {
        System.out.println("\n[中介者收到通知] -> 来自: " + sender.getClass().getSimpleName() + ", 事件: " + event);

        // 当“登录或注册”复选框状态改变时
        if (sender == loginOrRegisterChkBx && "check".equals(event)) {
            if (loginOrRegisterChkBx.checked) {
                this.title = "登录";
                System.out.println("窗口标题更新为: " + this.title);
                System.out.println("显示登录表单组件。");
                System.out.println("隐藏注册表单组件。");
            } else {
                this.title = "注册";
                System.out.println("窗口标题更新为: " + this.title);
                System.out.println("显示注册表单组件。");
                System.out.println("隐藏登录表单组件。");
            }
        }

        // 当“确定”按钮被点击时
        if (sender == okBtn && "click".equals(event)) {
            if (loginOrRegisterChkBx.checked) {
                System.out.println("执行登录逻辑...");
                // 模拟：尝试找到使用登录信息的用户。
                String username = loginUsername.getText();
                String password = loginPassword.getText();
                System.out.println("尝试使用 用户名: " + username + ", 密码: " + password + " 登录。");
                // 模拟登录失败
                if (username.isEmpty() || password.isEmpty()) {
                    System.out.println("错误：用户名或密码不能为空！在登录字段上方显示错误信息。");
                } else {
                    System.out.println("登录成功！");
                }
            } else {
                System.out.println("执行注册逻辑...");
                // 1. 使用注册字段中的数据创建用户账号。
                // 2. 完成用户登录工作。
                System.out.println("使用注册信息创建新用户并登录...");
                System.out.println("注册成功并已登录！");
            }
        }
    }
    
    // 为了方便外部模拟，提供组件的getter方法
    public Checkbox getLoginOrRegisterChkBx() { return loginOrRegisterChkBx; }
    public Button getOkBtn() { return okBtn; }
    public Textbox getLoginUsername() { return loginUsername; }
    public Textbox getLoginPassword() { return loginPassword; }
}
```

client客户端
```java
public class Client {
    public static void main(String[] args) {
        // 1. 创建中介者对象，它会自动初始化所有组件
        AuthenticationDialog dialog = new AuthenticationDialog();

        // --- 模拟场景1: 用户切换到注册页面 ---
        System.out.println("\n======= 场景1: 用户切换到注册页面 =======");
        // 用户点击了“登录或注册”复选框，从“登录”切换到“注册”
        dialog.getLoginOrRegisterChkBx().check();
        
        // --- 模拟场景2: 用户在登录页面尝试登录 ---
        System.out.println("\n======= 场景2: 用户尝试登录 =======");
        // 用户又切回了登录页面
        dialog.getLoginOrRegisterChkBx().check();
        
        // 用户输入用户名和密码
        dialog.getLoginUsername().setText("admin");
        dialog.getLoginPassword().setText("12345");
        
        // 用户点击“确定”按钮
        dialog.getOkBtn().click();
        
        // --- 模拟场景3: 用户尝试用空信息登录 ---
        System.out.println("\n======= 场景3: 用户尝试用空信息登录 =======");
        dialog.getLoginUsername().setText("");
        dialog.getLoginPassword().setText("");
        dialog.getOkBtn().click();

    }
}
```

当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式
当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。
如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。
符合单一职责原则
符合开闭原则

课上eg：
![Pasted image 20251121160854.png](/img/user/accessory/Pasted%20image%2020251121160854.png)


### 策略模式
策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。
![Pasted image 20251119102826.png|400](/img/user/accessory/Pasted%20image%2020251119102826.png)
1. 上下文 （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。
2. 策略 （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。
3. 具体策略 （Concrete Strategies） 实现了上下文所用算法的各种不同变体。
4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。
5. 客户端 （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。

Starategy接口，声明了各种算法各个版本共有的操作
```java
/**
 * 策略接口声明了某个算法各个不同版本间所共有的操作。
 * 上下文会使用该接口来调用由具体策略定义的算法。
 */
public interface Strategy {
    int execute(int a, int b);
}
```

ConcreteStrategy具体策略类： 各种策略算法
```java
/**
 * 具体策略会在遵循策略基础接口的情况下实现算法。
 * 该接口实现了它们在上下文中的互换性。
 */
class ConcreteStrategyAdd implements Strategy {
    @Override
    public int execute(int a, int b) {
        System.out.println("执行加法策略...");
        return a + b;
    }
}

class ConcreteStrategySubtract implements Strategy {
    @Override
    public int execute(int a, int b) {
        System.out.println("执行减法策略...");
        return a - b;
    }
}

class ConcreteStrategyMultiply implements Strategy {
    @Override
    public int execute(int a, int b) {
        System.out.println("执行乘法策略...");
        return a * b;
    }
}
```

Context: 持有一个Strategy类型的引用但并不知道引用的具体类型是哪种具体的算法 通过setStrategy给他设定是具体哪种策略 然后执行对应的execute.
```java
/**
 * 上下文定义了客户端关注的接口。
 */
public class Context {
    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。
    // 上下文必须通过策略接口来与所有策略进行交互。
    private Strategy strategy;

    /**
     * 上下文通常会通过构造函数来接收策略对象，
     * 同时还提供设置器以便在运行时切换策略。
     * @param strategy 要使用的策略
     */
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    /**
     * 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。
     * @param a 第一个操作数
     * @param b 第二个操作数
     * @return 策略执行后的结果
     */
    public int executeStrategy(int a, int b) {
        if (strategy == null) {
            throw new IllegalStateException("策略未设置，请先调用 setStrategy()。");
        }
        return strategy.execute(a, b);
    }
}
```
client
```java
import java.util.Scanner;

/**
 * 客户端代码会选择具体策略并将其传递给上下文。
 * 客户端必须知晓策略之间的差异，才能做出正确的选择。
 */
public class ExampleApplication {
    public static void main(String[] args) {
        // 创建上下文对象
        Context context = new Context();

        Scanner scanner = new Scanner(System.in);

        System.out.print("请输入第一个数字: ");
        int firstNumber = scanner.nextInt();

        System.out.print("请输入第二个数字: ");
        int secondNumber = scanner.nextInt();

        System.out.print("请输入期望进行的行为 (add, subtract, multiply): ");
        String action = scanner.next();

        scanner.close();

        // 客户端根据用户的输入决定使用哪种策略
        if ("add".equalsIgnoreCase(action)) {
            context.setStrategy(new ConcreteStrategyAdd());
        } else if ("subtract".equalsIgnoreCase(action)) {
            context.setStrategy(new ConcreteStrategySubtract());
        } else if ("multiply".equalsIgnoreCase(action)) {
            context.setStrategy(new ConcreteStrategyMultiply());
        } else {
            System.out.println("未知的行为！");
            return;
        }

        // 上下文执行选定的策略
        int result = context.executeStrategy(firstNumber, secondNumber);

        // 打印结果
        System.out.println("结果是: " + result);
    }
}
```

策略方法的核心就是 有Strategy接口规定具体策略需要实现的方法，有具体的策略类实现不同的算法。客户端通过context设置不同的策略类从而实现不同策略类的算法。

课上eg:
![Pasted image 20251121160258.png](/img/user/accessory/Pasted%20image%2020251121160258.png)

符合开闭原则

练习:
![Pasted image 20251121160537.png|400](/img/user/accessory/Pasted%20image%2020251121160537.png)

实现一个会员Member接口，里面有个打折方法，各个具体的会员类分别实现打折方法。Context中要有一个成员变量是Member，然后要有一个方法是setMember 然后才能调用具体会员类中的具体打折方法


### 状态模式
状态模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类
![Pasted image 20251120152548.png|450](/img/user/accessory/Pasted%20image%2020251120152548.png)
1. 上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。
2. 状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。
3. 具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。
4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

eg: 订单的三种状态: 待支付，已支付，已发货
首先定义抽象状态接口，并实现三种具体的状态
```java
interface OrderState {
    void handlePay(OrderContext ctx);
    void handleCancel(OrderContext ctx);
}

class PendingState implements OrderState {
    @Override
    public void handlePay(OrderContext ctx) {
        System.out.println("支付成功！");
        // 核心：状态流转，把自己切换成已支付状态
        ctx.setState(new PaidState()); 
    }

    @Override
    public void handleCancel(OrderContext ctx) {
        System.out.println("订单直接取消。");
    }
}

class PaidState implements OrderState {
    @Override
    public void handlePay(OrderContext ctx) {
        System.out.println("您已经付过款了，请勿重复支付。");
    }

    @Override
    public void handleCancel(OrderContext ctx) {
        System.out.println("发起退款流程...");
    }
}


```

定义ordercontext持有orderstate当前状态,并且能够修改状态
```java
class OrderContext {
    // 持有当前状态
    private OrderState currentState;

    public OrderContext() {
        // 初始状态
        this.currentState = new PendingState(); 
    }

    public void setState(OrderState state) {
        this.currentState = state;
    }

    // 动作委托给当前状态去处理
    public void pay() {
        currentState.handlePay(this);
    }

    public void cancel() {
        currentState.handleCancel(this);
    }
}
```
client
```java
public static void main(String[] args) {
    OrderContext order = new OrderContext();
    
    order.pay();    // 输出：支付成功！(内部状态自动变为 PaidState)
    order.pay();    // 输出：您已经付过款了...
    order.cancel(); // 输出：发起退款流程...
}
```

eg2:
![Pasted image 20251121155038.png](/img/user/accessory/Pasted%20image%2020251121155038.png)

符合单一职责原则
符合开闭原则

练习
![Pasted image 20251121155341.png](/img/user/accessory/Pasted%20image%2020251121155341.png)

Account实现打电话方法扣除花费，然后调用状态state的checkState， checkState在三种状态具体类中实现，主要就是在这个状态里类里new一个别的状态
### 观察者模式
定义对象间的一种 一对多（One-to-Many） 的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
就像我们在b站上关注了一个up主，up主更新，所有人都会得到推送
![Pasted image 20251120153509.png|450](/img/user/accessory/Pasted%20image%2020251120153509.png)
1. 发布者 （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。
2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。
3. 订阅者 （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 `update`更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。
4. 具体订阅者 （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。
5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。
6. 客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

```java
import java.util.ArrayList;
import java.util.List;

// ==========================================
// 3. Subscriber Interface (对应图中标注 3)
// ==========================================
interface Subscriber {
    // 图中是 update(context)，这里 context 就是 Publisher 本身
    void update(Publisher publisher); 
}

// ==========================================
// 1. Publisher (对应图中标注 1)
// ==========================================
class Publisher {
    // 维护订阅者列表
    private List<Subscriber> subscribers = new ArrayList<>();
    
    // mainState (对应图中标注 1 的 mainState)
    private String productName;
    private boolean inStock = false; // 核心状态：是否有货

    public Publisher(String name) {
        this.productName = name;
    }

    public void subscribe(Subscriber s) {
        subscribers.add(s);
    }

    public void unsubscribe(Subscriber s) {
        subscribers.remove(s);
    }

    public boolean isInStock() {
        return inStock;
    }

    public String getProductName() {
        return productName;
    }

    // 对应图中标注 2 (上面的框)：通知逻辑
    public void notifySubscribers() {
        for (Subscriber s : subscribers) {
            // 关键点：s.update(this) -> 把自己传过去
            s.update(this); 
        }
    }

    // 对应图中标注 2 (下面的框)：业务逻辑
    public void restock() {
        System.out.println("【商城】: " + productName + " 补货上架了！");
        this.inStock = true; // mainState = newState
        notifySubscribers(); // 触发通知
    }
}

// ==========================================
// 4. Concrete Subscribers (对应图中标注 4)
// ==========================================

// 具体订阅者A：普通玩家
class Gamer implements Subscriber {
    private String name;

    public Gamer(String name) {
        this.name = name;
    }

    @Override
    // 对应图中标注 5：具体的响应逻辑
    public void update(Publisher publisher) {
        if (publisher.isInStock()) {
            System.out.println(name + " (玩家):收到通知，" + publisher.getProductName() + " 有货了！我要买！");
        }
    }
}

// 具体订阅者B：黄牛
class Scalper implements Subscriber {
    @Override
    // 对应图中标注 5：具体的响应逻辑
    public void update(Publisher publisher) {
        if (publisher.isInStock()) {
            System.out.println("黄牛 (脚本): 检测到 " + publisher.getProductName() + " 上架，正在启动自动抢购程序...");
        }
    }
}

// ==========================================
// 6. Client (对应图中标注 6)
// ==========================================
public class Client {
    public static void main(String[] args) {
        // 1. 创建 Publisher
        Publisher rtx4090 = new Publisher("RTX 4090 显卡");

        // 2. 创建具体 Subscribers
        Subscriber player1 = new Gamer("小明");
        Subscriber player2 = new Gamer("小红");
        Subscriber scalper = new Scalper();

        // 3. 注册 (subscribe)
        rtx4090.subscribe(player1);
        rtx4090.subscribe(player2);
        rtx4090.subscribe(scalper);

        // 4. 触发业务逻辑
        System.out.println("--- 此时显卡还没货 ---");
        
        // 这一步对应图中标注 2 (mainBusinessLogic)
        // 状态改变 -> 自动通知所有订阅者
        rtx4090.restock(); 
    }
}
```