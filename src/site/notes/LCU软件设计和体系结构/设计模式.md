---
{"created":"2025-11-17T10:31","updated":"2025-11-18T15:37","dg-publish":true,"permalink":"/LCU软件设计和体系结构/设计模式/","dgPassFrontmatter":true,"noteIcon":""}
---

### Overview
需要学的设计模式
![Pasted image 20251117113655.png|500](/img/user/accessory/Pasted%20image%2020251117113655.png)

### 简单工厂模式
![Pasted image 20251117105533.png|500](/img/user/accessory/Pasted%20image%2020251117105533.png)
简单工厂模式比较简单，说白了就是一个专门的工厂类，根据传入的参数，来决定创建哪一种产品类的实例
其实从这句话里也能得出一些信息，首先要有一个工厂类，要有一个create方法，create方法中要有if判断来决定返回什么产品。要想返回不同产品类的实例，那就只能让Factory返回一个抽象产品类或接口，然后真正的产品类继承或实现
如果把这个创建的方法变成静态的，就是静态简单工厂模式
![Pasted image 20251117105949.png|500](/img/user/accessory/Pasted%20image%2020251117105949.png)

优点: 职责分离，工厂类负责创建对象，客户端使用对象，符合单一职责原则
缺点：不符合开闭原则。当增加新的产品时，必须修改类中的判断逻辑，违背了“对修改关闭”的原则
### 工厂方法模式
工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
这里的核心是为了解决简单工厂不符合开闭原则的问题，这里引入了子类这种具体的工厂将原来工厂中的判断逻辑分开了。
客户端需要什么产品去找对应的工厂
![Pasted image 20251117110602.png|500](/img/user/accessory/Pasted%20image%2020251117110602.png)

![Pasted image 20251117110648.png|500](/img/user/accessory/Pasted%20image%2020251117110648.png)

```java
// 1. 抽象产品
interface Chart {
    void display();
}

// 2. 具体产品
class PieChart implements Chart {
    public void display() { System.out.println("显示饼图"); }
}

class LineChart implements Chart {
    public void display() { System.out.println("显示折线图"); }
}


// 3. 抽象工厂
interface ChartFactory {
    // 这就是“工厂方法”，返回一个抽象产品
    Chart createChart(); 
}

// 4. 具体工厂
class PieChartFactory implements ChartFactory {
    @Override
    public Chart createChart() {
        System.out.println("饼图工厂：正在生产饼图...");
        return new PieChart();
    }
}

class LineChartFactory implements ChartFactory {
    @Override
    public Chart createChart() {
        System.out.println("折线图工厂：正在生产折线图...");
        return new LineChart();
    }
}

//5. 客户端
public class Client {
    public static void main(String[] args) {
        // 我需要一个饼图，所以我找到饼图工厂
        ChartFactory pieFactory = new PieChartFactory();
        Chart pieChart = pieFactory.createChart();
        pieChart.display();

        System.out.println("-----------------");

        // 我需要一个折线图，所以我找到折线图工厂
        ChartFactory lineFactory = new LineChartFactory();
        Chart lineChart = lineFactory.createChart();
        lineChart.display();
    }
}

```

当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。
如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法
如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。
符合单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护
符合开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。
缺点：应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。
**与其他模式的关系**
抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。

### 抽象工厂模式
![Pasted image 20251117112130.png|400](/img/user/accessory/Pasted%20image%2020251117112130.png)
这里的核心是抽象工厂模式与简单工厂和工厂方法（它们都只专注于创建**一种**产品）不同，抽象工厂模式的重点是创建**一整套（一个家族）相互关联的产品**，而无需指定它们的具体类。

首先，要给每种产品提供明确的结构
![Pasted image 20251117112445.png|300](/img/user/accessory/Pasted%20image%2020251117112445.png)

```java
// 抽象产品 1: 椅子
interface Chair {
    void showStyle();
}

// 抽象产品 2: 沙发
interface Sofa {
    void showStyle();
}

// 抽象产品 3: 咖啡桌
interface CoffeeTable {
    void showStyle();
}


// --- 维多利亚产品族 ---
class VictorianChair implements Chair {
    public void showStyle() { System.out.println("这是一把维多利亚风格的椅子。"); }
}
class VictorianSofa implements Sofa {
    public void showStyle() { System.out.println("这是一个维多利亚风格的沙发。"); }
}
class VictorianCoffeeTable implements CoffeeTable {
    public void showStyle() { System.out.println("这是一个维多利亚风格的咖啡桌。"); }
}

// --- 现代产品族 ---
class ModernChair implements Chair {
    public void showStyle() { System.out.println("这是一把现代风格的椅子。"); }
}
class ModernSofa implements Sofa {
    public void showStyle() { System.out.println("这是一个现代风格的沙发。"); }
}
class ModernCoffeeTable implements CoffeeTable {
    public void showStyle() { System.out.println("这是一个现代风格的咖啡桌。"); }
}

```

定义抽象工厂创建所有类型产品，然后创建具体工厂，每种工厂对应一种风格
![Pasted image 20251117112706.png|400](/img/user/accessory/Pasted%20image%2020251117112706.png)

```java
// 抽象工厂接口
interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
    CoffeeTable createCoffeeTable();
}

// 具体工厂 1: 维多利亚家具工厂
class VictorianFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new VictorianChair();
    }
    @Override
    public Sofa createSofa() {
        return new VictorianSofa();
    }
    @Override
    public CoffeeTable createCoffeeTable() {
        return new VictorianCoffeeTable();
    }
}

// 具体工厂 2: 现代家具工厂
class ModernFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new ModernChair();
    }
    @Override
    public Sofa createSofa() {
        return new ModernSofa();
    }
    @Override
    public CoffeeTable createCoffeeTable() {
        return new ModernCoffeeTable();
    }
}


```

客户端
```java
public class Client {
    public static void main(String[] args) {
        System.out.println("--- 客户需要一套维多利亚风格的家具 ---");
        // 1. 选择风格：获取维多利亚家具工厂
        FurnitureFactory victorianFactory = new VictorianFurnitureFactory();

        // 2. 从该工厂获取一套家具
        Chair victorianChair = victorianFactory.createChair();
        Sofa victorianSofa = victorianFactory.createSofa();
        CoffeeTable victorianCoffeeTable = victorianFactory.createCoffeeTable();

        // 3. 验证风格是否统一
        victorianChair.showStyle(); // 输出: 这是一把维多利亚风格的椅子。
        victorianSofa.showStyle();   // 输出: 这是一个维多利亚风格的沙发。
        victorianCoffeeTable.showStyle(); // 输出: 这是一个维多利亚风格的咖啡桌。

        System.out.println("\n--- 客户需要一套现代风格的家具 ---");
        // 1. 切换风格：获取现代家具工厂
        FurnitureFactory modernFactory = new ModernFurnitureFactory();
        
        // 2. 从新工厂获取一套家具
        Chair modernChair = modernFactory.createChair();
        Sofa modernSofa = modernFactory.createSofa();

        // 3. 验证风格
        modernChair.showStyle(); // 输出: 这是一把现代风格的椅子。
        modernSofa.showStyle();  // 输出: 这是一个现代风格的沙发。
    }
}

```
那其实就是这样
![Pasted image 20251117113253.png|400](/img/user/accessory/Pasted%20image%2020251117113253.png)
即
![Pasted image 20251117112758.png|500](/img/user/accessory/Pasted%20image%2020251117112758.png)

### 生成器模式
**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
![Pasted image 20251117151231.png|500](/img/user/accessory/Pasted%20image%2020251117151231.png)
如果创建一个House对象，不同的房子都继承House 这样可能会有很多子类，而且有很多重复的地方
如果不用子类，你可以在House基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题
![Pasted image 20251117151432.png|400](/img/user/accessory/Pasted%20image%2020251117151432.png)
会出现绝大多数参数没用的情况
解决方法，就是使用Builder，把每一个组件都抽取出来，通过.buildWalls()方法来创建墙
![Pasted image 20251117151505.png|400](/img/user/accessory/Pasted%20image%2020251117151505.png)
当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。
![Pasted image 20251117151636.png|400](/img/user/accessory/Pasted%20image%2020251117151636.png)

```java
// 这是我们的一个产品：一个复杂的实体房子对象
public class House {
    private int windows;
    private int doors;
    private int rooms;
    private boolean hasGarage;
    private boolean hasSwimmingPool;
    private boolean hasGarden;

    // 为了简洁，我们省略了所有setter和getter，只留下一个toString()来展示结果
    @Override
    public String toString() {
        return "实体房子: \n" +
                "  窗户=" + windows + "\n" +
                "  门=" + doors + "\n" +
                "  房间=" + rooms + "\n" +
                "  是否有车库=" + hasGarage + "\n" +
                "  是否有泳池=" + hasSwimmingPool + "\n" +
                "  是否有花园=" + hasGarden + "\n";
    }
    
    // setter们会被Builder调用
    public void setWindows(int windows) { this.windows = windows; }
    public void setDoors(int doors) { this.doors = doors; }
    public void setRooms(int rooms) { this.rooms = rooms; }
    public void setHasGarage(boolean hasGarage) { this.hasGarage = hasGarage; }
    public void setHasSwimmingPool(boolean hasSwimmingPool) { this.hasSwimmingPool = hasSwimmingPool; }
    public void setHasGarden(boolean hasGarden) { this.hasGarden = hasGarden; }
}


// 这是我们的另一个产品：一个描述房子规格的蓝图/手册
public class HouseBlueprint {
    private StringBuilder description = new StringBuilder();

    public void addPart(String partDescription) {
        description.append(partDescription).append("\n");
    }

    @Override
    public String toString() {
        return "房子蓝图/手册:\n" + description.toString();
    }
}


// 对应UML图中的 <<interface>> Builder
public interface IHouseBuilder {
    void reset();
    void buildWindows(int number);
    void buildDoors(int number);
    void buildRooms(int number);
    void buildGarage();
    void buildSwimmingPool();
    void buildGarden();
}

// 对应UML图中的 Builder1
public class HouseBuilder implements IHouseBuilder {
    private House house;

    public HouseBuilder() {
        this.reset();
    }
    
    @Override
    public void reset() {
        this.house = new House();
    }

    @Override
    public void buildWindows(int number) {
        house.setWindows(number);
    }

    @Override
    public void buildDoors(int number) {
        house.setDoors(number);
    }

    @Override
    public void buildRooms(int number) {
        house.setRooms(number);
    }

    @Override
    public void buildGarage() {
        house.setHasGarage(true);
    }

    @Override
    public void buildSwimmingPool() {
        house.setHasSwimmingPool(true);
    }

    @Override
    public void buildGarden() {
        house.setHasGarden(true);
    }

    // 这是获取最终产品的方法
    public House getResult() {
        return this.house;
    }
}

// 对应UML图中的 Builder2
public class HouseBlueprintBuilder implements IHouseBuilder {
    private HouseBlueprint blueprint;

    public HouseBlueprintBuilder() {
        this.reset();
    }

    @Override
    public void reset() {
        this.blueprint = new HouseBlueprint();
    }

    @Override
    public void buildWindows(int number) {
        blueprint.addPart("添加 " + number + " 个窗户的施工说明。");
    }

    @Override
    public void buildDoors(int number) {
        blueprint.addPart("添加 " + number + " 个门的施工说明。");
    }

    @Override
    public void buildRooms(int number) {
        blueprint.addPart("规划并建造 " + number + " 个房间。");
    }

    @Override
    public void buildGarage() {
        blueprint.addPart("添加车库建造规范：地基、尺寸、材料等。");
    }

    @Override
    public void buildSwimmingPool() {
        blueprint.addPart("添加泳池建造规范：挖掘、防水、过滤系统等。");
    }

    @Override
    public void buildGarden() {
        blueprint.addPart("添加花园设计和施工说明：土壤、植物选择、灌溉系统。");
    }

    // 获取最终产品
    public HouseBlueprint getResult() {
        return this.blueprint;
    }
}


// 对应UML图中的 Director
public class Director {
    // 指挥建造一个“家庭别墅” (House with garden)
    public void buildFamilyVilla(IHouseBuilder builder) {
        builder.reset();
        builder.buildDoors(3);
        builder.buildWindows(6);
        builder.buildRooms(5);
        builder.buildGarage();
        builder.buildGarden();
    }

    // 指挥建造一个“豪华泳池别墅” (House with swimming pool)
    public void buildLuxuryPoolVilla(IHouseBuilder builder) {
        builder.reset();
        builder.buildDoors(5);
        builder.buildWindows(10);
        builder.buildRooms(8);
        builder.buildGarage();
        builder.buildSwimmingPool();
    }
}

//客户端
public class Demo {
    public static void main(String[] args) {
        // 创建一个项目经理
        Director director = new Director();

        System.out.println("--- 建造一栋家庭别墅 ---");

        // 1. 建造实体房子
        HouseBuilder houseBuilder = new HouseBuilder();
        director.buildFamilyVilla(houseBuilder); // 项目经理指挥施工队
        House familyVilla = houseBuilder.getResult(); // 从施工队获取成果
        System.out.println("建造完成的实体房子：");
        System.out.println(familyVilla);

        // 2. 使用完全相同的流程，生成对应的蓝图
        HouseBlueprintBuilder blueprintBuilder = new HouseBlueprintBuilder();
        director.buildFamilyVilla(blueprintBuilder); // 同一个项目经理，用同样的流程指挥
        HouseBlueprint familyVillaBlueprint = blueprintBuilder.getResult(); // 从蓝图团队获取成果
        System.out.println("生成的房子蓝图：");
        System.out.println(familyVillaBlueprint);
        
        System.out.println("========================================\n");
        
        System.out.println("--- 建造一栋豪华泳池别墅 ---");
        
        // 3. 建造豪华泳池别墅的实体
        director.buildLuxuryPoolVilla(houseBuilder); // 复用houseBuilder
        House luxuryVilla = houseBuilder.getResult();
        System.out.println("建造完成的实体房子：");
        System.out.println(luxuryVilla);
        
        // 4. 生成豪华泳池别墅的蓝图
        director.buildLuxuryPoolVilla(blueprintBuilder); // 复用blueprintBuilder
        HouseBlueprint luxuryVillaBlueprint = blueprintBuilder.getResult();
        System.out.println("生成的房子蓝图：");
        System.out.println(luxuryVillaBlueprint);
    }
}

```
使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。
当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。

符合单一职责原则

### 单例模式
单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
![Pasted image 20251117153711.png|400](/img/user/accessory/Pasted%20image%2020251117153711.png)
```java
public class Emperor {
    // 1. 类加载时就立即创建实例，所以是“饿汉”
    private static final Emperor instance = new Emperor();

    // 2. 构造方法私有化，防止外部创建实例
    private Emperor() {
        System.out.println("一位皇帝诞生了！ (饿汉式)");
    }

    // 3. 提供全局访问点
    public static Emperor getInstance() {
        return instance;
    }

    // 皇帝可以处理政务
    public void handleGovernmentAffairs(String minister) {
        System.out.println("皇帝正在与 " + minister + " 商议国事...");
    }
}

```

违反了单一职责原则

### 组合模式
组合模式让你用“树形结构”来表示整体-部分的层级关系，让客户端“一致地”处理单个对象和对象集合。
![Pasted image 20251118140735.png|300](/img/user/accessory/Pasted%20image%2020251118140735.png)
1. **组件** （Component） 接口描述了树中简单项目和复杂项目所共有的操作。
2. **叶节点** （Leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。
3. **容器** （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。
4. **客户端** （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。

```text
考研复习
 ├── 高数
 │    ├── 第一章：函数极限
 │    ├── 第二章：一元微分学
 │    └── 第三章：不定积分
 ├── 英语
 │    └── 完型 & 阅读
 └── 专业课
      ├── 基础部分
      └── 算法部分

```

```java
// Compoent
interface Task {
    void show(int indent);
}

// Leaf: 不可再分的任务
class SimpleTask implements Task {
    private String name;

    public SimpleTask(String name) {
        this.name = name;
    }

    @Override
    public void show(int indent) {
        System.out.println(" ".repeat(indent) + "- " + name);
    }
}


// Composite: 包含子任务的大人物
import java.util.ArrayList;
import java.util.List;

class CompositeTask implements Task {
    private String name;
    private List<Task> children = new ArrayList<>();

    public CompositeTask(String name) {
        this.name = name;
    }

    public void add(Task t) {
        children.add(t);
    }

    @Override
    public void show(int indent) {
        System.out.println(" ".repeat(indent) + "[ " + name + " ]");
        for (Task t : children) {
            t.show(indent + 2);
        }
    }
}


//客户端使用
public class Main {
    public static void main(String[] args) {
        CompositeTask exam = new CompositeTask("考研复习");
        CompositeTask math = new CompositeTask("高数");
        CompositeTask english = new CompositeTask("英语");
        CompositeTask cs = new CompositeTask("专业课");

        // 高数子任务
        math.add(new SimpleTask("第一章：函数极限"));
        math.add(new SimpleTask("第二章：一元微分学"));
        math.add(new SimpleTask("第三章：不定积分"));

        // 英语
        english.add(new SimpleTask("完型 & 阅读"));

        // 专业课
        cs.add(new SimpleTask("基础部分"));
        cs.add(new SimpleTask("算法部分"));

        // 整体考研任务
        exam.add(math);
        exam.add(english);
        exam.add(cs);

        exam.show(0);
    }
}


```

如果你需要实现树状对象结构， 可以使用组合模式。
如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。

符合开闭原则

### 适配器模式
适配器模式让原本接口不兼容的类能够一起工作，就像给老设备配一个转接头一样
运作方式:
1. 适配器实现与其中一个现有对象兼容的接口。
2. 现有对象可以使用该接口安全地调用适配器方法。
3. 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。

![Pasted image 20251118141844.png|400](/img/user/accessory/Pasted%20image%2020251118141844.png)
1. **客户端** （Client） 是包含当前程序业务逻辑的类。
2. **客户端接口** （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。
3. **服务** （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。
4. **适配器** （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。
5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。

![Pasted image 20251118142300.png|400](/img/user/accessory/Pasted%20image%2020251118142300.png)
```java
// === Client Interface (Target) ===
// 客户端希望使用的接口：getRadius()
public class RoundPeg {
    protected double radius;

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}

// 不是适配器四大角色之一，但作为“客户端逻辑”使用 Target
public class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public boolean fits(RoundPeg peg) {
        return peg.getRadius() <= this.radius;
    }
}

// === Service (Adaptee) ===
// 现有的类，没有 radius，接口不兼容
public class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }
}

// === Adapter ===
// 继承 Target（RoundPeg），包装 Adaptee（SquarePeg）
// 使方钉表现得像圆钉（提供 getRadius()）
public class SquarePegAdapter extends RoundPeg {
    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        super(0);  // 先随便给父类 radius
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        // 将方钉的宽度转换为等效圆的半径（半对角线）
        return peg.getWidth() * Math.sqrt(2) / 2;
    }
}


// === Client ===
// 客户端只认识 RoundPeg（Target），却能使用 SquarePeg（Adaptee）
// 因为我们通过 Adapter 进行了适配
public class Main {
    public static void main(String[] args) {

        RoundHole hole = new RoundHole(5);

        RoundPeg roundPeg = new RoundPeg(5);
        System.out.println(hole.fits(roundPeg)); // true

        SquarePeg smallSqPeg = new SquarePeg(5);
        SquarePeg largeSqPeg = new SquarePeg(10);

        // 适配器让方钉变成“看起来像圆钉”
        SquarePegAdapter smallAdapter = new SquarePegAdapter(smallSqPeg);
        SquarePegAdapter largeAdapter = new SquarePegAdapter(largeSqPeg);

        System.out.println(hole.fits(smallAdapter)); // true
        System.out.println(hole.fits(largeAdapter)); // false
    }
}


```

当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。
符合单一职责原则
符合开闭原则

### 外观模式
外观模式用一个类来简化复杂系统的使用，为用户提供一个更容易调用的统一接口。
当你遇到下面情况时：
- 一个复杂系统有许多子模块，调用方式繁琐
- 你希望给客户端一个更简单的入口
- 想隐藏内部细节，让代码更易用、更可维护

典型用途：
- 封装复杂库（如 FFmpeg、OpenCV）
- 封装复杂业务流程（如支付流程）
- 为旧系统提供友好的“统一入口”

![Pasted image 20251118143325.png|400](/img/user/accessory/Pasted%20image%2020251118143325.png)
1. **外观** （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
2. 创建**附加外观** （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。
4. **客户端** （Client） 使用外观代替对子系统对象的直接调用。

![Pasted image 20251118145323.png|400](/img/user/accessory/Pasted%20image%2020251118145323.png)


```java
//外观提供了进行视频转换的简单接口
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println("VideoConversionFacade: conversion started.");
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println("VideoConversionFacade: conversion completed.");
        return result;
    }
}


//Demo
package refactoring_guru.facade.example;

import refactoring_guru.facade.example.facade.VideoConversionFacade;

import java.io.File;

public class Demo {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo("youtubevideo.ogg", "mp4");
        // ...
    }
}
```

### 桥接模式
![Pasted image 20251118152230.png|400](/img/user/accessory/Pasted%20image%2020251118152230.png)

我们可以将颜色相关的代码抽取到拥有 `红色`和 `蓝色`两个子类的颜色类中， 然后在 `形状`类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 `形状`和 `颜色`之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。

![Pasted image 20251118152307.png|400](/img/user/accessory/Pasted%20image%2020251118152307.png)
1. **抽象部分** （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。
2. **实现部分** （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。
    抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。
3. **具体实现** （Concrete Implementations） 中包括特定于平台的代码。
4. **精确抽象** （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。
5. 通常情况下， **客户端** （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。

![Pasted image 20251118152343.png|400](/img/user/accessory/Pasted%20image%2020251118152343.png)
- Remote (遥控器) 是一个基础遥控器，它定义了高层控制逻辑，比如开关、调节音量、切换频道等。
- AdvancedRemote (高级遥控器) 继承自 Remote，并在其基础上增加了新功能，比如 mute() (静音)。
- 我们可以想象，这个遥控器的“抽象”层次结构可以继续扩展，比如未来可以有 SmartRemote (智能遥控器)，增加语音控制等功能。这个维度的变化是关于 “遥控器有什么样的功能按钮”。

- Device (设备) 是一个接口，它定义了所有设备都应该具备的基础操作，如 isEnabled (是否开启), enable (开启), disable (关闭), getVolume (获取音量) 等。这是底层的、平台相关的具体操作。
- Radio (收音机) 和 TV (电视) 是 Device 接口的具体实现类。它们各自实现了如何开关、如何调节音量等具体逻辑。
- 这个设备的“实现”层次结构也可以独立扩展，比如未来可以加入 DVDPlayer (DVD播放器)、Projector (投影仪) 等新设备。这个维度的变化是关于 “设备具体如何执行这些操作”

桥”就是 Remote 类中包含的一个 Device 类型的成员变量 (protected Device device;)。Remote 类并不关心它具体控制的是 TV 还是 Radio。它只知道它持有一个遵循 Device 接口的对象
当客户端 (Client) 调用 remote.togglePower() 时，Remote 类内部的逻辑会去调用它所持有的 device 对象的 enable() 或 disable() 方法。它将高层逻辑（“切换电源”）的请求 委托 (Delegate) 给了实现部分（具体的设备）来完成。
```java
/**
 * 实现部分的接口 (Implementor)
 * 定义了所有设备需要实现的基础操作。
 */
public interface Device {
    boolean isEnabled();
    void enable();
    void disable();
    int getVolume();
    void setVolume(int percent);
    int getChannel();
    void setChannel(int channel);
}

/**
 * 具体的设备实现：电视 (Concrete Implementor)
 */
public class Tv implements Device {
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
        System.out.println("电视: 已开机");
    }

    @Override
    public void disable() {
        on = false;
        System.out.println("电视: 已关机");
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int percent) {
        if (percent > 100) {
            this.volume = 100;
        } else if (percent < 0) {
            this.volume = 0;
        } else {
            this.volume = percent;
        }
        System.out.println("电视: 音量设置为 " + this.volume + "%");
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
        System.out.println("电视: 切换到频道 " + this.channel);
    }
}

/**
 * 具体的设备实现：收音机 (Concrete Implementor)
 */
public class Radio implements Device {
    private boolean on = false;
    private int volume = 20;
    private int channel = 1; // 代表FM频率，简化为整数

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
        System.out.println("收音机: 已开启");
    }

    @Override
    public void disable() {
        on = false;
        System.out.println("收音机: 已关闭");
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int percent) {
        if (percent > 100) {
            this.volume = 100;
        } else if (percent < 0) {
            this.volume = 0;
        } else {
            this.volume = percent;
        }
        System.out.println("收音机: 音量设置为 " + this.volume + "%");
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
        System.out.println("收音机: 调频到 FM " + this.channel);
    }
}


/**
 * 抽象部分 (Abstraction)
 * 定义了遥控器的高层控制逻辑，并通过一个Device引用与实现部分连接。
 */
public class Remote {
    // 使用 protected 使得子类可以访问，这就是“桥”
    protected Device device;

    public Remote(Device device) {
        this.device = device;
    }

    public void togglePower() {
        System.out.println("遥控器: 按下电源键");
        if (device.isEnabled()) {
            device.disable();
        } else {
            device.enable();
        }
    }

    public void volumeDown() {
        System.out.println("遥控器: 按下音量减小键");
        device.setVolume(device.getVolume() - 10);
    }

    public void volumeUp() {
        System.out.println("遥控器: 按下音量增大键");
        device.setVolume(device.getVolume() + 10);
    }

    public void channelDown() {
        System.out.println("遥控器: 按下频道减小键");
        device.setChannel(device.getChannel() - 1);
    }

    public void channelUp() {
        System.out.println("遥控器: 按下频道增大键");
        device.setChannel(device.getChannel() + 1);
    }
}


/**
 * 精确抽象 (Refined Abstraction)
 * 继承并扩展了基础遥控器的功能。
 */
public class AdvancedRemote extends Remote {
    public AdvancedRemote(Device device) {
        // 调用父类的构造函数来建立桥接
        super(device);
    }

    public void mute() {
        System.out.println("高级遥控器: 按下静音键");
        device.setVolume(0);
    }
}

public class BridgePatternDemo {
    public static void main(String[] args) {
        System.out.println("--- 测试基础遥控器和电视 ---");
        Device tv = new Tv();
        Remote basicRemote = new Remote(tv);
        basicRemote.togglePower(); // 开机
        basicRemote.volumeUp();    // 音量增大
        basicRemote.channelUp();   // 频道增加
        basicRemote.togglePower(); // 关机

        System.out.println("\n==============================\n");

        System.out.println("--- 测试高级遥控器和收音机 ---");
        Device radio = new Radio();
        // 注意，这里我们用了高级遥控器 AdvancedRemote
        AdvancedRemote advancedRemote = new AdvancedRemote(radio);
        advancedRemote.togglePower(); // 开机
        advancedRemote.volumeUp();    // 音量增大
        advancedRemote.mute();        // 使用高级遥控器特有的静音功能
        advancedRemote.togglePower(); // 关机
    }
}


```

