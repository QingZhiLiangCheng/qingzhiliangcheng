---
{"created":"2025-11-18T16:47","updated":"2025-11-20T21:40","dg-publish":true,"permalink":"/LCU软件设计和体系结构/2021级期中考试/","dgPassFrontmatter":true,"noteIcon":""}
---


 1、下列选项中，属于创建型设计模式的是（）
 A、单例（Singleton）B、适配器（Adapter）C、迭代器（Iterator）D、命令（Command）


设计模式一共分类三类，创建型设计模式，结构型设计模式，行为型设计模式
其中单例模式是创建型设计模式。 单例模式的核心就是只能创建一个实例对象
适配器模式是结构型设计模式，他的核心是为长方体增加一个判别方法，使得判断他是否能嵌入原来圆柱体的槽
迭代器模式是行为型模式，主要是定义了遍历一个结构的具体方式
命令模式是行为模式，核心是将请求转换为一个包含与请求相关的所有信息的独立对象

2、下列选项中，描述设计模式的四个基本要素不包括（       ）2分
A、模式名称B、问题描述C、解决方案D、实现

描述设计模式的四个基本要素：模式名称、问题描述、解决方案、效果


组件应该只承担一个职责，即只有一个原因可以引起它变化。描述的设计原则是（     ）2分
A、开闭原则（ocp）B、单一职责原则（srp）C、迪米特原则（dip）D、理氏替换原则（lsp）

下列关于开闭原则（ocp）的描述正确的是（   ）2分
A、对抽象开放，对实现封闭、
B、对实现开放，对实现封闭
C、对扩展开放，对修改封闭
D、对修改开放，对扩展封闭

下列关联关系中，耦合度最强的是（    ）2分
A、继承（extends）
B、依赖（dependency）
C、组合（aggregation）
D、关联（association）

啥是耦合，就是一个模块对另一个模块的依赖程度

| 关系类型   | 中文含义     | 耦合强度   | 生命周期关系 | 生活比喻    | UML    |
| :----- | :------- | :----- | :----- | :------ | ------ |
| **继承** | 是一个      | **最强** | -      | 你和你的父母  |        |
| **组合** | 拥有（不可分割） | 强      | 同生共死   | 人和心脏    | 实心菱形直线 |
| **聚合** | 拥有（可分割）  | 中      | 独立     | 班级和学生   | 空心菱形直线 |
| **关联** | 有一个      | 较弱     | 独立     | 老师和学生   | 直线     |
| **依赖** | 用一下      | **最弱** | 完全无关   | 我和借来用的笔 | 虚线     |

6 下图中，两类的关联关系为（        ）
![Pasted image 20251120163535.png|300](/img/user/accessory/Pasted%20image%2020251120163535.png)A、继承（extends）B、实现（implement）C、 关联（association）D、依赖（dependency）

7、下图中，两类的关联关系是（       ）
![Pasted image 20251120163646.png|150](/img/user/accessory/Pasted%20image%2020251120163646.png)
  
A、实现（implement）B、继承（extends）C、依赖（dependency）D、聚合（aggregation）

8 在uml类图中，表示package访问权限的符号是（        ）2分
A、+B、#C、~D、-

9 关于下图中field2的描述错误的是（     ）
![Pasted image 20251120163853.png|250](/img/user/accessory/Pasted%20image%2020251120163853.png)
A、类的一个属性B、静态的（static）C、int类型，初始值为0D、公共的（public）
注意静态的怎么看

10、组合（composite）模式适用于（）2分
A、保证一个类具有唯一实例
B、分离复杂对象的构建过程和表示，以便同样的构建过程创建出不同表示的对象
C、使得客户对树形结构中的单一对象和组合对象的访问具有一致性
D、解决接口不一致问题

A是单例模式
B是构造器模式
C是组合模式
D是适配器模式？

  
11 关于lazy型单例（Singleton）模式，下列说法错误的是
A、构造方法为私有的（private）
B、代表唯一实例的成员变量，是私有的（private）、静态的（static）
C、获取唯一实例的成员方法，是私有的（private）、静态的（static）
D、唯一实例，是首次被获取时创建的

获取唯一实例的成员方法，应该为public static的

12 适用于 解决“保证一个类只有一个实例”问题 的设计模式是（  ）2分
A、工厂方法（FactoryMethod）
B、生成器（Builder）
C、单例（Singleton）
D、抽象工厂（AbstractFactory）

  
13 抽象工厂模式（AbstractFactory）属于（）2分
A、创建型模式 B、结构型模式 C、行为型模式 D、架构模式

14 命令（Command）模式适用于（     ）
A、保证一个类具有唯一实例
B、将请求封装成对象，对请求进行参数化、排队、日志记录等管理，并提供可撤销的操作。
C、使得客户对树形结构中的单一对象和组合对象的访问具有一致性
D、解决接口不一致问题

15 访问者（Visitor）模式属于（）
A、创建型设计模式B、结构型设计模式C、行为型设计模式D、体系结构模式

16、访问者（Visitor）模式适用于（     ）
A、保证一个类具有唯一实例
B、为一个对象结构中各元素定义新操作，且不用改动元素的类。
C、使得客户对树形结构中的单一对象和组合对象的访问具有一致性
D、解决接口不一致问题

17 迭代器（Iterator）模式适用于（     ）
A、分离聚合类和实现元素遍历功能，提供顺序访问聚合对象的元素的方式，而无需该聚合对象暴露其内部表示。
B、为子系统的一系列接口提供一个统一的高层次接口。
C、分离继承结构中的抽象和实现，使得两个部分可以独立地灵活扩展。
D、解决接口不一致问题

分离继承结构中的抽象和实现，使得两个部分可以独立地灵活扩展 -- 是桥接模式

  
18 桥接（Bridge）模式适用于（     ）
A、保证一个类具有唯一实例
B、为子系统的一系列接口提供一个统一的高层次接口。
C、分离继承结构中的抽象和实现，使得两个部分可以独立地灵活扩展。
D、解决接口不一致问题

19 外观（Facade）模式适用于（     ）
A、保证一个类具有唯一实例
B、为子系统的一系列接口提供一个统一的高层次接口。
C、使得客户对树形结构中的单一对象和组合对象的访问具有一致性
D、解决接口不一致问题

适配器（adpater）模式适用于（）
A、保证一个类具有唯一实例
B、分离复杂对象的构建过程和表示，以便同样的构建过程创建出不同表示的对象
C、使得客户对树形结构中的单一对象和组合对象的访问具有一致性
D、解决接口不一致问题

下面是使用简单模式完成的设计类图，请修改为使用工厂方法模式。
![Pasted image 20251120165002.png](/img/user/accessory/Pasted%20image%2020251120165002.png)

2、阅读后面的代码，完成如下问题： (1) 根据代码画出uml类图 (2) 代码设计使用了什么模式？
```java
import java.util.Iterator;
import java.util.ArrayList;

public interface Aggregate<T> {
    T get(int index);
    void add(T e);
    void remove(T e);
    int total();
    Iterator<T> DWordsIterator();
}

class NamesAggregate implements Aggregate<String> {
    private ArrayList<String> names = new ArrayList<>();

    public NamesAggregate() {
    }

    @Override
    public String get(int index) {
        return names.get(index);
    }

    @Override
    public void add(String e) {
        names.add(e);
    }

    @Override
    public void remove(String e) {
        names.remove(e);
    }

    @Override
    public int total() {
        return names.size();
    }

    @Override
    public Iterator<String> DWordsIterator() {
        return new DWordsNameIterator(this); // 这里方法名可能打错了，应该是 DWordsIterator
    }
}

public class DWordsNameIterator implements Iterator<String> {
    private final Aggregate<String> aggr;
    private int current = 0, next = 0;

    public DWordsNameIterator(Aggregate<String> namesAggr) {
        aggr = namesAggr;
    }

    @Override
    public boolean hasNext() {
        boolean result = false;
        for (int i = current; i < aggr.total(); i++) {
            if (aggr.get(i).length() == 2) {
                result = true;
                next = i;
                break;
            }
        }
        return result;
    }

    @Override
    public String next() {
        current = next + 1;
        return aggr.get(next);
    }
}

public class Client {
    public static void main(String[] args) {
        NamesAggregate aggr = new NamesAggregate();
        aggr.add("张芳");
        aggr.add("张盛国");
        aggr.add("王新");
        aggr.add("李月月");
        aggr.add("李晓");
        aggr.add("赵中华"); // 这个在图中被部分遮挡了
        Iterator<String> it = aggr.DWordsIterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}

```

![Pasted image 20251120214004.png](/img/user/accessory/Pasted%20image%2020251120214004.png)

